(self.webpackChunk_masatomakino_pixijs_mouse_event_transmitter=self.webpackChunk_masatomakino_pixijs_mouse_event_transmitter||[]).push([[736],{720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EseUJBQXNCOztBQUV0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsTUFBTTtBQUNOLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0Msd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsd0RBQXdEOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzPzllNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgdmFyIHAgPSBjLm5leHQ7XG4gICAgd2hpbGUgKHAgIT09IGEpIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcih4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAoIWJyaWRnZSkge1xuICAgICAgICByZXR1cm4gb3V0ZXJOb2RlO1xuICAgIH1cblxuICAgIHZhciBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKGJyaWRnZSwgaG9sZSk7XG5cbiAgICAvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICBmaWx0ZXJQb2ludHMoYnJpZGdlUmV2ZXJzZSwgYnJpZGdlUmV2ZXJzZS5uZXh0KTtcbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKGJyaWRnZSwgYnJpZGdlLm5leHQpO1xufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAoeCAtIG1pblgpICogaW52U2l6ZSB8IDA7XG4gICAgeSA9ICh5IC0gbWluWSkgKiBpbnZTaXplIHwgMDtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgPj0gKGF4IC0gcHgpICogKGN5IC0gcHkpICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSA+PSAoYnggLSBweCkgKiAoYXkgLSBweSkgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpID49IChjeCAtIHB4KSAqIChieSAtIHB5KTtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgdmFyIG8yID0gc2lnbihhcmVhKHAxLCBxMSwgcTIpKTtcbiAgICB2YXIgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuICAgIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gMDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///720\n")},1379:module=>{eval("\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3OS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3ZnLXBhdGgvaW5kZXguanM/NzY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuLyoqXG4gKiBleHBlY3RlZCBhcmd1bWVudCBsZW5ndGhzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBsZW5ndGggPSB7YTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMH1cblxuLyoqXG4gKiBzZWdtZW50IHBhdHRlcm5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cblxudmFyIHNlZ21lbnQgPSAvKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnXG5cbi8qKlxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxuICogb2YgY29tbWFuZHMgd2hlcmUgZWFjaCBjb21tYW5kIGlzIGFuIEFycmF5IG9mIHRoZVxuICogZm9ybSBgW2NvbW1hbmQsIGFyZzEsIGFyZzIsIC4uLl1gXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcblx0dmFyIGRhdGEgPSBbXVxuXHRwYXRoLnJlcGxhY2Uoc2VnbWVudCwgZnVuY3Rpb24oXywgY29tbWFuZCwgYXJncyl7XG5cdFx0dmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKClcblx0XHRhcmdzID0gcGFyc2VWYWx1ZXMoYXJncylcblxuXHRcdC8vIG92ZXJsb2FkZWQgbW92ZVRvXG5cdFx0aWYgKHR5cGUgPT0gJ20nICYmIGFyZ3MubGVuZ3RoID4gMikge1xuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgMikpKVxuXHRcdFx0dHlwZSA9ICdsJ1xuXHRcdFx0Y29tbWFuZCA9IGNvbW1hbmQgPT0gJ20nID8gJ2wnIDogJ0wnXG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PSBsZW5ndGhbdHlwZV0pIHtcblx0XHRcdFx0YXJncy51bnNoaWZ0KGNvbW1hbmQpXG5cdFx0XHRcdHJldHVybiBkYXRhLnB1c2goYXJncylcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmxlbmd0aCA8IGxlbmd0aFt0eXBlXSkgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgcGF0aCBkYXRhJylcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIGxlbmd0aFt0eXBlXSkpKVxuXHRcdH1cblx0fSlcblx0cmV0dXJuIGRhdGFcbn1cblxudmFyIG51bWJlciA9IC8tP1swLTldKlxcLj9bMC05XSsoPzplWy0rXT9cXGQrKT8vaWdcblxuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncykge1xuXHR2YXIgbnVtYmVycyA9IGFyZ3MubWF0Y2gobnVtYmVyKVxuXHRyZXR1cm4gbnVtYmVycyA/IG51bWJlcnMubWFwKE51bWJlcikgOiBbXVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1379\n")},2218:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/YTkyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2218\n")},4162:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ Cache)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4796);\n/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9879);\n\n\n\n"use strict";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__/* .convertToList */ .S)(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__/* .warn */ .Z)(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2Mi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDtBQUNPOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzRUFBSSxzQkFBc0IsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQWE7QUFDOUI7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFJO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNFQUFJLHNCQUFzQixLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanM/ZWEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhY2hlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NhY2hlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKiogQ2xlYXIgYWxsIGVudHJpZXMuICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhY2hlTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHNcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2tcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGVudHJ5IGJ5IGtleVxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZ2V0XG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHdhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBieSBrZXkgb3Iga2V5cyBuYW1lXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9yIGtleXMgdG8gc2V0XG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGUgY2FjaGUgb3IgZnJvbSB3aGljaCBjYWNoZWFibGUgYXNzZXRzIHdpbGwgYmUgZGVyaXZlZC5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbnZlcnRUb0xpc3Qoa2V5KTtcbiAgICBsZXQgY2FjaGVhYmxlQXNzZXRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICBpZiAocGFyc2VyLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNhY2hlYWJsZUFzc2V0cyA9IHBhcnNlci5nZXRDYWNoZWFibGVBc3NldHMoa2V5cywgdmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FjaGVhYmxlTWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhjYWNoZWFibGVBc3NldHMgfHwge30pKTtcbiAgICBpZiAoIWNhY2hlYWJsZUFzc2V0cykge1xuICAgICAga2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGNhY2hlYWJsZU1hcC5zZXQoa2V5MiwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5cyA9IFsuLi5jYWNoZWFibGVNYXAua2V5cygpXTtcbiAgICBjb25zdCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLnNldChrZXkyLCBjYWNoZWRBc3NldHMpO1xuICAgIH0pO1xuICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBjYWNoZWFibGVBc3NldHMgPyBjYWNoZWFibGVBc3NldHNba2V5Ml0gOiB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoa2V5MikgJiYgdGhpcy5fY2FjaGUuZ2V0KGtleTIpICE9PSB2YWwpIHtcbiAgICAgICAgd2FybihcIltDYWNoZV0gYWxyZWFkeSBoYXMga2V5OlwiLCBrZXkyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlLnNldChrZXkyLCBjYWNoZWFibGVNYXAuZ2V0KGtleTIpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGVudHJ5IGJ5IGtleVxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyByZW1vdmUgYW55IGFzc29jaWF0ZWQgYWxpYXMgZnJvbSB0aGUgY2FjaGUgYWxzby5cbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIHdhcm4oYFtBc3NldHNdIEFzc2V0IGlkICR7a2V5fSB3YXMgbm90IGZvdW5kIGluIHRoZSBDYWNoZWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGNhY2hlS2V5cyA9IGNhY2hlTWFwLmNhY2hlS2V5cztcbiAgICBjYWNoZUtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGtleTIpO1xuICAgIH0pO1xuICAgIGNhY2hlTWFwLmtleXMuZm9yRWFjaCgoa2V5MikgPT4ge1xuICAgICAgdGhpcy5fY2FjaGVNYXAuZGVsZXRlKGtleTIpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBBbGwgbG9hZGVyIHBhcnNlcnMgcmVnaXN0ZXJlZCAqL1xuICBnZXQgcGFyc2VycygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VycztcbiAgfVxufVxuY29uc3QgQ2FjaGUgPSBuZXcgQ2FjaGVDbGFzcygpO1xuXG5leHBvcnQgeyBDYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4162\n')},4334:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ LoaderParserPriority)\n/* harmony export */ });\n\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMzNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFRztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy9Mb2FkZXJQYXJzZXIubWpzPzk5MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTG9hZGVyUGFyc2VyUHJpb3JpdHkgPSAvKiBAX19QVVJFX18gKi8gKChMb2FkZXJQYXJzZXJQcmlvcml0eTIpID0+IHtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkxvd1wiXSA9IDBdID0gXCJMb3dcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIk5vcm1hbFwiXSA9IDFdID0gXCJOb3JtYWxcIjtcbiAgTG9hZGVyUGFyc2VyUHJpb3JpdHkyW0xvYWRlclBhcnNlclByaW9yaXR5MltcIkhpZ2hcIl0gPSAyXSA9IFwiSGlnaFwiO1xuICByZXR1cm4gTG9hZGVyUGFyc2VyUHJpb3JpdHkyO1xufSkoTG9hZGVyUGFyc2VyUHJpb3JpdHkgfHwge30pO1xuXG5leHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyUGFyc2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4334\n')},9879:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ convertToList)\n/* harmony export */ });\n\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvdXRpbHMvY29udmVydFRvTGlzdC5tanM/ZWMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvbnZlcnRUb0xpc3QgPSAoaW5wdXQsIHRyYW5zZm9ybSwgZm9yY2VUcmFuc2Zvcm0gPSBmYWxzZSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG4gIGlmICghdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgfHwgZm9yY2VUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGNvbnZlcnRUb0xpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnRUb0xpc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9879\n')},8479:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ copySearchParams)\n/* harmony export */ });\n\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hc3NldHMvdXRpbHMvY29weVNlYXJjaFBhcmFtcy5tanM/ODIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGNvcHlTZWFyY2hQYXJhbXMgPSAodGFyZ2V0VXJsLCBzb3VyY2VVcmwpID0+IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gc291cmNlVXJsLnNwbGl0KFwiP1wiKVsxXTtcbiAgaWYgKHNlYXJjaFBhcmFtcykge1xuICAgIHRhcmdldFVybCArPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFVybDtcbn07XG5cbmV4cG9ydCB7IGNvcHlTZWFyY2hQYXJhbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHlTZWFyY2hQYXJhbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8479\n')},8409:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* binding */ Color)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/color/Color.mjs\n\n\n\n"use strict";\nk([names]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter\'s parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter\'s parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set Color#value to null");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexidecimal string.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHex(); // returns "#ffffff"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexidecimal string with alpha.\n   * @example\n   * import { Color } from \'pixi.js\';\n   * new Color(\'white\').toHexa(); // returns "#ffffffff"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from \'pixi.js\';\n   * Color.isColorLike(\'white\'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from \'pixi.js\';\n * Color.shared.setValue(0xffffff).toHex(); // \'#ffffff\'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\n\n//# sourceMappingURL=Color.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsRUFBRSxJQUFJLFVBQVUsRUFBRTtBQUM3RDs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvcmQvaW5kZXgubWpzPzJhNmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3JkL3BsdWdpbnMvbmFtZXMubWpzPzFjNjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvY29sb3IvQ29sb3IubWpzPzM2MGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxvPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0saT0vXiMoWzAtOWEtZl17Myw4fSkkL2kscz1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLGE9TWF0aC5tYXgodCxuLGUpLG89YS1NYXRoLm1pbih0LG4sZSksaT1vP2E9PT10PyhuLWUpL286YT09PW4/MisoZS10KS9vOjQrKHQtbikvbzowO3JldHVybntoOjYwKihpPDA/aSs2OmkpLHM6YT9vL2EqMTAwOjAsdjphLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIGE9TWF0aC5mbG9vcih0KSxvPWUqKDEtbiksaT1lKigxLSh0LWEpKm4pLHM9ZSooMS0oMS10K2EpKm4pLGg9YSU2O3JldHVybntyOjI1NSpbZSxpLG8sbyxzLGVdW2hdLGc6MjU1KltzLGUsZSxpLG8sb11baF0sYjoyNTUqW28sbyxzLGUsZSxpXVtoXSxhOnV9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGQ9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxjPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHA9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PWkuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOmEoe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxwLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxhPWcoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKGEpfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLG89ci5hLGk9dm9pZCAwPT09bz8xOm87cmV0dXJuIHQobikmJnQoZSkmJnQodSk/YSh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIoaSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLGE9ci5hLG89dm9pZCAwPT09YT8xOmE7aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgaT1nKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihvKX0pO3JldHVybiBmKGkpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGE9ci5zLG89ci52LGk9ci5hLHM9dm9pZCAwPT09aT8xOmk7aWYoIXQobil8fCF0KGEpfHwhdChvKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIoYSksdjpOdW1iZXIobyksYTpOdW1iZXIocyl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LEk9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEg9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSwkPWZ1bmN0aW9uKHIsdCl7dmFyIG49YyhyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSxqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSCh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9byh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLGk9KGE9ci5hKTwxP3MobigyNTUqYSkpOlwiXCIsXCIjXCIrcyh0KStzKGUpK3ModSkraTt2YXIgcix0LGUsdSxhLGl9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZChjKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWQoYyh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdyh7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHcoTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KCQodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3coe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1jKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT13KHIpLnRvSGV4KCl9LHJ9KCksdz1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIGo/cjpuZXcgaihyKX0sUz1bXSxrPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXtTLmluZGV4T2Yocik8MCYmKHIoaix5KSxTLnB1c2gocikpfSl9LEU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGooe3I6MjU1Kk1hdGgucmFuZG9tKCksZzoyNTUqTWF0aC5yYW5kb20oKSxiOjI1NSpNYXRoLnJhbmRvbSgpfSl9O2V4cG9ydHtqIGFzIENvbG9yZCx3IGFzIGNvbG9yZCxrIGFzIGV4dGVuZCxJIGFzIGdldEZvcm1hdCxFIGFzIHJhbmRvbX07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG49clt0aGlzLnRvSGV4KCldO2lmKG4pcmV0dXJuIG47aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbz10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9byxpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9XG4iLCJpbXBvcnQgeyBleHRlbmQsIGNvbG9yZCB9IGZyb20gJ0BwaXhpL2NvbG9yZCc7XG5pbXBvcnQgbmFtZXNQbHVnaW4gZnJvbSAnQHBpeGkvY29sb3JkL3BsdWdpbnMvbmFtZXMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuZChbbmFtZXNQbHVnaW5dKTtcbmNvbnN0IF9Db2xvciA9IGNsYXNzIF9Db2xvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbG9yU291cmNlfSB2YWx1ZSAtIE9wdGlvbmFsIHZhbHVlIHRvIHVzZSwgaWYgbm90IHByb3ZpZGVkLCB3aGl0ZSBpcyB1c2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUgPSAxNjc3NzIxNSkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9jb21wb25lbnRzID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLl9jb21wb25lbnRzLmZpbGwoMSk7XG4gICAgdGhpcy5faW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBHZXQgcmVkIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCByZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gIH1cbiAgLyoqIEdldCBncmVlbiBjb21wb25lbnQgKDAgLSAxKSAqL1xuICBnZXQgZ3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMV07XG4gIH1cbiAgLyoqIEdldCBibHVlIGNvbXBvbmVudCAoMCAtIDEpICovXG4gIGdldCBibHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzJdO1xuICB9XG4gIC8qKiBHZXQgYWxwaGEgY29tcG9uZW50ICgwIC0gMSkgKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzNdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBzZWUgQ29sb3IudmFsdWVcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBjb2xvciBzb3VyY2UuXG4gICAqXG4gICAqIFdoZW4gc2V0dGluZzpcbiAgICogLSBTZXR0aW5nIHRvIGFuIGluc3RhbmNlIG9mIGBDb2xvcmAgd2lsbCBjb3B5IGl0cyBjb2xvciBzb3VyY2UgYW5kIGNvbXBvbmVudHMuXG4gICAqIC0gT3RoZXJ3aXNlLCBgQ29sb3JgIHdpbGwgdHJ5IHRvIG5vcm1hbGl6ZSB0aGUgY29sb3Igc291cmNlIGFuZCBzZXQgdGhlIGNvbXBvbmVudHMuXG4gICAqICAgSWYgdGhlIGNvbG9yIHNvdXJjZSBpcyBpbnZhbGlkLCBhbiBgRXJyb3JgIHdpbGwgYmUgdGhyb3duIGFuZCB0aGUgYENvbG9yYCB3aWxsIGxlZnQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG51bGxgIGluIHRoZSBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZSBpcyBhZGRlZCB0byBtYXRjaCB0aGUgVHlwZVNjcmlwdCBydWxlOiByZXR1cm4gdHlwZSBvZiBnZXR0ZXJcbiAgICogbXVzdCBiZSBhc3NpZ25hYmxlIHRvIGl0cyBzZXR0ZXIncyBwYXJhbWV0ZXIgdHlwZS4gU2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYCB3aWxsIHRocm93IGFuIGBFcnJvcmAuXG4gICAqXG4gICAqIFdoZW4gZ2V0dGluZzpcbiAgICogLSBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBvdmVycmlkZGVuIChlLmcuLCB7QGxpbmsgQ29sb3IubXVsdGlwbHkgbXVsdGlwbHl9LFxuICAgKiAgIHtAbGluayBDb2xvci5wcmVtdWx0aXBseSBwcmVtdWx0aXBseX0gb3Ige0BsaW5rIENvbG9yLnJvdW5kIHJvdW5kfSkuXG4gICAqIC0gT3RoZXJ3aXNlLCB0aGUgY29sb3Igc291cmNlIHVzZWQgd2hlbiBzZXR0aW5nIGlzIHJldHVybmVkLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX0NvbG9yKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlLl92YWx1ZSk7XG4gICAgICB0aGlzLl9pbnQgPSB2YWx1ZS5faW50O1xuICAgICAgdGhpcy5fY29tcG9uZW50cy5zZXQodmFsdWUuX2NvbXBvbmVudHMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgQ29sb3IjdmFsdWUgdG8gbnVsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsIHx8ICF0aGlzLl9pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX25vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2Nsb25lU291cmNlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29weSBhIGNvbG9yIHNvdXJjZSBpbnRlcm5hbGx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBDb2xvciBzb3VyY2VcbiAgICovXG4gIF9jbG9uZVNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IC4uLnZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2sgZm9yIGNvbG9yIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB2YWx1ZTEgLSBGaXJzdCBjb2xvciBzb3VyY2VcbiAgICogQHBhcmFtIHZhbHVlMiAtIFNlY29uZCBjb2xvciBzb3VyY2VcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBzb3VyY2VzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBfaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiB2YWx1ZTI7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZTEgPT09IFwibnVtYmVyXCIgfHwgdHlwZTEgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTEpICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyh2YWx1ZTEpO1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBSR0JBIGNvbG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvUmdiKCk7IC8vIHJldHVybnMgeyByOiAxLCBnOiAxLCBiOiAxLCBhOiAxIH1cbiAgICovXG4gIHRvUmdiYSgpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIFJHQiBjb2xvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcignd2hpdGUnKS50b1JnYigpOyAvLyByZXR1cm5zIHsgcjogMSwgZzogMSwgYjogMSB9XG4gICAqL1xuICB0b1JnYigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgfVxuICAvKiogQ29udmVydCB0byBhIENTUy1zdHlsZSByZ2JhIHN0cmluZzogYHJnYmEoMjU1LDI1NSwyNTUsMS4wKWAuICovXG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgaWYgKCF0aGlzLl9hcnJheVJnYikge1xuICAgICAgdGhpcy5fYXJyYXlSZ2IgPSBbXTtcbiAgICB9XG4gICAgb3V0ID0gb3V0IHx8IHRoaXMuX2FycmF5UmdiO1xuICAgIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiYSkge1xuICAgICAgdGhpcy5fYXJyYXlSZ2JhID0gW107XG4gICAgfVxuICAgIG91dCA9IG91dCB8fCB0aGlzLl9hcnJheVJnYmE7XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9SZ2JBcnJheShvdXQpIHtcbiAgICBpZiAoIXRoaXMuX2FycmF5UmdiKSB7XG4gICAgICB0aGlzLl9hcnJheVJnYiA9IFtdO1xuICAgIH1cbiAgICBvdXQgPSBvdXQgfHwgdGhpcy5fYXJyYXlSZ2I7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9OdW1iZXIoKTsgLy8gcmV0dXJucyAxNjc3NzIxNVxuICAgKi9cbiAgdG9OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIEJHUiBudW1iZXJcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKDB4ZmZjYzk5KS50b0Jnck51bWJlcigpOyAvLyByZXR1cm5zIDB4OTljY2ZmXG4gICAqL1xuICB0b0Jnck51bWJlcigpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiAoYiA8PCAxNikgKyAoZyA8PCA4KSArIHI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIgaW4gbGl0dGxlIGVuZGlhbiBmb3JtYXQgKGUuZy4sIEJCR0dSUikuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIG5ldyBDb2xvcigweGZmY2M5OSkudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTsgLy8gcmV0dXJucyAweDk5Y2NmZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjb2xvciBhcyBhIG51bWJlciBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cbiAgICovXG4gIHRvTGl0dGxlRW5kaWFuTnVtYmVyKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5faW50O1xuICAgIHJldHVybiAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgNjUyODApICsgKCh2YWx1ZSAmIDI1NSkgPDwgMTYpO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSB3aXRoIGFub3RoZXIgY29sb3IuIFRoaXMgYWN0aW9uIGlzIGRlc3RydWN0aXZlLCBhbmQgd2lsbFxuICAgKiBvdmVycmlkZSB0aGUgcHJldmlvdXMgYHZhbHVlYCBwcm9wZXJ0eSB0byBiZSBgbnVsbGAuXG4gICAqIEBwYXJhbSB7Q29sb3JTb3VyY2V9IHZhbHVlIC0gVGhlIGNvbG9yIHRvIG11bHRpcGx5IGJ5LlxuICAgKi9cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IuX3RlbXAuc2V0VmFsdWUodmFsdWUpLl9jb21wb25lbnRzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMF0gKj0gcjtcbiAgICB0aGlzLl9jb21wb25lbnRzWzFdICo9IGc7XG4gICAgdGhpcy5fY29tcG9uZW50c1syXSAqPSBiO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gKj0gYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBjb2xvciB0byBhIHByZW11bHRpcGxpZWQgYWxwaGEgZm9ybWF0LiBUaGlzIGFjdGlvbiBpcyBkZXN0cnVjdGl2ZSwgYW5kIHdpbGxcbiAgICogb3ZlcnJpZGUgdGhlIHByZXZpb3VzIGB2YWx1ZWAgcHJvcGVydHkgdG8gYmUgYG51bGxgLlxuICAgKiBAcGFyYW0gYWxwaGEgLSBUaGUgYWxwaGEgdG8gbXVsdGlwbHkgYnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FwcGx5VG9SR0I9dHJ1ZV0gLSBXaGV0aGVyIHRvIHByZW11bHRpcGx5IFJHQiBjaGFubmVscy5cbiAgICogQHJldHVybnMge0NvbG9yfSAtIEl0c2VsZi5cbiAgICovXG4gIHByZW11bHRpcGx5KGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhcHBseVRvUkdCKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdICo9IGFscGhhO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1sxXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gKj0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBvbmVudHNbM10gPSBhbHBoYTtcbiAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQcmVtdWx0aXBsaWVzIGFscGhhIHdpdGggY3VycmVudCBjb2xvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gVGhlIGFscGhhIHRvIG11bHRpcGx5IGJ5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBseVRvUkdCPXRydWVdIC0gV2hldGhlciB0byBwcmVtdWx0aXBseSBSR0IgY2hhbm5lbHMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbnQgbXVsdGlwbGllZCBieSBhbHBoYVxuICAgKi9cbiAgdG9QcmVtdWx0aXBsaWVkKGFscGhhLCBhcHBseVRvUkdCID0gdHJ1ZSkge1xuICAgIGlmIChhbHBoYSA9PT0gMSkge1xuICAgICAgcmV0dXJuICgyNTUgPDwgMjQpICsgdGhpcy5faW50O1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgIHJldHVybiBhcHBseVRvUkdCID8gMCA6IHRoaXMuX2ludDtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl9pbnQgPj4gMTYgJiAyNTU7XG4gICAgbGV0IGcgPSB0aGlzLl9pbnQgPj4gOCAmIDI1NTtcbiAgICBsZXQgYiA9IHRoaXMuX2ludCAmIDI1NTtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgciA9IHIgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgICBnID0gZyAqIGFscGhhICsgMC41IHwgMDtcbiAgICAgIGIgPSBiICogYWxwaGEgKyAwLjUgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAgICogbmV3IENvbG9yKCd3aGl0ZScpLnRvSGV4KCk7IC8vIHJldHVybnMgXCIjZmZmZmZmXCJcbiAgICovXG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGhleFN0cmluZyA9IHRoaXMuX2ludC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGAjJHtcIjAwMDAwMFwiLnN1YnN0cmluZygwLCA2IC0gaGV4U3RyaW5nLmxlbmd0aCkgKyBoZXhTdHJpbmd9YDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCB0byBhIGhleGlkZWNpbWFsIHN0cmluZyB3aXRoIGFscGhhLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKiBuZXcgQ29sb3IoJ3doaXRlJykudG9IZXhhKCk7IC8vIHJldHVybnMgXCIjZmZmZmZmZmZcIlxuICAgKi9cbiAgdG9IZXhhKCkge1xuICAgIGNvbnN0IGFscGhhVmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMuX2NvbXBvbmVudHNbM10gKiAyNTUpO1xuICAgIGNvbnN0IGFscGhhU3RyaW5nID0gYWxwaGFWYWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIFwiMDBcIi5zdWJzdHJpbmcoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZztcbiAgfVxuICAvKipcbiAgICogU2V0IGFscGhhLCBzdWl0YWJsZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBwYXJhbSBhbHBoYVxuICAgKi9cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gdGhpcy5fY2xhbXAoYWxwaGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHZhbHVlIGludG8gcmdiYVxuICAgKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZVxuICAgKi9cbiAgX25vcm1hbGl6ZSh2YWx1ZSkge1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuICAgIGxldCBhO1xuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE2Nzc3MjE1KSB7XG4gICAgICBjb25zdCBpbnQgPSB2YWx1ZTtcbiAgICAgIHIgPSAoaW50ID4+IDE2ICYgMjU1KSAvIDI1NTtcbiAgICAgIGcgPSAoaW50ID4+IDggJiAyNTUpIC8gMjU1O1xuICAgICAgYiA9IChpbnQgJiAyNTUpIC8gMjU1O1xuICAgICAgYSA9IDE7XG4gICAgfSBlbHNlIGlmICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpICYmIHZhbHVlLmxlbmd0aCA+PSAzICYmIHZhbHVlLmxlbmd0aCA8PSA0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2NsYW1wKHZhbHVlKTtcbiAgICAgIFtyLCBnLCBiLCBhID0gMV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUsIDAsIDI1NSk7XG4gICAgICBbciwgZywgYiwgYSA9IDI1NV0gPSB2YWx1ZTtcbiAgICAgIHIgLz0gMjU1O1xuICAgICAgZyAvPSAyNTU7XG4gICAgICBiIC89IDI1NTtcbiAgICAgIGEgLz0gMjU1O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF9Db2xvci5IRVhfUEFUVEVSTi5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFsdWUgPSBgIyR7bWF0Y2hbMl19YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcmQodmFsdWUpO1xuICAgICAgaWYgKGNvbG9yLmlzVmFsaWQoKSkge1xuICAgICAgICAoeyByLCBnLCBiLCBhIH0gPSBjb2xvci5yZ2JhKTtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSA9IHI7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzFdID0gZztcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBiO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1szXSA9IGE7XG4gICAgICB0aGlzLl9yZWZyZXNoSW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgY29sb3IgJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqIFJlZnJlc2ggdGhlIGludGVybmFsIGNvbG9yIHJnYiBudW1iZXIgKi9cbiAgX3JlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsYW1wcyB2YWx1ZXMgdG8gYSByYW5nZS4gV2lsbCBvdmVycmlkZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUocykgdG8gY2xhbXBcbiAgICogQHBhcmFtIG1pbiAtIE1pbmltdW0gdmFsdWVcbiAgICogQHBhcmFtIG1heCAtIE1heGltdW0gdmFsdWVcbiAgICovXG4gIF9jbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgdmFsdWUuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgdmFsdWVbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgY29sb3ItbGlrZSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBjb2xvci1saWtlIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IENvbG9yIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqIENvbG9yLmlzQ29sb3JMaWtlKCd3aGl0ZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoMHhmZmZmZmYpOyAvLyByZXR1cm5zIHRydWVcbiAgICogQ29sb3IuaXNDb2xvckxpa2UoWzEsIDEsIDFdKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqL1xuICBzdGF0aWMgaXNDb2xvckxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIF9Db2xvciB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCB8fCB2YWx1ZS5yICE9PSB2b2lkIDAgJiYgdmFsdWUuZyAhPT0gdm9pZCAwICYmIHZhbHVlLmIgIT09IHZvaWQgMCAmJiB2YWx1ZS5hICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgfHwgdmFsdWUuaCAhPT0gdm9pZCAwICYmIHZhbHVlLnMgIT09IHZvaWQgMCAmJiB2YWx1ZS5sICE9PSB2b2lkIDAgJiYgdmFsdWUuYSAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwIHx8IHZhbHVlLmggIT09IHZvaWQgMCAmJiB2YWx1ZS5zICE9PSB2b2lkIDAgJiYgdmFsdWUudiAhPT0gdm9pZCAwICYmIHZhbHVlLmEgIT09IHZvaWQgMDtcbiAgfVxufTtcbi8qKlxuICogRGVmYXVsdCBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwaXhpLmpzJztcbiAqIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSgweGZmZmZmZikudG9IZXgoKTsgLy8gJyNmZmZmZmYnXG4gKi9cbl9Db2xvci5zaGFyZWQgPSBuZXcgX0NvbG9yKCk7XG4vKipcbiAqIFRlbXBvcmFyeSBDb2xvciBvYmplY3QgZm9yIHN0YXRpYyB1c2VzIGludGVybmFsbHkuXG4gKiBBcyB0byBub3QgY29uZmxpY3Qgd2l0aCBDb2xvci5zaGFyZWQuXG4gKiBAaWdub3JlXG4gKi9cbl9Db2xvci5fdGVtcCA9IG5ldyBfQ29sb3IoKTtcbi8qKiBQYXR0ZXJuIGZvciBoZXggc3RyaW5ncyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuX0NvbG9yLkhFWF9QQVRURVJOID0gL14oI3wweCk/KChbYS1mMC05XXszfSl7MSwyfShbYS1mMC05XXsyfSk/KSQvaTtcbmxldCBDb2xvciA9IF9Db2xvcjtcblxuZXhwb3J0IHsgQ29sb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8409\n')},3646:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  z: () => (/* binding */ DOMAdapter)\n});\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs\n\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement("canvas");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, "text/xml");\n  }\n};\n\n\n//# sourceMappingURL=BrowserAdapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs\n\n\n"use strict";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3JCMkU7O0FBRTNFO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZW52aXJvbm1lbnQtYnJvd3Nlci9Ccm93c2VyQWRhcHRlci5tanM/MzA5NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcz81ZDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIGNyZWF0ZUNhbnZhczogKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuICB9XG59O1xuXG5leHBvcnQgeyBCcm93c2VyQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlckFkYXB0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tICcuLi9lbnZpcm9ubWVudC1icm93c2VyL0Jyb3dzZXJBZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IGN1cnJlbnRBZGFwdGVyID0gQnJvd3NlckFkYXB0ZXI7XG5jb25zdCBET01BZGFwdGVyID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhZGFwdGVyLlxuICAgKiBAcmV0dXJucyB7ZW52aXJvbm1lbnQuQWRhcHRlcn0gVGhlIGN1cnJlbnQgYWRhcHRlci5cbiAgICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gY3VycmVudEFkYXB0ZXI7XG4gIH0sXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGFkYXB0ZXIuXG4gICAqIEBwYXJhbSBhZGFwdGVyIC0gVGhlIG5ldyBhZGFwdGVyLlxuICAgKi9cbiAgc2V0KGFkYXB0ZXIpIHtcbiAgICBjdXJyZW50QWRhcHRlciA9IGFkYXB0ZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IERPTUFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3646\n')},3489:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rw: () => (/* binding */ extensions),\n/* harmony export */   nw: () => (/* binding */ ExtensionType)\n/* harmony export */ });\n/* unused harmony export normalizeExtensionPriority */\n\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["WebGLPipes"] = "webgl-pipes";\n  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";\n  ExtensionType2["WebGLSystem"] = "webgl-system";\n  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";\n  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";\n  ExtensionType2["WebGPUSystem"] = "webgpu-system";\n  ExtensionType2["CanvasSystem"] = "canvas-system";\n  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";\n  ExtensionType2["CanvasPipes"] = "canvas-pipes";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  ExtensionType2["MaskEffect"] = "mask-effect";\n  ExtensionType2["BlendMode"] = "blend-mode";\n  ExtensionType2["TextureSource"] = "texture-source";\n  ExtensionType2["Environment"] = "environment";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\n\n//# sourceMappingURL=Extensions.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakYsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw0QkFBNEI7QUFDeEcsbUZBQW1GLDRCQUE0QjtBQUMvRyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRTtBQUNqRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanM/NjViYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBFeHRlbnNpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRXh0ZW5zaW9uVHlwZTIpID0+IHtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBcHBsaWNhdGlvblwiXSA9IFwiYXBwbGljYXRpb25cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHTFBpcGVzXCJdID0gXCJ3ZWJnbC1waXBlc1wiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdMUGlwZXNBZGFwdG9yXCJdID0gXCJ3ZWJnbC1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR0xTeXN0ZW1cIl0gPSBcIndlYmdsLXN5c3RlbVwiO1xuICBFeHRlbnNpb25UeXBlMltcIldlYkdQVVBpcGVzXCJdID0gXCJ3ZWJncHUtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJXZWJHUFVQaXBlc0FkYXB0b3JcIl0gPSBcIndlYmdwdS1waXBlcy1hZGFwdG9yXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiV2ViR1BVU3lzdGVtXCJdID0gXCJ3ZWJncHUtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzU3lzdGVtXCJdID0gXCJjYW52YXMtc3lzdGVtXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FudmFzUGlwZXNBZGFwdG9yXCJdID0gXCJjYW52YXMtcGlwZXMtYWRhcHRvclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhbnZhc1BpcGVzXCJdID0gXCJjYW52YXMtcGlwZXNcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJBc3NldFwiXSA9IFwiYXNzZXRcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJMb2FkUGFyc2VyXCJdID0gXCJsb2FkLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlc29sdmVQYXJzZXJcIl0gPSBcInJlc29sdmUtcGFyc2VyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQ2FjaGVQYXJzZXJcIl0gPSBcImNhY2hlLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkRldGVjdGlvblBhcnNlclwiXSA9IFwiZGV0ZWN0aW9uLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIk1hc2tFZmZlY3RcIl0gPSBcIm1hc2stZWZmZWN0XCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQmxlbmRNb2RlXCJdID0gXCJibGVuZC1tb2RlXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiVGV4dHVyZVNvdXJjZVwiXSA9IFwidGV4dHVyZS1zb3VyY2VcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJFbnZpcm9ubWVudFwiXSA9IFwiZW52aXJvbm1lbnRcIjtcbiAgcmV0dXJuIEV4dGVuc2lvblR5cGUyO1xufSkoRXh0ZW5zaW9uVHlwZSB8fCB7fSk7XG5jb25zdCBub3JtYWxpemVFeHRlbnNpb24gPSAoZXh0KSA9PiB7XG4gIGlmICh0eXBlb2YgZXh0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIiAmJiBleHQuZXh0ZW5zaW9uKSB7XG4gICAgaWYgKCFleHQuZXh0ZW5zaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIGV4dC5leHRlbnNpb24gIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IGV4dC5leHRlbnNpb24gfSA6IGV4dC5leHRlbnNpb247XG4gICAgZXh0ID0geyAuLi5tZXRhZGF0YSwgcmVmOiBleHQgfTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGV4dCA9IHsgLi4uZXh0IH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHRlbnNpb24gdHlwZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXh0LnR5cGUgPSBbZXh0LnR5cGVdO1xuICB9XG4gIHJldHVybiBleHQ7XG59O1xuY29uc3Qgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eTtcbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIC8qKiBAaWdub3JlICovXG4gIF9hZGRIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9yZW1vdmVIYW5kbGVyczoge30sXG4gIC8qKiBAaWdub3JlICovXG4gIF9xdWV1ZToge30sXG4gIC8qKlxuICAgKiBSZW1vdmUgZXh0ZW5zaW9ucyBmcm9tIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBFeHRlbnNpb25zIHRvIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm5zIHtleHRlbnNpb25zfSBGb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZW1vdmUoLi4uZXh0ZW5zaW9uczIpIHtcbiAgICBleHRlbnNpb25zMi5tYXAobm9ybWFsaXplRXh0ZW5zaW9uKS5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgIGV4dC50eXBlLmZvckVhY2goKHR5cGUpID0+IHRoaXMuX3JlbW92ZUhhbmRsZXJzW3R5cGVdPy4oZXh0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBSZWdpc3RlciBuZXcgZXh0ZW5zaW9ucyB3aXRoIFBpeGlKUy5cbiAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBUaGUgc3ByZWFkIG9mIGV4dGVuc2lvbnMgdG8gYWRkIHRvIFBpeGlKUy5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZCguLi5leHRlbnNpb25zMikge1xuICAgIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICBpZiAoIWhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgcXVldWVbdHlwZV0gPSBxdWV1ZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICBxdWV1ZVt0eXBlXT8ucHVzaChleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzW3R5cGVdPy4oZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGV4dGVuc2lvbnMgYnkgbmFtZS5cbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgZXh0ZW5zaW9uIHR5cGUuXG4gICAqIEBwYXJhbSBvbkFkZCAgLSBGdW5jdGlvbiBoYW5kbGVyIHdoZW4gZXh0ZW5zaW9ucyBhcmUgYWRkZWQvcmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHBhcmFtIG9uUmVtb3ZlICAtIEZ1bmN0aW9uIGhhbmRsZXIgd2hlbiBleHRlbnNpb25zIGFyZSByZW1vdmVkL3VucmVnaXN0ZXJlZCB7QGxpbmsgU3RyaWN0RXh0ZW5zaW9uRm9ybWF0fS5cbiAgICogQHJldHVybnMge2V4dGVuc2lvbnN9IEZvciBjaGFpbmluZy5cbiAgICovXG4gIGhhbmRsZSh0eXBlLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBhZGRIYW5kbGVycyA9IHRoaXMuX2FkZEhhbmRsZXJzO1xuICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gdGhpcy5fcmVtb3ZlSGFuZGxlcnM7XG4gICAgaWYgKGFkZEhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4dGVuc2lvbiB0eXBlICR7dHlwZX0gYWxyZWFkeSBoYXMgYSBoYW5kbGVyYCk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXJzW3R5cGVdID0gb25BZGQ7XG4gICAgcmVtb3ZlSGFuZGxlcnNbdHlwZV0gPSBvblJlbW92ZTtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGlmIChxdWV1ZVt0eXBlXSkge1xuICAgICAgcXVldWVbdHlwZV0/LmZvckVhY2goKGV4dCkgPT4gb25BZGQoZXh0KSk7XG4gICAgICBkZWxldGUgcXVldWVbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbWFwIGJ5IGBuYW1lYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIGV4dGVuc2lvbiB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBtYXAgLSBUaGUgb2JqZWN0IG1hcCBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlNYXAodHlwZSwgbWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5uYW1lKSB7XG4gICAgICAgICAgbWFwW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5yZWY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb24ubmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSxcbiAgLyoqXG4gICAqIEhhbmRsZSBhIHR5cGUsIGJ1dCB1c2luZyBhIGxpc3Qgb2YgZXh0ZW5zaW9ucyB3aXRoIGEgYG5hbWVgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIG1hcCAtIFRoZSBhcnJheSBvZiBuYW1lZCBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gRmFsbGJhY2sgcHJpb3JpdHkgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlOYW1lZExpc3QodHlwZSwgbWFwLCBkZWZhdWx0UHJpb3JpdHkgPSAtMSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZShcbiAgICAgIHR5cGUsXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5uYW1lID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFwLnB1c2goeyBuYW1lOiBleHRlbnNpb24ubmFtZSwgdmFsdWU6IGV4dGVuc2lvbi5yZWYgfSk7XG4gICAgICAgIG1hcC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShiLnZhbHVlLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkoYS52YWx1ZSwgZGVmYXVsdFByaW9yaXR5KSk7XG4gICAgICB9LFxuICAgICAgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0ubmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbWFwLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9LFxuICAvKipcbiAgICogSGFuZGxlIGEgdHlwZSwgYnV0IHVzaW5nIGEgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gdHlwZSAtIFR5cGUgb2YgZXh0ZW5zaW9uIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCBvZiBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFByaW9yaXR5IC0gVGhlIGRlZmF1bHQgcHJpb3JpdHkgdG8gdXNlIGlmIG5vbmUgaXMgc3BlY2lmaWVkLlxuICAgKiBAcmV0dXJucyB7ZXh0ZW5zaW9uc30gRm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaGFuZGxlQnlMaXN0KHR5cGUsIGxpc3QsIGRlZmF1bHRQcmlvcml0eSA9IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKFxuICAgICAgdHlwZSxcbiAgICAgIChleHRlbnNpb24pID0+IHtcbiAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IG5vcm1hbGl6ZUV4dGVuc2lvblByaW9yaXR5KGIsIGRlZmF1bHRQcmlvcml0eSkgLSBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eShhLCBkZWZhdWx0UHJpb3JpdHkpKTtcbiAgICAgIH0sXG4gICAgICAoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucywgbm9ybWFsaXplRXh0ZW5zaW9uUHJpb3JpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dGVuc2lvbnMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3489\n')},6282:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ FilterEffect)\n/* harmony export */ });\n\nclass FilterEffect {\n  constructor(options) {\n    this.pipe = "filter";\n    this.priority = 1;\n    this.filters = options?.filters;\n    this.filterArea = options?.filterArea;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterEffect.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanM/NzQxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEZpbHRlckVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBpcGUgPSBcImZpbHRlclwiO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxO1xuICAgIHRoaXMuZmlsdGVycyA9IG9wdGlvbnM/LmZpbHRlcnM7XG4gICAgdGhpcy5maWx0ZXJBcmVhID0gb3B0aW9ucz8uZmlsdGVyQXJlYTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmlsdGVyRWZmZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJFZmZlY3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6282\n')},2372:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MxU: () => (/* reexport */ Application),\n  TCu: () => (/* reexport */ Graphics/* Graphics */.T),\n  AeJ: () => (/* reexport */ Rectangle/* Rectangle */.A),\n  DE6: () => (/* reexport */ sayHello/* sayHello */.D)\n});\n\n// UNUSED EXPORTS: AbstractBitmapFont, AbstractRenderer, AbstractText, AccessibilitySystem, AlphaFilter, AlphaMask, AlphaMaskPipe, AnimatedSprite, Assets, AssetsClass, BLEND_TO_NPM, BUFFER_TYPE, BackgroundLoader, BackgroundSystem, Batch, BatchGeometry, BatchTextureArray, BatchableGraphics, BatchableMesh, BatchableSprite, Batcher, BatcherPipe, BigPool, BindGroup, BindGroupSystem, BitmapFont, BitmapFontManager, BitmapText, BitmapTextPipe, BlendModeFilter, BlendModePipe, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferImageSource, BufferResource, BufferUsage, CLEAR, Cache, CanvasPool, CanvasPoolClass, CanvasSource, CanvasTextMetrics, CanvasTextPipe, CanvasTextSystem, Circle, Color, ColorBlend, ColorBurnBlend, ColorDodgeBlend, ColorMask, ColorMaskPipe, ColorMatrixFilter, CompressedSource, Container, Culler, CullerPlugin, CustomRenderPipe, DATA_URI, DDS, DEG_TO_RAD, DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, DOMAdapter, DRAW_MODES, DXGI_TO_TEXTURE_FORMAT, DarkenBlend, DifferenceBlend, DisplacementFilter, DivideBlend, DynamicBitmapFont, Ellipse, EventBoundary, EventEmitter, EventSystem, EventsTicker, ExclusionBlend, ExtensionType, ExtractSystem, FOURCC_TO_TEXTURE_FORMAT, FederatedContainer, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FillGradient, FillPattern, Filter, FilterEffect, FilterPipe, FilterSystem, FontStylePromiseCache, GAUSSIAN_VALUES, GL_FORMATS, GL_INTERNAL_FORMAT, GL_TARGETS, GL_TYPES, GL_WRAP_MODES, GenerateTextureSystem, Geometry, GlBackBufferSystem, GlBatchAdaptor, GlBuffer, GlBufferSystem, GlColorMaskSystem, GlContextSystem, GlEncoderSystem, GlGeometrySystem, GlGraphicsAdaptor, GlMeshAdaptor, GlProgram, GlProgramData, GlRenderTarget, GlRenderTargetAdaptor, GlRenderTargetSystem, GlShaderSystem, GlStateSystem, GlStencilSystem, GlTexture, GlTextureSystem, GlUboSystem, GlUniformGroupSystem, GlobalUniformSystem, GpuBatchAdaptor, GpuBlendModesToPixi, GpuBufferSystem, GpuColorMaskSystem, GpuDeviceSystem, GpuEncoderSystem, GpuGraphicsAdaptor, GpuGraphicsContext, GpuMeshAdapter, GpuMipmapGenerator, GpuProgram, GpuReadBuffer, GpuRenderTarget, GpuRenderTargetAdaptor, GpuRenderTargetSystem, GpuShaderSystem, GpuStateSystem, GpuStencilModesToPixi, GpuStencilSystem, GpuTextureSystem, GpuUboSystem, GpuUniformBatchPipe, GraphicsContext, GraphicsContextRenderData, GraphicsContextSystem, GraphicsPath, GraphicsPipe, HTMLText, HTMLTextPipe, HTMLTextRenderData, HTMLTextStyle, HTMLTextSystem, HardLightBlend, HardMixBlend, HelloSystem, IGLUniformData, ImageSource, InstructionSet, KTX, LightenBlend, LinearBurnBlend, LinearDodgeBlend, LinearLightBlend, Loader, LoaderParserPriority, LuminosityBlend, MAX_TEXTURES, MSAA_QUALITY, MaskEffectManager, MaskEffectManagerClass, MaskFilter, Matrix, Mesh, MeshGeometry, MeshPipe, MeshPlane, MeshRope, MeshSimple, NOOP, NegationBlend, NineSliceGeometry, NineSlicePlane, NineSliceSprite, NineSliceSpritePipe, NoiseFilter, ObservablePoint, OverlayBlend, PI_2, PinLightBlend, PipelineSystem, PlaneGeometry, Point, Polygon, Pool, PoolGroupClass, PrepareBase, PrepareQueue, PrepareSystem, PrepareUpload, QuadGeometry, RAD_TO_DEG, RenderContainer, RenderGroup, RenderGroupPipe, RenderGroupSystem, RenderTarget, RenderTargetSystem, RenderTexture, RendererType, ResizePlugin, Resolver, RopeGeometry, RoundedRectangle, SCALE_MODES, STENCIL_MODES, SVGParser, SVGToGraphicsPath, SaturationBlend, ScissorMask, SdfShader, Shader, ShaderStage, ShapePath, SharedRenderPipes, SharedSystems, SoftLightBlend, Sprite, SpritePipe, Spritesheet, State, StencilMask, StencilMaskPipe, SubtractBlend, SystemRunner, TEXTURE_FORMAT_BLOCK_SIZE, Text, TextStyle, Texture, TextureGCSystem, TextureMatrix, TexturePool, TexturePoolClass, TextureSource, TextureStyle, TextureUvs, Ticker, TickerListener, TickerPlugin, TilingSprite, TilingSpritePipe, TilingSpriteShader, Transform, Triangle, UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS, UPDATE_BLEND, UPDATE_COLOR, UPDATE_PRIORITY, UPDATE_TRANSFORM, UPDATE_VISIBLE, UboBatch, UboSystem, UniformGroup, VERSION, VideoSource, ViewSystem, ViewableBuffer, VividLightBlend, WGSL_ALIGN_SIZE_DATA, WGSL_TO_STD40_SIZE, WRAP_MODES, WebGLRenderer, WebGPURenderer, WebWorkerAdapter, WorkerManager, _getGlobalBounds, _getGlobalBoundsRecursive, accessibilityTarget, addBits, addMaskBounds, addMaskLocalBounds, addProgramDefines, alphaFrag, alphaWgsl, applyMatrix, applyStyleParams, assignWithIgnore, autoDetectEnvironment, autoDetectRenderer, autoDetectSource, basisTranscoderUrls, batchSamplersUniformGroup, bitmapFontCachePlugin, bitmapFontTextParser, bitmapFontXMLParser, bitmapFontXMLStringParser, blendTemplateFrag, blendTemplateVert, blendTemplateWgsl, blockDataMap, blurTemplateWgsl, boundsPool, browserExt, buildAdaptiveBezier, buildAdaptiveQuadratic, buildArc, buildArcTo, buildArcToSvg, buildCircle, buildContextBatches, buildGeometryFromPath, buildInstructions, buildLine, buildPolygon, buildRectangle, buildSimpleUvs, buildTriangle, buildUvs, cacheTextureArray, calculateProjection, checkChildrenDidChange, checkDataUrl, checkExtension, childrenHelperMixin, closePointEps, collectAllRenderables, collectRenderGroups, color32BitToUniform, colorBit, colorBitGl, colorMatrixFilterFrag, colorMatrixFilterWgsl, colorToUniform, compareModeToGlCompare, compileHighShader, compileHighShaderGl, compileHighShaderGlProgram, compileHighShaderGpuProgram, compileHooks, compileInputs, compileOutputs, compileShader, convertFillInputToFillStyle, convertFormatIfRequired, convertToList, copySearchParams, createIdFromString, createLevelBuffers, createLevelBuffersFromKTX, createStringVariations, createTexture, createUboElementsSTD40, createUboElementsWGSL, createUboSyncFunction, createUboSyncFunctionSTD40, createUboSyncFunctionWGSL, crossOrigin, cullingMixin, curveEps, defaultFilterVert, defaultValue, definedProps, deprecation, detectAvif, detectBasis, detectCompressed, detectDefaults, detectMp4, detectOgv, detectVideoAlphaMode, detectWebm, detectWebp, determineCrossOrigin, displacementFrag, displacementVert, displacementWgsl, earcut, effectsMixin, ensureAttributes, ensureIsBuffer, ensureOptions, ensurePrecision, ensureTextStyle, executeInstructions, extensions, extractAttributesFromGlProgram, extractAttributesFromGpuProgram, extractFontFamilies, extractStructAndGroups, fastCopy, findHooksRx, findMixin, fontStringFromTextStyle, formatShader, fragmentGPUTemplate, fragmentGlTemplate, generateArraySyncSTD40, generateArraySyncWGSL, generateBlurFragSource, generateBlurGlProgram, generateBlurProgram, generateBlurVertSource, generateGPULayout, generateGpuLayoutGroups, generateLayout, generateLayoutHash, generateProgram, generateShaderSyncCode, generateTextStyleKey, generateTextureBatchBit, generateTextureBatchBitGl, generateUID, generateUniformsSync, getAdjustedBlendModeBlend, getAttributeInfoFromFormat, getBitmapTextLayout, getCanvasBoundingBox, getCanvasFillStyle, getCanvasTexture, getDefaultUniformValue, getFastGlobalBounds, getFontCss, getFontFamilyName, getGeometryBounds, getGlTypeFromFormat, getGlobalBounds, getGlobalRenderableBounds, getLocalBounds, getMatrixRelativeToParent, getMaxFragmentPrecision, getOrientationOfPoints, getParent, getPo2TextureFromSource, getResolutionOfUrl, getSVGUrl, getSupportedCompressedTextureFormats, getSupportedGPUCompressedTextureFormats, getSupportedGlCompressedTextureFormats, getSupportedTextureFormats, getTemporaryCanvasFromImage, getTestContext, getTextureBatchBindGroup, getTextureDefaultMatrix, getTextureFormatFromKTXTexture, getUboData, getUniformData, getUrlExtension, glFormatToGPUFormat, glUploadBufferImageResource, glUploadCompressedTextureResource, glUploadImageResource, glUploadVideoResource, globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl, gpuFormatToBasisTranscoderFormat, gpuFormatToKTXBasisTranscoderFormat, gpuUploadBufferImageResource, gpuUploadCompressedTextureResource, gpuUploadImageResource, gpuUploadVideoResource, groupD8, hasCachedCanvasTexture, hslWgsl, hslgl, hslgpu, injectBits, insertVersion, isMobile, isPow2, isRenderingToScreen, isSafari, isSingleItem, isWebGLSupported, isWebGPUSupported, ktxTranscoderUrls, loadBasis, loadBasisOnWorker, loadBitmapFont, loadDDS, loadFontAsBase64, loadFontCSS, loadImageBitmap, loadJson, loadKTX, loadKTX2, loadKTX2onWorker, loadSVGImage, loadSvg, loadTextures, loadTxt, loadVideoTextures, loadWebFont, localUniformBit, localUniformBitGl, localUniformBitGroup2, localUniformMSDFBit, localUniformMSDFBitGl, log2, logDebugTexture, logProgramError, logRenderGroupScene, logScene, mSDFBit, mSDFBitGl, mapFormatToGlFormat, mapFormatToGlInternalFormat, mapFormatToGlType, mapGlToVertexFormat, mapSize, mapType, mapWebGLBlendModesToPixi, maskFrag, maskVert, maskWgsl, matrixPool, measureHtmlText, measureMixin, migrateFragmentFromV7toV8, mipmapScaleModeToGlFilter, mixColors, mixHexColors, mixStandardAnd32BitColors, multiplyHexColors, nextPow2, noiseFrag, noiseWgsl, nonCompressedFormats, normalizeExtensionPriority, nssvg, nsxhtml, onRenderMixin, parseDDS, parseFunctionBody, parseKTX, path, preloadVideo, removeItems, removeStructAndGroupDuplicates, resetUids, resolveCharacters, resolveCompressedTextureUrl, resolveJsonUrl, resolveTextureUrl, resourceToTexture, roundPixelsBit, roundPixelsBitGl, roundedShapeArc, roundedShapeQuadraticCurve, scaleModeToGlFilter, setBasisTranscoderPath, setKTXTranscoderPath, setPositions, setProgramName, setUvs, sortMixin, spritesheetAsset, squaredDistanceToLineSegment, stripVersion, testImageFormat, testVideoFormat, textStyleToCSS, textureBit, textureBitGl, textureFrom, tilingBit, tilingBitGl, toLocalGlobalMixin, transformVertices, triangulateWithHoles, uboSyncFunctionsSTD40, uboSyncFunctionsWGSL, uid, uniformParsers, unpremultiplyAlpha, unsafeEvalSupported, updateLocalTransform, updateQuadBounds, updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren, updateTransformBackwards, updateWorldTransform, v8_0_0, validFormats, validateRenderables, vertexGPUTemplate, vertexGlTemplate, viewportFromFrame, vkFormatToGPUFormat, warn, webworkerExt, wrapModeToGlAddress\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-browser/browserExt.mjs\n\n\n"use strict";\nconst browserExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "browser",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(737), __webpack_require__.e(81)]).then(__webpack_require__.bind(__webpack_require__, 2081));\n  }\n};\n\n\n//# sourceMappingURL=browserExt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs\n\n\n"use strict";\nconst webworkerExt = {\n  extension: {\n    type: Extensions/* ExtensionType */.nw.Environment,\n    name: "webworker",\n    priority: 0\n  },\n  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(737), __webpack_require__.e(277)]).then(__webpack_require__.bind(__webpack_require__, 1277));\n  }\n};\n\n\n//# sourceMappingURL=webworkerExt.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs + 7 modules\nvar init = __webpack_require__(9846);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs + 5 modules\nvar spritesheet_init = __webpack_require__(9026);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs\n\n\n"use strict";\nconst environments = [];\nExtensions/* extensions */.Rw.handleByNamedList(Extensions/* ExtensionType */.nw.Environment, environments);\nasync function autoDetectEnvironment(manageImports) {\n  if (!manageImports)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\n\n\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(3646);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs\nvar AbstractRenderer = __webpack_require__(7199);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs\n\n\n\n"use strict";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!adapter/* DOMAdapter */.z.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = adapter/* DOMAdapter */.z.get().createCanvas();\n      let gl = canvas.getContext("webgl", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension("WEBGL_lose_context");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs\n\n\n"use strict";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = adapter/* DOMAdapter */.z.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await navigator.gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\n\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs\n\n\n\n\n\n"use strict";\nconst renderPriority = ["webgpu", "webgl", "canvas"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  await autoDetectEnvironment(\n    options.manageImports ?? true\n  );\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === "webgpu" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(816), __webpack_require__.e(45)]).then(__webpack_require__.bind(__webpack_require__, 7045));\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === "webgl" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer/* AbstractRenderer */.I.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await Promise.all(/* import() */[__webpack_require__.e(8), __webpack_require__.e(816), __webpack_require__.e(172)]).then(__webpack_require__.bind(__webpack_require__, 2172));\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === "canvas") {\n      finalOptions = { ...options };\n      break;\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/Application.mjs\n\n\n\n\n\n"use strict";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that\'s rendered. */\n    this.stage = new Container/* Container */.W2();\n    if (args[0] !== void 0) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application constructor options are deprecated, please use Application.init() instead.");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Application.view is deprecated, please use Application.canvas instead.");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer\'s screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.Application, Application._plugins);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(6475);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/sayHello.mjs\nvar sayHello = __webpack_require__(3921);\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(browserExt, webworkerExt);\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRTtBQUNNO0FBQ0Y7QUFDQTtBQUNFO0FBQ047QUFDSTtBQUNvQjtBQUNWO0FBQ3JCO0FBQ3VEO0FBQ3BDO0FBQ3ZDO0FBQ1U7QUFDa0I7QUFDVTtBQUNNO0FBQzdCO0FBQ1U7QUFDakI7QUFDUjtBQUNnQjtBQUNtQjtBQUN4QjtBQUNBO0FBQ2dCO0FBQ0U7QUFDSTtBQUNDO0FBQ2xDO0FBQ1c7QUFDRztBQUNMO0FBQ2U7QUFDSjtBQUNLO0FBQ0E7QUFDTztBQUM3QjtBQUNIO0FBQ1U7QUFDcUI7QUFDcEM7QUFDSztBQUN3QjtBQUNaO0FBQ2Q7O0FBRTNDO0FBQ0EsNkJBQVUsS0FBSyxVQUFVLEVBQUUsWUFBWTs7QUFFUztBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50LWJyb3dzZXIvYnJvd3NlckV4dC5tanM/NjUyZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9lbnZpcm9ubWVudC13ZWJ3b3JrZXIvd2Vid29ya2VyRXh0Lm1qcz9hYjQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanM/Mjk1ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQubWpzP2Q2NzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanM/MTdmMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2F1dG9EZXRlY3RSZW5kZXJlci5tanM/NDczYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9hcHAvQXBwbGljYXRpb24ubWpzPzAyM2IiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvaW5kZXgubWpzPzE5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJyb3dzZXJFeHQgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRW52aXJvbm1lbnQsXG4gICAgbmFtZTogXCJicm93c2VyXCIsXG4gICAgcHJpb3JpdHk6IC0xXG4gIH0sXG4gIHRlc3Q6ICgpID0+IHRydWUsXG4gIGxvYWQ6IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBpbXBvcnQoJy4vYnJvd3NlckFsbC5tanMnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnJvd3NlckV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlckV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3Qgd2Vid29ya2VyRXh0ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkVudmlyb25tZW50LFxuICAgIG5hbWU6IFwid2Vid29ya2VyXCIsXG4gICAgcHJpb3JpdHk6IDBcbiAgfSxcbiAgdGVzdDogKCkgPT4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5Xb3JrZXJHbG9iYWxTY29wZSAhPT0gdm9pZCAwLFxuICBsb2FkOiBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaW1wb3J0KCcuL3dlYndvcmtlckFsbC5tanMnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgd2Vid29ya2VyRXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJ3b3JrZXJFeHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGVudmlyb25tZW50cyA9IFtdO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeU5hbWVkTGlzdChFeHRlbnNpb25UeXBlLkVudmlyb25tZW50LCBlbnZpcm9ubWVudHMpO1xuYXN5bmMgZnVuY3Rpb24gYXV0b0RldGVjdEVudmlyb25tZW50KG1hbmFnZUltcG9ydHMpIHtcbiAgaWYgKCFtYW5hZ2VJbXBvcnRzKVxuICAgIHJldHVybjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnZpcm9ubWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbnYgPSBlbnZpcm9ubWVudHNbaV07XG4gICAgaWYgKGVudi52YWx1ZS50ZXN0KCkpIHtcbiAgICAgIGF3YWl0IGVudi52YWx1ZS5sb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGF1dG9EZXRlY3RFbnZpcm9ubWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b0RldGVjdEVudmlyb25tZW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX2lzV2ViR0xTdXBwb3J0ZWQ7XG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHtcbiAgaWYgKF9pc1dlYkdMU3VwcG9ydGVkICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIF9pc1dlYkdMU3VwcG9ydGVkO1xuICBfaXNXZWJHTFN1cHBvcnRlZCA9ICgoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA/PyBBYnN0cmFjdFJlbmRlcmVyLmRlZmF1bHRPcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBpZiAoIURPTUFkYXB0ZXIuZ2V0KCkuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgY29uc3Qgc3VjY2VzcyA9ICEhZ2w/LmdldENvbnRleHRBdHRyaWJ1dGVzKCk/LnN0ZW5jaWw7XG4gICAgICBpZiAoZ2wpIHtcbiAgICAgICAgY29uc3QgbG9zZUNvbnRleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik7XG4gICAgICAgIGlmIChsb3NlQ29udGV4dCkge1xuICAgICAgICAgIGxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsID0gbnVsbDtcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG4gIHJldHVybiBfaXNXZWJHTFN1cHBvcnRlZDtcbn1cblxuZXhwb3J0IHsgaXNXZWJHTFN1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNXZWJHTFN1cHBvcnRlZC5tanMubWFwXG4iLCJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBfaXNXZWJHUFVTdXBwb3J0ZWQ7XG5hc3luYyBmdW5jdGlvbiBpc1dlYkdQVVN1cHBvcnRlZChvcHRpb25zID0ge30pIHtcbiAgaWYgKF9pc1dlYkdQVVN1cHBvcnRlZCAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBfaXNXZWJHUFVTdXBwb3J0ZWQ7XG4gIF9pc1dlYkdQVVN1cHBvcnRlZCA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZ3B1ID0gRE9NQWRhcHRlci5nZXQoKS5nZXROYXZpZ2F0b3IoKS5ncHU7XG4gICAgaWYgKCFncHUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKG9wdGlvbnMpO1xuICAgICAgYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gX2lzV2ViR1BVU3VwcG9ydGVkO1xufVxuXG5leHBvcnQgeyBpc1dlYkdQVVN1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNXZWJHUFVTdXBwb3J0ZWQubWpzLm1hcFxuIiwiaW1wb3J0IHsgYXV0b0RldGVjdEVudmlyb25tZW50IH0gZnJvbSAnLi4vLi4vZW52aXJvbm1lbnQvYXV0b0RldGVjdEVudmlyb25tZW50Lm1qcyc7XG5pbXBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcyc7XG5pbXBvcnQgeyBpc1dlYkdQVVN1cHBvcnRlZCB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXIvaXNXZWJHUFVTdXBwb3J0ZWQubWpzJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfSBmcm9tICcuL3NoYXJlZC9zeXN0ZW0vQWJzdHJhY3RSZW5kZXJlci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHJlbmRlclByaW9yaXR5ID0gW1wid2ViZ3B1XCIsIFwid2ViZ2xcIiwgXCJjYW52YXNcIl07XG5hc3luYyBmdW5jdGlvbiBhdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucykge1xuICBsZXQgcHJlZmVycmVkT3JkZXIgPSBbXTtcbiAgaWYgKG9wdGlvbnMucHJlZmVyZW5jZSkge1xuICAgIHByZWZlcnJlZE9yZGVyLnB1c2gob3B0aW9ucy5wcmVmZXJlbmNlKTtcbiAgICByZW5kZXJQcmlvcml0eS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbSAhPT0gb3B0aW9ucy5wcmVmZXJlbmNlKSB7XG4gICAgICAgIHByZWZlcnJlZE9yZGVyLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJlZmVycmVkT3JkZXIgPSByZW5kZXJQcmlvcml0eS5zbGljZSgpO1xuICB9XG4gIGxldCBSZW5kZXJlckNsYXNzO1xuICBhd2FpdCBhdXRvRGV0ZWN0RW52aXJvbm1lbnQoXG4gICAgb3B0aW9ucy5tYW5hZ2VJbXBvcnRzID8/IHRydWVcbiAgKTtcbiAgbGV0IGZpbmFsT3B0aW9ucyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZlcnJlZE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gcHJlZmVycmVkT3JkZXJbaV07XG4gICAgaWYgKHJlbmRlcmVyVHlwZSA9PT0gXCJ3ZWJncHVcIiAmJiBhd2FpdCBpc1dlYkdQVVN1cHBvcnRlZCgpKSB7XG4gICAgICBjb25zdCB7IFdlYkdQVVJlbmRlcmVyIH0gPSBhd2FpdCBpbXBvcnQoJy4vZ3B1L1dlYkdQVVJlbmRlcmVyLm1qcycpO1xuICAgICAgUmVuZGVyZXJDbGFzcyA9IFdlYkdQVVJlbmRlcmVyO1xuICAgICAgZmluYWxPcHRpb25zID0geyAuLi5vcHRpb25zLCAuLi5vcHRpb25zLndlYmdwdSB9O1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChyZW5kZXJlclR5cGUgPT09IFwid2ViZ2xcIiAmJiBpc1dlYkdMU3VwcG9ydGVkKFxuICAgICAgb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID8/IEFic3RyYWN0UmVuZGVyZXIuZGVmYXVsdE9wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFxuICAgICkpIHtcbiAgICAgIGNvbnN0IHsgV2ViR0xSZW5kZXJlciB9ID0gYXdhaXQgaW1wb3J0KCcuL2dsL1dlYkdMUmVuZGVyZXIubWpzJyk7XG4gICAgICBSZW5kZXJlckNsYXNzID0gV2ViR0xSZW5kZXJlcjtcbiAgICAgIGZpbmFsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4ub3B0aW9ucy53ZWJnbCB9O1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChyZW5kZXJlclR5cGUgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgIGZpbmFsT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGRlbGV0ZSBmaW5hbE9wdGlvbnMud2ViZ3B1O1xuICBkZWxldGUgZmluYWxPcHRpb25zLndlYmdsO1xuICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlckNsYXNzKCk7XG4gIGF3YWl0IHJlbmRlcmVyLmluaXQoZmluYWxPcHRpb25zKTtcbiAgcmV0dXJuIHJlbmRlcmVyO1xufVxuXG5leHBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZW5kZXJlci5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zLCBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2F1dG9EZXRlY3RSZW5kZXJlci5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfQXBwbGljYXRpb24gPSBjbGFzcyBfQXBwbGljYXRpb24ge1xuICAvKiogQGlnbm9yZSAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgLyoqIFRoZSByb290IGRpc3BsYXkgY29udGFpbmVyIHRoYXQncyByZW5kZXJlZC4gKi9cbiAgICB0aGlzLnN0YWdlID0gbmV3IENvbnRhaW5lcigpO1xuICAgIGlmIChhcmdzWzBdICE9PSB2b2lkIDApIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJBcHBsaWNhdGlvbiBjb25zdHJ1Y3RvciBvcHRpb25zIGFyZSBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEFwcGxpY2F0aW9uLmluaXQoKSBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbmFsIGFwcGxpY2F0aW9uIGFuZCByZW5kZXJlciBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgYXN5bmMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMucmVuZGVyZXIgPSBhd2FpdCBhdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgX0FwcGxpY2F0aW9uLl9wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKiogUmVuZGVyIHRoZSBjdXJyZW50IHN0YWdlLiAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoeyBjb250YWluZXI6IHRoaXMuc3RhZ2UgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBjYW52YXMgZWxlbWVudC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBjYW52YXMgZWxlbWVudC5cbiAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqL1xuICBnZXQgdmlldygpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQXBwbGljYXRpb24udmlldyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEFwcGxpY2F0aW9uLmNhbnZhcyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIncyBzY3JlZW4gcmVjdGFuZ2xlLiBJdHMgc2FmZSB0byB1c2UgYXMgYGZpbHRlckFyZWFgIG9yIGBoaXRBcmVhYCBmb3IgdGhlIHdob2xlIHNjcmVlbi5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjcmVlbjtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGFwcGxpY2F0aW9uIGFuZCBhbGwgb2YgaXRzIHJlc291cmNlcy5cbiAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn1bcmVuZGVyZXJEZXN0cm95T3B0aW9ucz1mYWxzZV0gLSBUaGUgb3B0aW9ucyBmb3IgZGVzdHJveWluZyB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn1bcmVuZGVyZXJEZXN0cm95T3B0aW9ucy5yZW1vdmVWaWV3PWZhbHNlXSAtIFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnM9ZmFsc2VdIC0gVGhlIG9wdGlvbnMgZm9yIGRlc3Ryb3lpbmcgdGhlIHN0YWdlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIElmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95IG1ldGhvZFxuICAgKiBjYWxsZWQgYXMgd2VsbC4gYG9wdGlvbnNgIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIHRleHR1cmVzIGUuZy4gU3ByaXRlcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSxcbiAgICogaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlU291cmNlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCB0ZXh0dXJlcyBlLmcuIFNwcml0ZXMuXG4gICAqICBJZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlLFxuICAgKiBpdCBzaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGNoaWxkIHNwcml0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb250ZXh0PWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCBncmFwaGljc0NvbnRleHRzIGUuZy4gR3JhcGhpY3MuXG4gICAqIElmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWUsXG4gICAqIGl0IHNob3VsZCBkZXN0cm95IHRoZSBjb250ZXh0IG9mIHRoZSBjaGlsZCBncmFwaGljcy5cbiAgICovXG4gIGRlc3Ryb3kocmVuZGVyZXJEZXN0cm95T3B0aW9ucyA9IGZhbHNlLCBvcHRpb25zID0gZmFsc2UpIHtcbiAgICBjb25zdCBwbHVnaW5zID0gX0FwcGxpY2F0aW9uLl9wbHVnaW5zLnNsaWNlKDApO1xuICAgIHBsdWdpbnMucmV2ZXJzZSgpO1xuICAgIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICBwbHVnaW4uZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhZ2UuZGVzdHJveShvcHRpb25zKTtcbiAgICB0aGlzLnN0YWdlID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kocmVuZGVyZXJEZXN0cm95T3B0aW9ucyk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn07XG4vKipcbiAqIENvbGxlY3Rpb24gb2YgaW5zdGFsbGVkIHBsdWdpbnMuXG4gKiBAYWxpYXMgX3BsdWdpbnNcbiAqL1xuX0FwcGxpY2F0aW9uLl9wbHVnaW5zID0gW107XG5sZXQgQXBwbGljYXRpb24gPSBfQXBwbGljYXRpb247XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uLCBBcHBsaWNhdGlvbi5fcGx1Z2lucyk7XG5cbmV4cG9ydCB7IEFwcGxpY2F0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHBsaWNhdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBicm93c2VyRXh0IH0gZnJvbSAnLi9lbnZpcm9ubWVudC1icm93c2VyL2Jyb3dzZXJFeHQubWpzJztcbmltcG9ydCB7IHdlYndvcmtlckV4dCB9IGZyb20gJy4vZW52aXJvbm1lbnQtd2Vid29ya2VyL3dlYndvcmtlckV4dC5tanMnO1xuaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5leHBvcnQgeyBFeHRlbnNpb25UeXBlLCBub3JtYWxpemVFeHRlbnNpb25Qcmlvcml0eSB9IGZyb20gJy4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgJy4vcmVuZGVyaW5nL2luaXQubWpzJztcbmltcG9ydCAnLi9zcHJpdGVzaGVldC9pbml0Lm1qcyc7XG5pbXBvcnQgJy4vYWNjZXNzaWJpbGl0eS9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vYXBwL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vYXNzZXRzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vY29sb3IvaW5kZXgubWpzJztcbmltcG9ydCAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vY3VsbGluZy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50L2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vZW52aXJvbm1lbnQtYnJvd3Nlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50LXdlYndvcmtlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2V2ZW50cy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL2V4dGVuc2lvbnMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9maWx0ZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vbWF0aHMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9wcmVwYXJlL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcmVuZGVyaW5nL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vc2NlbmUvaW5kZXgubWpzJztcbmltcG9ydCAnLi9zcHJpdGVzaGVldC9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3RpY2tlci9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3V0aWxzL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBBY2Nlc3NpYmlsaXR5U3lzdGVtIH0gZnJvbSAnLi9hY2Nlc3NpYmlsaXR5L0FjY2Vzc2liaWxpdHlTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGFjY2Vzc2liaWxpdHlUYXJnZXQgfSBmcm9tICcuL2FjY2Vzc2liaWxpdHkvYWNjZXNzaWJpbGl0eVRhcmdldC5tanMnO1xuZXhwb3J0IHsgQ29sb3JCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvQ29sb3JCbGVuZC5tanMnO1xuZXhwb3J0IHsgQ29sb3JCdXJuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0NvbG9yQnVybkJsZW5kLm1qcyc7XG5leHBvcnQgeyBDb2xvckRvZGdlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0NvbG9yRG9kZ2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgRGFya2VuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RhcmtlbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBEaWZmZXJlbmNlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RpZmZlcmVuY2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgRGl2aWRlQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0RpdmlkZUJsZW5kLm1qcyc7XG5leHBvcnQgeyBFeGNsdXNpb25CbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvRXhjbHVzaW9uQmxlbmQubWpzJztcbmV4cG9ydCB7IEhhcmRMaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9IYXJkTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgSGFyZE1peEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9IYXJkTWl4QmxlbmQubWpzJztcbmV4cG9ydCB7IExpZ2h0ZW5CbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGlnaHRlbkJsZW5kLm1qcyc7XG5leHBvcnQgeyBMaW5lYXJCdXJuQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL0xpbmVhckJ1cm5CbGVuZC5tanMnO1xuZXhwb3J0IHsgTGluZWFyRG9kZ2VCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGluZWFyRG9kZ2VCbGVuZC5tanMnO1xuZXhwb3J0IHsgTGluZWFyTGlnaHRCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvTGluZWFyTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgTHVtaW5vc2l0eUJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9MdW1pbm9zaXR5QmxlbmQubWpzJztcbmV4cG9ydCB7IE5lZ2F0aW9uQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL05lZ2F0aW9uQmxlbmQubWpzJztcbmV4cG9ydCB7IE92ZXJsYXlCbGVuZCB9IGZyb20gJy4vYWR2YW5jZWQtYmxlbmQtbW9kZXMvT3ZlcmxheUJsZW5kLm1qcyc7XG5leHBvcnQgeyBQaW5MaWdodEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9QaW5MaWdodEJsZW5kLm1qcyc7XG5leHBvcnQgeyBTYXR1cmF0aW9uQmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1NhdHVyYXRpb25CbGVuZC5tanMnO1xuZXhwb3J0IHsgU29mdExpZ2h0QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1NvZnRMaWdodEJsZW5kLm1qcyc7XG5leHBvcnQgeyBTdWJ0cmFjdEJsZW5kIH0gZnJvbSAnLi9hZHZhbmNlZC1ibGVuZC1tb2Rlcy9TdWJ0cmFjdEJsZW5kLm1qcyc7XG5leHBvcnQgeyBWaXZpZExpZ2h0QmxlbmQgfSBmcm9tICcuL2FkdmFuY2VkLWJsZW5kLW1vZGVzL1ZpdmlkTGlnaHRCbGVuZC5tanMnO1xuZXhwb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tICcuL2FwcC9BcHBsaWNhdGlvbi5tanMnO1xuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9hcHAvUmVzaXplUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBUaWNrZXJQbHVnaW4gfSBmcm9tICcuL2FwcC9UaWNrZXJQbHVnaW4ubWpzJztcbmV4cG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfSBmcm9tICcuL2Fzc2V0cy9Bc3NldHMubWpzJztcbmV4cG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tICcuL2Fzc2V0cy9CYWNrZ3JvdW5kTG9hZGVyLm1qcyc7XG5leHBvcnQgeyBDYWNoZSB9IGZyb20gJy4vYXNzZXRzL2NhY2hlL0NhY2hlLm1qcyc7XG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9IGZyb20gJy4vYXNzZXRzL2NhY2hlL3BhcnNlcnMvY2FjaGVUZXh0dXJlQXJyYXkubWpzJztcbmV4cG9ydCB7IGRldGVjdEF2aWYgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0QXZpZi5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0RGVmYXVsdHMgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0RGVmYXVsdHMubWpzJztcbmV4cG9ydCB7IGRldGVjdE1wNCB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RNcDQubWpzJztcbmV4cG9ydCB7IGRldGVjdE9ndiB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RPZ3YubWpzJztcbmV4cG9ydCB7IGRldGVjdFdlYm0gfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3BhcnNlcnMvZGV0ZWN0V2VibS5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0V2VicCB9IGZyb20gJy4vYXNzZXRzL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyB0ZXN0SW1hZ2VGb3JtYXQgfSBmcm9tICcuL2Fzc2V0cy9kZXRlY3Rpb25zL3V0aWxzL3Rlc3RJbWFnZUZvcm1hdC5tanMnO1xuZXhwb3J0IHsgdGVzdFZpZGVvRm9ybWF0IH0gZnJvbSAnLi9hc3NldHMvZGV0ZWN0aW9ucy91dGlscy90ZXN0VmlkZW9Gb3JtYXQubWpzJztcbmV4cG9ydCB7IExvYWRlciB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9Mb2FkZXIubWpzJztcbmV4cG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBsb2FkSnNvbiB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL2xvYWRKc29uLm1qcyc7XG5leHBvcnQgeyBsb2FkVHh0IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanMnO1xuZXhwb3J0IHsgZ2V0Rm9udEZhbWlseU5hbWUsIGxvYWRXZWJGb250IH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzJztcbmV4cG9ydCB7IGxvYWRTdmcgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkU1ZHLm1qcyc7XG5leHBvcnQgeyBsb2FkSW1hZ2VCaXRtYXAsIGxvYWRUZXh0dXJlcyB9IGZyb20gJy4vYXNzZXRzL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5tanMnO1xuZXhwb3J0IHsgY3Jvc3NPcmlnaW4sIGRldGVybWluZUNyb3NzT3JpZ2luLCBsb2FkVmlkZW9UZXh0dXJlcywgcHJlbG9hZFZpZGVvIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFZpZGVvVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL2Fzc2V0cy9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy91dGlscy9jcmVhdGVUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH0gZnJvbSAnLi9hc3NldHMvbG9hZGVyL3dvcmtlcnMvV29ya2VyTWFuYWdlci5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUpzb25VcmwgfSBmcm9tICcuL2Fzc2V0cy9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVKc29uVXJsLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlVGV4dHVyZVVybCB9IGZyb20gJy4vYXNzZXRzL3Jlc29sdmVyL3BhcnNlcnMvcmVzb2x2ZVRleHR1cmVVcmwubWpzJztcbmV4cG9ydCB7IFJlc29sdmVyLCBnZXRVcmxFeHRlbnNpb24gfSBmcm9tICcuL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuZXhwb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5leHBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi9hc3NldHMvdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuZXhwb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gJy4vYXNzZXRzL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfSBmcm9tICcuL2Fzc2V0cy91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuL2Fzc2V0cy91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcbmV4cG9ydCB7IENvbG9yIH0gZnJvbSAnLi9jb2xvci9Db2xvci5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0QmFzaXMgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvYmFzaXMvZGV0ZWN0QmFzaXMubWpzJztcbmV4cG9ydCB7IGxvYWRCYXNpcyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy9sb2FkQmFzaXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUxldmVsQnVmZmVycyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9iYXNpcy91dGlscy9jcmVhdGVMZXZlbEJ1ZmZlcnMubWpzJztcbmV4cG9ydCB7IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3V0aWxzL2dwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBiYXNpc1RyYW5zY29kZXJVcmxzLCBzZXRCYXNpc1RyYW5zY29kZXJQYXRoIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3V0aWxzL3NldEJhc2lzVHJhbnNjb2RlclBhdGgubWpzJztcbmV4cG9ydCB7IGxvYWRCYXNpc09uV29ya2VyIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Jhc2lzL3dvcmtlci9sb2FkQmFzaXNPbldvcmtlci5tanMnO1xuZXhwb3J0IHsgRERTLCBEWEdJX1RPX1RFWFRVUkVfRk9STUFULCBGT1VSQ0NfVE9fVEVYVFVSRV9GT1JNQVQsIFRFWFRVUkVfRk9STUFUX0JMT0NLX1NJWkUgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMvZGRzL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRERTIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2Rkcy9sb2FkRERTLm1qcyc7XG5leHBvcnQgeyBwYXJzZUREUyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9kZHMvcGFyc2VERFMubWpzJztcbmV4cG9ydCB7IGxvYWRLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4L2xvYWRLVFgubWpzJztcbmV4cG9ydCB7IHBhcnNlS1RYIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eC9wYXJzZUtUWC5tanMnO1xuZXhwb3J0IHsgR0xfSU5URVJOQUxfRk9STUFULCBLVFggfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9jb25zdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDIgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi9sb2FkS1RYMi5tanMnO1xuZXhwb3J0IHsgY29udmVydEZvcm1hdElmUmVxdWlyZWQgfSBmcm9tICcuL2NvbXByZXNzZWQtdGV4dHVyZXMva3R4Mi91dGlscy9jb252ZXJ0Rm9ybWF0SWZSZXF1aXJlZC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTGV2ZWxCdWZmZXJzRnJvbUtUWCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2NyZWF0ZUxldmVsQnVmZmVyc0Zyb21LVFgubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZSB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgZ2xGb3JtYXRUb0dQVUZvcm1hdCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL2dsRm9ybWF0VG9HUFVGb3JtYXQubWpzJztcbmV4cG9ydCB7IGdwdUZvcm1hdFRvS1RYQmFzaXNUcmFuc2NvZGVyRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvZ3B1Rm9ybWF0VG9LVFhCYXNpc1RyYW5zY29kZXJGb3JtYXQubWpzJztcbmV4cG9ydCB7IGt0eFRyYW5zY29kZXJVcmxzLCBzZXRLVFhUcmFuc2NvZGVyUGF0aCB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3V0aWxzL3NldEtUWFRyYW5zY29kZXJQYXRoLm1qcyc7XG5leHBvcnQgeyB2a0Zvcm1hdFRvR1BVRm9ybWF0IH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL2t0eDIvdXRpbHMvdmtGb3JtYXRUb0dQVUZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbG9hZEtUWDJvbldvcmtlciB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9rdHgyL3dvcmtlci9sb2FkS1RYMm9uV29ya2VyLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkIH0gZnJvbSAnLi9jb21wcmVzc2VkLXRleHR1cmVzL3NoYXJlZC9kZXRlY3RDb21wcmVzc2VkLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwsIHZhbGlkRm9ybWF0cyB9IGZyb20gJy4vY29tcHJlc3NlZC10ZXh0dXJlcy9zaGFyZWQvcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBDdWxsZXIgfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyLm1qcyc7XG5leHBvcnQgeyBDdWxsZXJQbHVnaW4gfSBmcm9tICcuL2N1bGxpbmcvQ3VsbGVyUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBjdWxsaW5nTWl4aW4gfSBmcm9tICcuL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5leHBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBhdXRvRGV0ZWN0RW52aXJvbm1lbnQgfSBmcm9tICcuL2Vudmlyb25tZW50L2F1dG9EZXRlY3RFbnZpcm9ubWVudC5tanMnO1xuZXhwb3J0IHsgQnJvd3NlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LWJyb3dzZXIvQnJvd3NlckFkYXB0ZXIubWpzJztcbmV4cG9ydCB7IFdlYldvcmtlckFkYXB0ZXIgfSBmcm9tICcuL2Vudmlyb25tZW50LXdlYndvcmtlci9XZWJXb3JrZXJBZGFwdGVyLm1qcyc7XG5leHBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9ldmVudHMvRXZlbnRCb3VuZGFyeS5tanMnO1xuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfSBmcm9tICcuL2V2ZW50cy9FdmVudFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRXZlbnRzVGlja2VyIH0gZnJvbSAnLi9ldmVudHMvRXZlbnRUaWNrZXIubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkRXZlbnQubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZENvbnRhaW5lciB9IGZyb20gJy4vZXZlbnRzL0ZlZGVyYXRlZEV2ZW50VGFyZ2V0Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBibGVuZFRlbXBsYXRlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9ibGVuZC10ZW1wbGF0ZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsZW5kVGVtcGxhdGVWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2JsZW5kLXRlbXBsYXRlLnZlcnQubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYmxlbmRUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvYmxlbmQtdGVtcGxhdGUud2dzbC5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoc2xXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL2JsZW5kLW1vZGVzL2hzbC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFscGhhV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9hbHBoYS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJsdXJUZW1wbGF0ZVdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvYmx1ci9ncHUvYmx1ci10ZW1wbGF0ZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbG9yTWF0cml4RmlsdGVyRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvY29sb3JNYXRyaXhGaWx0ZXIuZnJhZy5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb2xvck1hdHJpeEZpbHRlcldnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvY29sb3ItbWF0cml4L2NvbG9yTWF0cml4RmlsdGVyLndnc2wubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdEZpbHRlclZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGVmYXVsdEZpbHRlci52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudEZyYWcgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFZlcnQgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRpc3BsYWNlbWVudFdnc2wgfSBmcm9tICcuL2ZpbHRlcnMvZGVmYXVsdHMvZGlzcGxhY2VtZW50L2Rpc3BsYWNlbWVudC53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlRnJhZyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vaXNlV2dzbCB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9ub2lzZS53Z3NsLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tGcmFnIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay5mcmFnLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tWZXJ0IH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay52ZXJ0Lm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1hc2tXZ3NsIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svbWFzay53Z3NsLm1qcyc7XG5leHBvcnQgeyBCbGVuZE1vZGVGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvYmxlbmQtbW9kZXMvQmxlbmRNb2RlRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBoc2xnbCB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR0xobHMubWpzJztcbmV4cG9ydCB7IGhzbGdwdSB9IGZyb20gJy4vZmlsdGVycy9ibGVuZC1tb2Rlcy9obHMvR1BVaGxzLm1qcyc7XG5leHBvcnQgeyBBbHBoYUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9hbHBoYS9BbHBoYUZpbHRlci5tanMnO1xuZXhwb3J0IHsgQmx1ckZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL0JsdXJGaWx0ZXIubWpzJztcbmV4cG9ydCB7IEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvQmx1ckZpbHRlclBhc3MubWpzJztcbmV4cG9ydCB7IEdBVVNTSUFOX1ZBTFVFUyB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyR2xQcm9ncmFtIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyR2xQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlIH0gZnJvbSAnLi9maWx0ZXJzL2RlZmF1bHRzL2JsdXIvZ2wvZ2VuZXJhdGVCbHVyVmVydFNvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyUHJvZ3JhbSB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ibHVyL2dwdS9nZW5lcmF0ZUJsdXJQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hdHJpeEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9jb2xvci1tYXRyaXgvQ29sb3JNYXRyaXhGaWx0ZXIubWpzJztcbmV4cG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9kaXNwbGFjZW1lbnQvRGlzcGxhY2VtZW50RmlsdGVyLm1qcyc7XG5leHBvcnQgeyBOb2lzZUZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9kZWZhdWx0cy9ub2lzZS9Ob2lzZUZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgRmlsdGVyRWZmZWN0IH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuZXhwb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJQaXBlLm1qcyc7XG5leHBvcnQgeyBGaWx0ZXJTeXN0ZW0gfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBNYXNrRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL21hc2svTWFza0ZpbHRlci5tanMnO1xuZXhwb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L2dyb3VwRDgubWpzJztcbmV4cG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRyB9IGZyb20gJy4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9IGZyb20gJy4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5leHBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi9tYXRocy9taXNjL3NxdWFyZWREaXN0YW5jZVRvTGluZVNlZ21lbnQubWpzJztcbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5leHBvcnQgeyBQb2ludCB9IGZyb20gJy4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmV4cG9ydCB7IENpcmNsZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL0NpcmNsZS5tanMnO1xuZXhwb3J0IHsgRWxsaXBzZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL0VsbGlwc2UubWpzJztcbmV4cG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL21hdGhzL3NoYXBlcy9Qb2x5Z29uLm1qcyc7XG5leHBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9SZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tICcuL21hdGhzL3NoYXBlcy9Sb3VuZGVkUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4vbWF0aHMvc2hhcGVzL1RyaWFuZ2xlLm1qcyc7XG5leHBvcnQgeyBQcmVwYXJlQmFzZSB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlQmFzZS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZVF1ZXVlIH0gZnJvbSAnLi9wcmVwYXJlL1ByZXBhcmVRdWV1ZS5tanMnO1xuZXhwb3J0IHsgUHJlcGFyZVN5c3RlbSB9IGZyb20gJy4vcHJlcGFyZS9QcmVwYXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBQcmVwYXJlVXBsb2FkIH0gZnJvbSAnLi9wcmVwYXJlL1ByZXBhcmVVcGxvYWQubWpzJztcbmV4cG9ydCB7IEdsQmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9nbC9HbEJhdGNoQWRhcHRvci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L0JhdGNoR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlR1BVTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVHUFVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlTGF5b3V0IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvZ2VuZXJhdGVMYXlvdXQubWpzJztcbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1QmF0Y2hBZGFwdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvR3B1QmF0Y2hBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaCwgQmF0Y2hlciB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzJztcbmV4cG9ydCB7IEJhdGNoZXJQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlclBpcGUubWpzJztcbmV4cG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH0gZnJvbSAnLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcbmV4cG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4vcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmV4cG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyLCBjb21waWxlSGlnaFNoYWRlckdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvY29tcGlsZUhpZ2hTaGFkZXIubWpzJztcbmV4cG9ydCB7IGFkZEJpdHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9hZGRCaXRzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSG9va3MsIGZpbmRIb29rc1J4IH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUhvb2tzLm1qcyc7XG5leHBvcnQgeyBjb21waWxlSW5wdXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvY29tcGlsZUlucHV0cy5tanMnO1xuZXhwb3J0IHsgY29tcGlsZU91dHB1dHMgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlci91dGlscy9jb21waWxlT3V0cHV0cy5tanMnO1xuZXhwb3J0IHsgZm9ybWF0U2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvZm9ybWF0U2hhZGVyLm1qcyc7XG5leHBvcnQgeyBpbmplY3RCaXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZXIvdXRpbHMvaW5qZWN0Qml0cy5tanMnO1xuZXhwb3J0IHsgZnJhZ21lbnRHUFVUZW1wbGF0ZSwgZnJhZ21lbnRHbFRlbXBsYXRlLCB2ZXJ0ZXhHUFVUZW1wbGF0ZSwgdmVydGV4R2xUZW1wbGF0ZSB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL2RlZmF1bHRQcm9ncmFtVGVtcGxhdGUubWpzJztcbmV4cG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvY29sb3JCaXQubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVGV4dHVyZUJhdGNoQml0LCBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQubWpzJztcbmV4cG9ydCB7IGdsb2JhbFVuaWZvcm1zQml0LCBnbG9iYWxVbmlmb3Jtc0JpdEdsLCBnbG9iYWxVbmlmb3Jtc1VCT0JpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvZ2xvYmFsVW5pZm9ybXNCaXQubWpzJztcbmV4cG9ydCB7IGxvY2FsVW5pZm9ybUJpdCwgbG9jYWxVbmlmb3JtQml0R2wsIGxvY2FsVW5pZm9ybUJpdEdyb3VwMiB9IGZyb20gJy4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybUJpdC5tanMnO1xuZXhwb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9yb3VuZFBpeGVsc0JpdC5tanMnO1xuZXhwb3J0IHsgdGV4dHVyZUJpdCwgdGV4dHVyZUJpdEdsIH0gZnJvbSAnLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvdGV4dHVyZUJpdC5tanMnO1xuZXhwb3J0IHsgQWxwaGFNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9hbHBoYS9BbHBoYU1hc2subWpzJztcbmV4cG9ydCB7IEFscGhhTWFza1BpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFza1BpcGUubWpzJztcbmV4cG9ydCB7IENvbG9yTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svY29sb3IvQ29sb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBDb2xvck1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9jb2xvci9Db2xvck1hc2tQaXBlLm1qcyc7XG5leHBvcnQgeyBNYXNrRWZmZWN0TWFuYWdlciwgTWFza0VmZmVjdE1hbmFnZXJDbGFzcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzJztcbmV4cG9ydCB7IFNjaXNzb3JNYXNrIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zY2lzc29yL1NjaXNzb3JNYXNrLm1qcyc7XG5leHBvcnQgeyBTdGVuY2lsTWFzayB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanMnO1xuZXhwb3J0IHsgU3RlbmNpbE1hc2tQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay9zdGVuY2lsL1N0ZW5jaWxNYXNrUGlwZS5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL21hc2svdXRpbHMvYWRkTWFza0JvdW5kcy5tanMnO1xuZXhwb3J0IHsgYWRkTWFza0xvY2FsQm91bmRzLCBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50IH0gZnJvbSAnLi9yZW5kZXJpbmcvbWFzay91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzJztcbmV4cG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2J1ZmZlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgR2xCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvYnVmZmVyL0dsQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBHbEJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9idWZmZXIvR2xCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IENMRUFSIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHbENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvY29udGV4dC9HbENvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsR2VvbWV0cnlTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvZ2VvbWV0cnkvR2xHZW9tZXRyeVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgZ2V0R2xUeXBlRnJvbUZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9nZW9tZXRyeS91dGlscy9nZXRHbFR5cGVGcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBHbEJhY2tCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xCYWNrQnVmZmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbENvbG9yTWFza1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbENvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xFbmNvZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsRW5jb2RlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvR2xSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdsU3RlbmNpbFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9HbFN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdsVWJvU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL0dsVWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHbFJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0QWRhcHRvci5tanMnO1xuZXhwb3J0IHsgR2xSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvcmVuZGVyVGFyZ2V0L0dsUmVuZGVyVGFyZ2V0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9iYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVNoYWRlclN5bmNDb2RlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HZW5lcmF0ZVNoYWRlclN5bmNDb2RlLm1qcyc7XG5leHBvcnQgeyBHbFByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgR2xQcm9ncmFtRGF0YSwgSUdMVW5pZm9ybURhdGEgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsUHJvZ3JhbURhdGEubWpzJztcbmV4cG9ydCB7IEdsU2hhZGVyU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9HbFNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2xVbmlmb3JtR3JvdXBTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL0dsVW5pZm9ybUdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBtaWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9taWdyYXRlRnJhZ21lbnRGcm9tVjd0b1Y4Lm1qcyc7XG5leHBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2NvbXBpbGVTaGFkZXIubWpzJztcbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zaGFkZXIvcHJvZ3JhbS9kZWZhdWx0VmFsdWUubWpzJztcbmV4cG9ydCB7IGVuc3VyZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZW5zdXJlQXR0cmlidXRlcy5tanMnO1xuZXhwb3J0IHsgZXh0cmFjdEF0dHJpYnV0ZXNGcm9tR2xQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2V4dHJhY3RBdHRyaWJ1dGVzRnJvbUdsUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dlbmVyYXRlUHJvZ3JhbS5tanMnO1xuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24ubWpzJztcbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5leHBvcnQgeyBnZXRVYm9EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVib0RhdGEubWpzJztcbmV4cG9ydCB7IGdldFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL2dldFVuaWZvcm1EYXRhLm1qcyc7XG5leHBvcnQgeyBsb2dQcm9ncmFtRXJyb3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5leHBvcnQgeyBtYXBTaXplIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL21hcFNpemUubWpzJztcbmV4cG9ydCB7IG1hcEdsVG9WZXJ0ZXhGb3JtYXQsIG1hcFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vbWFwVHlwZS5tanMnO1xuZXhwb3J0IHsgYWRkUHJvZ3JhbURlZmluZXMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9hZGRQcm9ncmFtRGVmaW5lcy5tanMnO1xuZXhwb3J0IHsgZW5zdXJlUHJlY2lzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvZW5zdXJlUHJlY2lzaW9uLm1qcyc7XG5leHBvcnQgeyBpbnNlcnRWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvaW5zZXJ0VmVyc2lvbi5tanMnO1xuZXhwb3J0IHsgc2V0UHJvZ3JhbU5hbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3Byb2dyYW0vcHJlcHJvY2Vzc29ycy9zZXRQcm9ncmFtTmFtZS5tanMnO1xuZXhwb3J0IHsgc3RyaXBWZXJzaW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9wcm9ncmFtL3ByZXByb2Nlc3NvcnMvc3RyaXBWZXJzaW9uLm1qcyc7XG5leHBvcnQgeyBXR1NMX1RPX1NURDQwX1NJWkUsIGNyZWF0ZVVib0VsZW1lbnRzU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzU1RENDAubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVVib1N5bmNGdW5jdGlvblNURDQwIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9jcmVhdGVVYm9TeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlQXJyYXlTeW5jU1RENDAgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvc2hhZGVyL3V0aWxzL2dlbmVyYXRlQXJyYXlTeW5jU1RENDAubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuZXhwb3J0IHsgVU5JRk9STV9UT19BUlJBWV9TRVRURVJTLCBVTklGT1JNX1RPX1NJTkdMRV9TRVRURVJTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luY1R5cGVzLm1qcyc7XG5leHBvcnQgeyBHbFN0YXRlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3N0YXRlL0dsU3RhdGVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9zdGF0ZS9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzJztcbmV4cG9ydCB7IEdMX0ZPUk1BVFMsIEdMX1RBUkdFVFMsIEdMX1RZUEVTLCBHTF9XUkFQX01PREVTIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvY29uc3QubWpzJztcbmV4cG9ydCB7IEdsVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL0dsVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgR2xUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvR2xUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEJ1ZmZlckltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBnbFVwbG9hZFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91cGxvYWRlcnMvZ2xVcGxvYWRWaWRlb1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBhcHBseVN0eWxlUGFyYW1zIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvYXBwbHlTdHlsZVBhcmFtcy5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR2xDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9nZXRTdXBwb3J0ZWRHbENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xGb3JtYXQubWpzJztcbmV4cG9ydCB7IG1hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL21hcEZvcm1hdFRvR2xJbnRlcm5hbEZvcm1hdC5tanMnO1xuZXhwb3J0IHsgbWFwRm9ybWF0VG9HbFR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ2wvdGV4dHVyZS91dGlscy9tYXBGb3JtYXRUb0dsVHlwZS5tanMnO1xuZXhwb3J0IHsgY29tcGFyZU1vZGVUb0dsQ29tcGFyZSwgbWlwbWFwU2NhbGVNb2RlVG9HbEZpbHRlciwgc2NhbGVNb2RlVG9HbEZpbHRlciwgd3JhcE1vZGVUb0dsQWRkcmVzcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9nbC90ZXh0dXJlL3V0aWxzL3BpeGlUb0dsTWFwcy5tanMnO1xuZXhwb3J0IHsgdW5wcmVtdWx0aXBseUFscGhhIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3RleHR1cmUvdXRpbHMvdW5wcmVtdWx0aXBseUFscGhhLm1qcyc7XG5leHBvcnQgeyBXZWJHTFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL1dlYkdMUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvQmluZEdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVCdWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVJlYWRCdWZmZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L2J1ZmZlci9HcHVSZWFkQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBVYm9CYXRjaCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvYnVmZmVyL1Vib0JhdGNoLm1qcyc7XG5leHBvcnQgeyBHcHVDb2xvck1hc2tTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUNvbG9yTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgR3B1RGV2aWNlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVEZXZpY2VTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdUVuY29kZXJTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdUVuY29kZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVN0ZW5jaWxTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L0dwdVN0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdwdVVib1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvR3B1VWJvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVVbmlmb3JtQmF0Y2hQaXBlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9HcHVVbmlmb3JtQmF0Y2hQaXBlLm1qcyc7XG5leHBvcnQgeyBQaXBlbGluZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvcGlwZWxpbmUvUGlwZWxpbmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGNhbGN1bGF0ZVByb2plY3Rpb24gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9jYWxjdWxhdGVQcm9qZWN0aW9uLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IEdwdVJlbmRlclRhcmdldEFkYXB0b3IgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBHcHVSZW5kZXJUYXJnZXRTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3JlbmRlclRhcmdldC9HcHVSZW5kZXJUYXJnZXRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJpbmRHcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuZXhwb3J0IHsgR3B1UHJvZ3JhbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVByb2dyYW0ubWpzJztcbmV4cG9ydCB7IEdwdVNoYWRlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0dwdVNoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgV0dTTF9BTElHTl9TSVpFX0RBVEEsIGNyZWF0ZVVib0VsZW1lbnRzV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib0VsZW1lbnRzV0dTTC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2NyZWF0ZVVib1N5bmNGdW5jdGlvbldHU0wubWpzJztcbmV4cG9ydCB7IGV4dHJhY3RBdHRyaWJ1dGVzRnJvbUdwdVByb2dyYW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9leHRyYWN0QXR0cmlidXRlc0Zyb21HcHVQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0U3RydWN0QW5kR3JvdXBzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZXh0cmFjdFN0cnVjdEFuZEdyb3Vwcy5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVBcnJheVN5bmNXR1NMIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVBcnJheVN5bmNXR1NMLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUdwdUxheW91dEdyb3VwcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL2dlbmVyYXRlR3B1TGF5b3V0R3JvdXBzLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUxheW91dEhhc2ggfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3NoYWRlci91dGlscy9nZW5lcmF0ZUxheW91dEhhc2gubWpzJztcbmV4cG9ydCB7IHJlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL3V0aWxzL3JlbW92ZVN0cnVjdEFuZEdyb3VwRHVwbGljYXRlcy5tanMnO1xuZXhwb3J0IHsgR3B1QmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc3RhdGUvR3B1QmxlbmRNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1U3RhdGVTeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0YXRlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHcHVTdGVuY2lsTW9kZXNUb1BpeGkgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3N0YXRlL0dwdVN0ZW5jaWxNb2Rlc1RvUGl4aS5tanMnO1xuZXhwb3J0IHsgR3B1VGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvdGV4dHVyZS9HcHVUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRCdWZmZXJJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBibG9ja0RhdGFNYXAsIGdwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IGdwdVVwbG9hZEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L3RleHR1cmUvdXBsb2FkZXJzL2dwdVVwbG9hZEltYWdlU291cmNlLm1qcyc7XG5leHBvcnQgeyBncHVVcGxvYWRWaWRlb1Jlc291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3VwbG9hZGVycy9ncHVVcGxvYWRWaWRlb1NvdXJjZS5tanMnO1xuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkR1BVQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL2dldFN1cHBvcnRlZEdQVUNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5tanMnO1xuZXhwb3J0IHsgR3B1TWlwbWFwR2VuZXJhdG9yIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dwdS90ZXh0dXJlL3V0aWxzL0dwdU1pcG1hcEdlbmVyYXRvci5tanMnO1xuZXhwb3J0IHsgV2ViR1BVUmVuZGVyZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvZ3B1L1dlYkdQVVJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJsZW5kTW9kZVBpcGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2JsZW5kTW9kZXMvQmxlbmRNb2RlUGlwZS5tanMnO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlclJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5leHBvcnQgeyBFeHRyYWN0U3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9leHRyYWN0L0V4dHJhY3RTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdlbmVyYXRlVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZXh0cmFjdC9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IERSQVdfTU9ERVMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IGJ1aWxkU2ltcGxlVXZzLCBidWlsZFV2cyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuZXhwb3J0IHsgZ2V0QXR0cmlidXRlSW5mb0Zyb21Gb3JtYXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEF0dHJpYnV0ZUluZm9Gcm9tRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBnZXRHZW9tZXRyeUJvdW5kcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvZ2V0R2VvbWV0cnlCb3VuZHMubWpzJztcbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy90cmFuc2Zvcm1WZXJ0aWNlcy5tanMnO1xuZXhwb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuZXhwb3J0IHsgR2xvYmFsVW5pZm9ybVN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L0dsb2JhbFVuaWZvcm1TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGlzUmVuZGVyaW5nVG9TY3JlZW4gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9pc1JlbmRlcmluZ1RvU2NyZWVuLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC9SZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldFN5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvcmVuZGVyVGFyZ2V0L1JlbmRlclRhcmdldFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgdmlld3BvcnRGcm9tRnJhbWUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3JlbmRlclRhcmdldC92aWV3cG9ydEZyb21GcmFtZS5tanMnO1xuZXhwb3J0IHsgU2hhZGVyU3RhZ2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9jb25zdC5tanMnO1xuZXhwb3J0IHsgU2hhZGVyIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBVYm9TeXN0ZW0gfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3NoYWRlci9VYm9TeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlVWJvU3luY0Z1bmN0aW9uIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvY3JlYXRlVWJvU3luY0Z1bmN0aW9uLm1qcyc7XG5leHBvcnQgeyBnZXREZWZhdWx0VW5pZm9ybVZhbHVlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvZ2V0RGVmYXVsdFVuaWZvcm1WYWx1ZS5tanMnO1xuZXhwb3J0IHsgdWJvU3luY0Z1bmN0aW9uc1NURDQwLCB1Ym9TeW5jRnVuY3Rpb25zV0dTTCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL3V0aWxzL3Vib1N5bmNGdW5jdGlvbnMubWpzJztcbmV4cG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvdXRpbHMvdW5pZm9ybVBhcnNlcnMubWpzJztcbmV4cG9ydCB7IEhlbGxvU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGFydHVwL0hlbGxvU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBCTEVORF9UT19OUE0sIFNURU5DSUxfTU9ERVMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5leHBvcnQgeyBTdGF0ZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvU3RhdGUubWpzJztcbmV4cG9ydCB7IEFic3RyYWN0UmVuZGVyZXIgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N5c3RlbS9BYnN0cmFjdFJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBTaGFyZWRSZW5kZXJQaXBlcywgU2hhcmVkU3lzdGVtcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1NoYXJlZFN5c3RlbXMubWpzJztcbmV4cG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1N5c3RlbVJ1bm5lci5tanMnO1xuZXhwb3J0IHsgQ2FudmFzUG9vbCwgQ2FudmFzUG9vbENsYXNzIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmV4cG9ydCB7IERFUFJFQ0FURURfU0NBTEVfTU9ERVMsIERFUFJFQ0FURURfV1JBUF9NT0RFUywgTVNBQV9RVUFMSVRZLCBTQ0FMRV9NT0RFUywgV1JBUF9NT0RFUyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9jb25zdC5tanMnO1xuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0J1ZmZlclNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ2FudmFzU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5leHBvcnQgeyBDb21wcmVzc2VkU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ29tcHJlc3NlZFNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VTb3VyY2UgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9JbWFnZVNvdXJjZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL1RleHR1cmVTb3VyY2UubWpzJztcbmV4cG9ydCB7IFZpZGVvU291cmNlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvVmlkZW9Tb3VyY2UubWpzJztcbmV4cG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZUdDU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlTWF0cml4Lm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlUG9vbCwgVGV4dHVyZVBvb2xDbGFzcyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVN0eWxlIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVTdHlsZS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVV2cyB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlVXZzLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVVJRCB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9nZW5lcmF0ZVVJRC5tanMnO1xuZXhwb3J0IHsgZ2V0Q2FudmFzVGV4dHVyZSwgaGFzQ2FjaGVkQ2FudmFzVGV4dHVyZSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy9nZXRDYW52YXNUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBnZXRTdXBwb3J0ZWRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0U3VwcG9ydGVkQ29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLm1qcyc7XG5leHBvcnQgeyBnZXRTdXBwb3J0ZWRUZXh0dXJlRm9ybWF0cywgbm9uQ29tcHJlc3NlZEZvcm1hdHMgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvdXRpbHMvZ2V0U3VwcG9ydGVkVGV4dHVyZUZvcm1hdHMubWpzJztcbmV4cG9ydCB7IGF1dG9EZXRlY3RTb3VyY2UsIHJlc291cmNlVG9UZXh0dXJlLCB0ZXh0dXJlRnJvbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanMnO1xuZXhwb3J0IHsgY3JlYXRlSWRGcm9tU3RyaW5nIH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC91dGlscy9jcmVhdGVJZEZyb21TdHJpbmcubWpzJztcbmV4cG9ydCB7IHBhcnNlRnVuY3Rpb25Cb2R5IH0gZnJvbSAnLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC91dGlscy9wYXJzZUZ1bmN0aW9uQm9keS5tanMnO1xuZXhwb3J0IHsgVmlld1N5c3RlbSB9IGZyb20gJy4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdmlldy9WaWV3U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuL3JlbmRlcmluZy9yZW5kZXJlcnMvdHlwZXMubWpzJztcbmV4cG9ydCB7IEJvdW5kcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9Cb3VuZHMubWpzJztcbmV4cG9ydCB7IF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUsIGdldEZhc3RHbG9iYWxCb3VuZHMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanMnO1xuZXhwb3J0IHsgX2dldEdsb2JhbEJvdW5kcywgZ2V0R2xvYmFsQm91bmRzLCB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcyc7XG5leHBvcnQgeyBnZXRMb2NhbEJvdW5kcywgZ2V0UGFyZW50IH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldExvY2FsQm91bmRzLm1qcyc7XG5leHBvcnQgeyBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvYm91bmRzL2dldFJlbmRlcmFibGVCb3VuZHMubWpzJztcbmV4cG9ydCB7IGJvdW5kc1Bvb2wsIG1hdHJpeFBvb2wgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuZXhwb3J0IHsgY2hpbGRyZW5IZWxwZXJNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvY2hpbGRyZW5IZWxwZXJNaXhpbi5tanMnO1xuZXhwb3J0IHsgZWZmZWN0c01peGluIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9lZmZlY3RzTWl4aW4ubWpzJztcbmV4cG9ydCB7IGZpbmRNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZmluZE1peGluLm1qcyc7XG5leHBvcnQgeyBtZWFzdXJlTWl4aW4gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL21lYXN1cmVNaXhpbi5tanMnO1xuZXhwb3J0IHsgb25SZW5kZXJNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvb25SZW5kZXJNaXhpbi5tanMnO1xuZXhwb3J0IHsgc29ydE1peGluIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzJztcbmV4cG9ydCB7IHRvTG9jYWxHbG9iYWxNaXhpbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcyc7XG5leHBvcnQgeyBDb250YWluZXIsIFVQREFURV9CTEVORCwgVVBEQVRFX0NPTE9SLCBVUERBVEVfVFJBTlNGT1JNLCBVUERBVEVfVklTSUJMRSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuZXhwb3J0IHsgQ3VzdG9tUmVuZGVyUGlwZSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL0N1c3RvbVJlbmRlclBpcGUubWpzJztcbmV4cG9ydCB7IFJlbmRlckNvbnRhaW5lciB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL1JlbmRlckNvbnRhaW5lci5tanMnO1xuZXhwb3J0IHsgUmVuZGVyR3JvdXAgfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cC5tanMnO1xuZXhwb3J0IHsgUmVuZGVyR3JvdXBQaXBlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvUmVuZGVyR3JvdXBQaXBlLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJHcm91cFN5c3RlbSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL1JlbmRlckdyb3VwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBhc3NpZ25XaXRoSWdub3JlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRJbnN0cnVjdGlvbnMsIGNvbGxlY3RBbGxSZW5kZXJhYmxlcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2J1aWxkSW5zdHJ1Y3Rpb25zLm1qcyc7XG5leHBvcnQgeyBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanMnO1xuZXhwb3J0IHsgY29sbGVjdFJlbmRlckdyb3VwcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2NvbGxlY3RSZW5kZXJHcm91cHMubWpzJztcbmV4cG9ydCB7IGRlZmluZWRQcm9wcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2RlZmluZWRQcm9wcy5tanMnO1xuZXhwb3J0IHsgZXhlY3V0ZUluc3RydWN0aW9ucyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL2V4ZWN1dGVJbnN0cnVjdGlvbnMubWpzJztcbmV4cG9ydCB7IG1peENvbG9ycywgbWl4U3RhbmRhcmRBbmQzMkJpdENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL21peENvbG9ycy5tanMnO1xuZXhwb3J0IHsgbWl4SGV4Q29sb3JzIH0gZnJvbSAnLi9zY2VuZS9jb250YWluZXIvdXRpbHMvbWl4SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyBtdWx0aXBseUhleENvbG9ycyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL211bHRpcGx5SGV4Q29sb3JzLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVMb2NhbFRyYW5zZm9ybSB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZUxvY2FsVHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVSZW5kZXJHcm91cFRyYW5zZm9ybSwgdXBkYXRlUmVuZGVyR3JvdXBUcmFuc2Zvcm1zLCB1cGRhdGVUcmFuc2Zvcm1BbmRDaGlsZHJlbiB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3VwZGF0ZVJlbmRlckdyb3VwVHJhbnNmb3Jtcy5tanMnO1xuZXhwb3J0IHsgdXBkYXRlV29ybGRUcmFuc2Zvcm0gfSBmcm9tICcuL3NjZW5lL2NvbnRhaW5lci91dGlscy91cGRhdGVXb3JsZFRyYW5zZm9ybS5tanMnO1xuZXhwb3J0IHsgdmFsaWRhdGVSZW5kZXJhYmxlcyB9IGZyb20gJy4vc2NlbmUvY29udGFpbmVyL3V0aWxzL3ZhbGlkYXRlUmVuZGVyYWJsZXMubWpzJztcbmV4cG9ydCB7IEdsR3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9nbC9HbEdyYXBoaWNzQWRhcHRvci5tanMnO1xuZXhwb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSwgY29sb3JUb1VuaWZvcm0gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuZXhwb3J0IHsgR3B1R3JhcGhpY3NBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9ncHUvR3B1R3JhcGhpY3NBZGFwdG9yLm1qcyc7XG5leHBvcnQgeyBCYXRjaGFibGVHcmFwaGljcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0JhdGNoYWJsZUdyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5leHBvcnQgeyBidWlsZEFkYXB0aXZlUXVhZHJhdGljIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlUXVhZHJhdGljLm1qcyc7XG5leHBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG8gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG8ubWpzJztcbmV4cG9ydCB7IGJ1aWxkQXJjVG9TdmcgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzJztcbmV4cG9ydCB7IGJ1aWxkQ2lyY2xlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZExpbmUubWpzJztcbmV4cG9ydCB7IGJ1aWxkUG9seWdvbiB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRQb2x5Z29uLm1qcyc7XG5leHBvcnQgeyBidWlsZFJlY3RhbmdsZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkVHJpYW5nbGUubWpzJztcbmV4cG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvY29uc3QubWpzJztcbmV4cG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5leHBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3MubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzQ29udGV4dCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgR3B1R3JhcGhpY3NDb250ZXh0LCBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhLCBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdyYXBoaWNzUGlwZSB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzUGlwZS5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3NQYXRoIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvcGF0aC9HcmFwaGljc1BhdGgubWpzJztcbmV4cG9ydCB7IHJvdW5kZWRTaGFwZUFyYywgcm91bmRlZFNoYXBlUXVhZHJhdGljQ3VydmUgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL3JvdW5kU2hhcGUubWpzJztcbmV4cG9ydCB7IFNoYXBlUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvU2hhcGVQYXRoLm1qcyc7XG5leHBvcnQgeyBTVkdQYXJzZXIgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9zdmcvU1ZHUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBTVkdUb0dyYXBoaWNzUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanMnO1xuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2J1aWxkQ29udGV4dEJhdGNoZXMubWpzJztcbmV4cG9ydCB7IGJ1aWxkR2VvbWV0cnlGcm9tUGF0aCB9IGZyb20gJy4vc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2J1aWxkR2VvbWV0cnlGcm9tUGF0aC5tanMnO1xuZXhwb3J0IHsgY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH0gZnJvbSAnLi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvZ2V0T3JpZW50YXRpb25PZlBvaW50cy5tanMnO1xuZXhwb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMnO1xuZXhwb3J0IHsgTWVzaFBsYW5lIH0gZnJvbSAnLi9zY2VuZS9tZXNoLXBsYW5lL01lc2hQbGFuZS5tanMnO1xuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBNZXNoUm9wZSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvTWVzaFJvcGUubWpzJztcbmV4cG9ydCB7IE1lc2hTaW1wbGUgfSBmcm9tICcuL3NjZW5lL21lc2gtc2ltcGxlL01lc2hTaW1wbGUubWpzJztcbmV4cG9ydCB7IFJvcGVHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvbWVzaC1zaW1wbGUvUm9wZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBHbE1lc2hBZGFwdG9yIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dsL0dsTWVzaEFkYXB0b3IubWpzJztcbmV4cG9ydCB7IEdwdU1lc2hBZGFwdGVyIH0gZnJvbSAnLi9zY2VuZS9tZXNoL2dwdS9HcHVNZXNoQWRhcHRlci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4vc2NlbmUvbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuZXhwb3J0IHsgZ2V0VGV4dHVyZURlZmF1bHRNYXRyaXggfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL2dldFRleHR1cmVEZWZhdWx0TWF0cml4Lm1qcyc7XG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoLm1qcyc7XG5leHBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgTWVzaFBpcGUgfSBmcm9tICcuL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5leHBvcnQgeyBBbmltYXRlZFNwcml0ZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLWFuaW1hdGVkL0FuaW1hdGVkU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBOaW5lU2xpY2VHZW9tZXRyeSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IE5pbmVTbGljZVBsYW5lLCBOaW5lU2xpY2VTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS1uaW5lLXNsaWNlL05pbmVTbGljZVNwcml0ZS5tanMnO1xuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanMnO1xuZXhwb3J0IHsgdGlsaW5nQml0LCB0aWxpbmdCaXRHbCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvdGlsaW5nQml0Lm1qcyc7XG5leHBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL1RpbGluZ1Nwcml0ZVNoYWRlci5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZS5tanMnO1xuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy9UaWxpbmdTcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBhcHBseU1hdHJpeCB9IGZyb20gJy4vc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9hcHBseU1hdHJpeC5tanMnO1xuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgc2V0UG9zaXRpb25zIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFBvc2l0aW9ucy5tanMnO1xuZXhwb3J0IHsgc2V0VXZzIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL3NldFV2cy5tanMnO1xuZXhwb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi9zY2VuZS9zcHJpdGUvQmF0Y2hhYmxlU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmV4cG9ydCB7IFNwcml0ZVBpcGUgfSBmcm9tICcuL3NjZW5lL3Nwcml0ZS9TcHJpdGVQaXBlLm1qcyc7XG5leHBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgYml0bWFwRm9udFRleHRQYXJzZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL2Fzc2V0L2JpdG1hcEZvbnRUZXh0UGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9iaXRtYXBGb250WE1MU3RyaW5nUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBiaXRtYXBGb250Q2FjaGVQbHVnaW4sIGxvYWRCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9hc3NldC9sb2FkQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgQml0bWFwRm9udE1hbmFnZXIgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcEZvbnRNYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9CaXRtYXBUZXh0Lm1qcyc7XG5leHBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IER5bmFtaWNCaXRtYXBGb250IH0gZnJvbSAnLi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanMnO1xuZXhwb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1iaXRtYXAvdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0Lm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFBpcGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSwgbnNzdmcsIG5zeGh0bWwgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IVE1MVGV4dFJlbmRlckRhdGEubWpzJztcbmV4cG9ydCB7IEhUTUxUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC9IdG1sVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanMnO1xuZXhwb3J0IHsgRm9udFN0eWxlUHJvbWlzZUNhY2hlLCBnZXRGb250Q3NzIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0Rm9udENzcy5tanMnO1xuZXhwb3J0IHsgZ2V0U1ZHVXJsIH0gZnJvbSAnLi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcyc7XG5leHBvcnQgeyBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UubWpzJztcbmV4cG9ydCB7IGxvYWRGb250QXNCYXNlNjQgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5leHBvcnQgeyBsb2FkRm9udENTUyB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL2xvYWRGb250Q1NTLm1qcyc7XG5leHBvcnQgeyBsb2FkU1ZHSW1hZ2UgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkU1ZHSW1hZ2UubWpzJztcbmV4cG9ydCB7IG1lYXN1cmVIdG1sVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC1odG1sL3V0aWxzL21lYXN1cmVIdG1sVGV4dC5tanMnO1xuZXhwb3J0IHsgdGV4dFN0eWxlVG9DU1MgfSBmcm9tICcuL3NjZW5lL3RleHQtaHRtbC91dGlscy90ZXh0U3R5bGVUb0NTUy5tanMnO1xuZXhwb3J0IHsgQWJzdHJhY3RUZXh0LCBlbnN1cmVPcHRpb25zIH0gZnJvbSAnLi9zY2VuZS90ZXh0L0Fic3RyYWN0VGV4dC5tanMnO1xuZXhwb3J0IHsgQ2FudmFzVGV4dE1ldHJpY3MgfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5leHBvcnQgeyBDYW52YXNUZXh0UGlwZSB9IGZyb20gJy4vc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFBpcGUubWpzJztcbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfSBmcm9tICcuL3NjZW5lL3RleHQvY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuZXhwb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi9zY2VuZS90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcbmV4cG9ydCB7IFNkZlNoYWRlciB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5leHBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NjZW5lL3RleHQvc2RmU2hhZGVyL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmV4cG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuZXhwb3J0IHsgVGV4dCB9IGZyb20gJy4vc2NlbmUvdGV4dC9UZXh0Lm1qcyc7XG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBlbnN1cmVUZXh0U3R5bGUgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZW5zdXJlVGV4dFN0eWxlLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZVRleHRTdHlsZUtleSB9IGZyb20gJy4vc2NlbmUvdGV4dC91dGlscy9nZW5lcmF0ZVRleHRTdHlsZUtleS5tanMnO1xuZXhwb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzJztcbmV4cG9ydCB7IFNwcml0ZXNoZWV0IH0gZnJvbSAnLi9zcHJpdGVzaGVldC9TcHJpdGVzaGVldC5tanMnO1xuZXhwb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9IGZyb20gJy4vc3ByaXRlc2hlZXQvc3ByaXRlc2hlZXRBc3NldC5tanMnO1xuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi90aWNrZXIvY29uc3QubWpzJztcbmV4cG9ydCB7IFRpY2tlciB9IGZyb20gJy4vdGlja2VyL1RpY2tlci5tanMnO1xuZXhwb3J0IHsgVGlja2VyTGlzdGVuZXIgfSBmcm9tICcuL3RpY2tlci9UaWNrZXJMaXN0ZW5lci5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0VmlkZW9BbHBoYU1vZGUgfSBmcm9tICcuL3V0aWxzL2Jyb3dzZXIvZGV0ZWN0VmlkZW9BbHBoYU1vZGUubWpzJztcbmV4cG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi91dGlscy9icm93c2VyL2lzTW9iaWxlLm1qcyc7XG5leHBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanMnO1xuZXhwb3J0IHsgaXNXZWJHTFN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBpc1dlYkdQVVN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci9pc1dlYkdQVVN1cHBvcnRlZC5tanMnO1xuZXhwb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gJy4vdXRpbHMvYnJvd3Nlci91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4vdXRpbHMvY2FudmFzL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcyc7XG5leHBvcnQgeyBEQVRBX1VSSSB9IGZyb20gJy4vdXRpbHMvY29uc3QubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5leHBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJy4vdXRpbHMvZGF0YS9yZW1vdmVJdGVtcy5tanMnO1xuZXhwb3J0IHsgcmVzZXRVaWRzLCB1aWQgfSBmcm9tICcuL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5leHBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH0gZnJvbSAnLi91dGlscy9kYXRhL1ZpZXdhYmxlQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBsb2dEZWJ1Z1RleHR1cmUgfSBmcm9tICcuL3V0aWxzL2xvZ2dpbmcvbG9nRGVidWdUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBsb2dSZW5kZXJHcm91cFNjZW5lLCBsb2dTY2VuZSB9IGZyb20gJy4vdXRpbHMvbG9nZ2luZy9sb2dTY2VuZS5tanMnO1xuZXhwb3J0IHsgd2FybiB9IGZyb20gJy4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5leHBvcnQgeyBOT09QIH0gZnJvbSAnLi91dGlscy9taXNjL05PT1AubWpzJztcbmV4cG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJy4vdXRpbHMvbWlzYy9UcmFuc2Zvcm0ubWpzJztcbmV4cG9ydCB7IGdldFJlc29sdXRpb25PZlVybCB9IGZyb20gJy4vdXRpbHMvbmV0d29yay9nZXRSZXNvbHV0aW9uT2ZVcmwubWpzJztcbmV4cG9ydCB7IHBhdGggfSBmcm9tICcuL3V0aWxzL3BhdGgubWpzJztcbmV4cG9ydCB7IFBvb2wgfSBmcm9tICcuL3V0aWxzL3Bvb2wvUG9vbC5tanMnO1xuZXhwb3J0IHsgQmlnUG9vbCwgUG9vbEdyb3VwQ2xhc3MgfSBmcm9tICcuL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5leHBvcnQgeyBWRVJTSU9OLCBzYXlIZWxsbyB9IGZyb20gJy4vdXRpbHMvc2F5SGVsbG8ubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWFyY3V0IH0gZnJvbSAnZWFyY3V0JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChicm93c2VyRXh0LCB3ZWJ3b3JrZXJFeHQpO1xuXG5leHBvcnQgeyBicm93c2VyRXh0LCBleHRlbnNpb25zLCB3ZWJ3b3JrZXJFeHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2372\n')},5321:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   y: () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var _misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5502);\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(_misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__/* .PI_2 */ ._b - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\n\n//# sourceMappingURL=Matrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyMS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUNFOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLDJCQUEyQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUk7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxTQUFTLEtBQUssUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21hdHJpeC9NYXRyaXgubWpzP2I4MWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUElfMiB9IGZyb20gJy4uL21pc2MvY29uc3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBNYXRyaXgge1xuICAvKipcbiAgICogQHBhcmFtIGEgLSB4IHNjYWxlXG4gICAqIEBwYXJhbSBiIC0geSBza2V3XG4gICAqIEBwYXJhbSBjIC0geCBza2V3XG4gICAqIEBwYXJhbSBkIC0geSBzY2FsZVxuICAgKiBAcGFyYW0gdHggLSB4IHRyYW5zbGF0aW9uXG4gICAqIEBwYXJhbSB0eSAtIHkgdHJhbnNsYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgY3VycmVudCBtYXRyaXguIE9ubHkgcG9wdWxhdGVkIHdoZW4gYHRvQXJyYXlgIGlzIGNhbGxlZCAqL1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBhID0gYXJyYXlbMF1cbiAgICogYiA9IGFycmF5WzFdXG4gICAqIGMgPSBhcnJheVszXVxuICAgKiBkID0gYXJyYXlbNF1cbiAgICogdHggPSBhcnJheVsyXVxuICAgKiB0eSA9IGFycmF5WzVdXG4gICAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gYSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEBwYXJhbSBjIC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gZCAtIE1hdHJpeCBjb21wb25lbnRcbiAgICogQHBhcmFtIHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gdHkgLSBNYXRyaXggY29tcG9uZW50XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLnR4ID0gdHg7XG4gICAgdGhpcy50eSA9IHR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cbiAgICogQHBhcmFtIHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICogQHBhcmFtIFtvdXQ9bmV3IEZsb2F0MzJBcnJheSg5KV0gLSBJZiBwcm92aWRlZCB0aGUgYXJyYXkgd2lsbCBiZSBhc3NpZ25lZCB0byBvdXRcbiAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxuICAgKi9cbiAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCkge1xuICAgIGlmICghdGhpcy5hcnJheSkge1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IDA7XG4gICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgYXJyYXlbOF0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgKi9cbiAgYXBwbHkocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYiAqIHggKyB0aGlzLmQgKiB5ICsgdGhpcy50eTtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcbiAgICogQHBhcmFtIHBvcyAtIFRoZSBvcmlnaW5cbiAgICogQHBhcmFtIHtQb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIG5ldyBwb2ludCwgaW52ZXJzZS10cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gICAqL1xuICBhcHBseUludmVyc2UocG9zLCBuZXdQb3MpIHtcbiAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50KCk7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCB0eCA9IHRoaXMudHg7XG4gICAgY29uc3QgdHkgPSB0aGlzLnR5O1xuICAgIGNvbnN0IGlkID0gMSAvIChhICogZCArIGMgKiAtYik7XG4gICAgY29uc3QgeCA9IHBvcy54O1xuICAgIGNvbnN0IHkgPSBwb3MueTtcbiAgICBuZXdQb3MueCA9IGQgKiBpZCAqIHggKyAtYyAqIGlkICogeSArICh0eSAqIGMgLSB0eCAqIGQpICogaWQ7XG4gICAgbmV3UG9zLnkgPSBhICogaWQgKiB5ICsgLWIgKiBpZCAqIHggKyAoLXR5ICogYSArIHR4ICogYikgKiBpZDtcbiAgICByZXR1cm4gbmV3UG9zO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXG4gICAqIEBwYXJhbSB4IC0gSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICogQHBhcmFtIHkgLSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICogQHBhcmFtIHggLSBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseVxuICAgKiBAcGFyYW0geSAtIFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseVxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgc2NhbGUoeCwgeSkge1xuICAgIHRoaXMuYSAqPSB4O1xuICAgIHRoaXMuZCAqPSB5O1xuICAgIHRoaXMuYyAqPSB4O1xuICAgIHRoaXMuYiAqPSB5O1xuICAgIHRoaXMudHggKj0geDtcbiAgICB0aGlzLnR5ICo9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHJldHVybnMgVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0d28gbWF0cml4J3MgYW5kIHNldHMgdGhlIHJlc3VsdCB0byB0aGlzIG1hdHJpeC4gQUIgPSBBICogQlxuICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgYXBwZW5kRnJvbShhLCBiKSB7XG4gICAgY29uc3QgYTEgPSBhLmE7XG4gICAgY29uc3QgYjEgPSBhLmI7XG4gICAgY29uc3QgYzEgPSBhLmM7XG4gICAgY29uc3QgZDEgPSBhLmQ7XG4gICAgY29uc3QgdHggPSBhLnR4O1xuICAgIGNvbnN0IHR5ID0gYS50eTtcbiAgICBjb25zdCBhMiA9IGIuYTtcbiAgICBjb25zdCBiMiA9IGIuYjtcbiAgICBjb25zdCBjMiA9IGIuYztcbiAgICBjb25zdCBkMiA9IGIuZDtcbiAgICB0aGlzLmEgPSBhMSAqIGEyICsgYjEgKiBjMjtcbiAgICB0aGlzLmIgPSBhMSAqIGIyICsgYjEgKiBkMjtcbiAgICB0aGlzLmMgPSBjMSAqIGEyICsgZDEgKiBjMjtcbiAgICB0aGlzLmQgPSBjMSAqIGIyICsgZDEgKiBkMjtcbiAgICB0aGlzLnR4ID0gdHggKiBhMiArIHR5ICogYzIgKyBiLnR4O1xuICAgIHRoaXMudHkgPSB0eCAqIGIyICsgdHkgKiBkMiArIGIudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hdHJpeCBiYXNlZCBvbiBhbGwgdGhlIGF2YWlsYWJsZSBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB4IC0gUG9zaXRpb24gb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0geSAtIFBvc2l0aW9uIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHBpdm90WSAtIFBpdm90IG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWCAtIFNjYWxlIG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gUm90YXRpb24gaW4gcmFkaWFuc1xuICAgKiBAcGFyYW0gc2tld1ggLSBTa2V3IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgdGhpcy50eSA9IHkgLSAocGl2b3RYICogdGhpcy5iICsgcGl2b3RZICogdGhpcy5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cbiAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gcHJlcGVuZFxuICAgKiBAcmV0dXJucyBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICBjb25zdCB0eDEgPSB0aGlzLnR4O1xuICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgICBjb25zdCBjMSA9IHRoaXMuYztcbiAgICAgIHRoaXMuYSA9IGExICogbWF0cml4LmEgKyB0aGlzLmIgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuYiA9IGExICogbWF0cml4LmIgKyB0aGlzLmIgKiBtYXRyaXguZDtcbiAgICAgIHRoaXMuYyA9IGMxICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguYztcbiAgICAgIHRoaXMuZCA9IGMxICogbWF0cml4LmIgKyB0aGlzLmQgKiBtYXRyaXguZDtcbiAgICB9XG4gICAgdGhpcy50eCA9IHR4MSAqIG1hdHJpeC5hICsgdGhpcy50eSAqIG1hdHJpeC5jICsgbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSB0eDEgKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRGVjb21wb3NlcyB0aGUgbWF0cml4ICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgYW5kIHJvdGF0aW9uKSBhbmQgc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0byBhIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYXBwbHkgdGhlIHByb3BlcnRpZXMgdG8uXG4gICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gd2l0aCB0aGUgbmV3bHkgYXBwbGllZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuYTtcbiAgICBjb25zdCBiID0gdGhpcy5iO1xuICAgIGNvbnN0IGMgPSB0aGlzLmM7XG4gICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICBjb25zdCBwaXZvdCA9IHRyYW5zZm9ybS5waXZvdDtcbiAgICBjb25zdCBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICBjb25zdCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcbiAgICBpZiAoZGVsdGEgPCAxZS01IHx8IE1hdGguYWJzKFBJXzIgLSBkZWx0YSkgPCAxZS01KSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gMDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnggPSBza2V3WDtcbiAgICAgIHRyYW5zZm9ybS5za2V3LnkgPSBza2V3WTtcbiAgICB9XG4gICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgdHJhbnNmb3JtLnNjYWxlLnkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLnggPSB0aGlzLnR4ICsgKHBpdm90LnggKiBhICsgcGl2b3QueSAqIGMpO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdGhpcy50eSArIChwaXZvdC54ICogYiArIHBpdm90LnkgKiBkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgbWF0cml4XG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpbnZlcnQoKSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICBjb25zdCBuID0gYTEgKiBkMSAtIGIxICogYzE7XG4gICAgdGhpcy5hID0gZDEgLyBuO1xuICAgIHRoaXMuYiA9IC1iMSAvIG47XG4gICAgdGhpcy5jID0gLWMxIC8gbjtcbiAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgdGhpcy50eCA9IChjMSAqIHRoaXMudHkgLSBkMSAqIHR4MSkgLyBuO1xuICAgIHRoaXMudHkgPSAtKGExICogdGhpcy50eSAtIGIxICogdHgxKSAvIG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIENoZWNrcyBpZiB0aGlzIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXggKi9cbiAgaXNJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxICYmIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgTWF0cml4IHRvIGFuIGlkZW50aXR5IChkZWZhdWx0KSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICB0aGlzLmEgPSAxO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5jID0gMDtcbiAgICB0aGlzLmQgPSAxO1xuICAgIHRoaXMudHggPSAwO1xuICAgIHRoaXMudHkgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IGdpdmVuIGluIHBhcmFtZXRlciB3aXRoIGl0cyB2YWx1ZXMgdXBkYXRlZC5cbiAgICovXG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gZ2l2ZW4gbWF0cml4XG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgdGhpc1xuICAgKi9cbiAgY29weUZyb20obWF0cml4KSB7XG4gICAgdGhpcy5hID0gbWF0cml4LmE7XG4gICAgdGhpcy5iID0gbWF0cml4LmI7XG4gICAgdGhpcy5jID0gbWF0cml4LmM7XG4gICAgdGhpcy5kID0gbWF0cml4LmQ7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eDtcbiAgICB0aGlzLnR5ID0gbWF0cml4LnR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanM6TWF0cml4IGE9JHt0aGlzLmF9IGI9JHt0aGlzLmJ9IGM9JHt0aGlzLmN9IGQ9JHt0aGlzLmR9IHR4PSR7dGhpcy50eH0gdHk9JHt0aGlzLnR5fV1gO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgKGlkZW50aXR5KSBtYXRyaXguXG4gICAqXG4gICAqIFRoaXMgaXMgYSBzaGFyZWQgb2JqZWN0LCBpZiB5b3Ugd2FudCB0byBtb2RpZnkgaXQgY29uc2lkZXIgY3JlYXRpbmcgYSBuZXcgYE1hdHJpeGBcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBpZGVudGl0eU1hdHJpeC5pZGVudGl0eSgpO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0YXRpYyBNYXRyaXggdGhhdCBjYW4gYmUgdXNlZCB0byBhdm9pZCBjcmVhdGluZyBuZXcgb2JqZWN0cy5cbiAgICogV2lsbCBhbHdheXMgZW5zdXJlIHRoZSBtYXRyaXggaXMgcmVzZXQgdG8gaWRlbnRpdHkgd2hlbiByZXF1ZXN0ZWQuXG4gICAqIFVzZSB0aGlzIG9iamVjdCBmb3IgZmFzdCBidXQgdGVtcG9yYXJ5IGNhbGN1bGF0aW9ucywgYXMgaXQgbWF5IGJlIG11dGF0ZWQgbGF0ZXIgb24uXG4gICAqIFRoaXMgaXMgYSBkaWZmZXJlbnQgb2JqZWN0IHRvIHRoZSBgSURFTlRJVFlgIG9iamVjdCBhbmQgc28gY2FuIGJlIG1vZGlmaWVkIHdpdGhvdXQgY2hhbmdpbmcgYElERU5USVRZYC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICByZXR1cm4gdGVtcE1hdHJpeC5pZGVudGl0eSgpO1xuICB9XG59XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuY29uc3QgaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbmV4cG9ydCB7IE1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWF0cml4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5321\n")},5502:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZX: () => (/* binding */ DEG_TO_RAD),\n/* harmony export */   _b: () => (/* binding */ PI_2),\n/* harmony export */   jl: () => (/* binding */ RAD_TO_DEG)\n/* harmony export */ });\n\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2MvY29uc3QubWpzP2IzNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XG5jb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbmNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG5leHBvcnQgeyBERUdfVE9fUkFELCBQSV8yLCBSQURfVE9fREVHIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5502\n")},4181:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a9: () => (/* binding */ nextPow2),\n/* harmony export */   wv: () => (/* binding */ isPow2)\n/* harmony export */ });\n/* unused harmony export log2 */\n\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2MvcG93Mi5tanM/OGU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG5leHRQb3cyKHYpIHtcbiAgdiArPSB2ID09PSAwID8gMSA6IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5mdW5jdGlvbiBpc1BvdzIodikge1xuICByZXR1cm4gISh2ICYgdiAtIDEpICYmICEhdjtcbn1cbmZ1bmN0aW9uIGxvZzIodikge1xuICBsZXQgciA9ICh2ID4gNjU1MzUgPyAxIDogMCkgPDwgNDtcbiAgdiA+Pj49IHI7XG4gIGxldCBzaGlmdCA9ICh2ID4gMjU1ID8gMSA6IDApIDw8IDM7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDE1ID8gMSA6IDApIDw8IDI7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDMgPyAxIDogMCkgPDwgMTtcbiAgdiA+Pj49IHNoaWZ0O1xuICByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8IHYgPj4gMTtcbn1cblxuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG93Mi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4181\n")},4973:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ObservablePoint)\n/* harmony export */ });\n\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUcsSUFBSSxHQUFHLFFBQVEsZUFBZTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9wb2ludC9PYnNlcnZhYmxlUG9pbnQubWpzP2NjZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgT2JzZXJ2YWJsZVBvaW50YFxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBwYXNzIHRvIGxpc3RlbiBmb3IgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB4LCB5KSB7XG4gICAgdGhpcy5feCA9IHggfHwgMDtcbiAgICB0aGlzLl95ID0geSB8fCAwO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBPcHRpb25hbCBvYnNlcnZlciB0byBwYXNzIHRvIHRoZSBuZXcgb2JzZXJ2YWJsZSBwb2ludC5cbiAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgb2JzZXJ2YWJsZSBwb2ludFxuICAgKi9cbiAgY2xvbmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChvYnNlcnZlciA/PyB0aGlzLl9vYnNlcnZlciwgdGhpcy5feCwgdGhpcy5feSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT14XSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAqIEByZXR1cm5zIFRoZSBvYnNlcnZhYmxlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIGlmICh0aGlzLl94ICE9PSB4IHx8IHRoaXMuX3kgIT09IHkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLl9vYnNlcnZlci5fb25VcGRhdGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludCAoYHBgKVxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb20uIENhbiBiZSBhbnkgb2YgdHlwZSB0aGF0IGlzIG9yIGV4dGVuZHMgYFBvaW50RGF0YWBcbiAgICogQHJldHVybnMgVGhlIG9ic2VydmFibGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBjb3B5RnJvbShwKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcbiAgICAgIHRoaXMuX3ggPSBwLng7XG4gICAgICB0aGlzLl95ID0gcC55O1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuX29uVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhhdCBvZiB0aGUgZ2l2ZW4gcG9pbnQgKGBwYClcbiAgICogQHBhcmFtIHAgLSBUaGUgcG9pbnQgdG8gY29weSB0by4gQ2FuIGJlIGFueSBvZiB0eXBlIHRoYXQgaXMgb3IgZXh0ZW5kcyBgUG9pbnREYXRhYFxuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgKGBwYCkgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgKi9cbiAgY29weVRvKHApIHtcbiAgICBwLnNldCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLl94ICYmIHAueSA9PT0gdGhpcy5feTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6T2JzZXJ2YWJsZVBvaW50IHg9JHswfSB5PSR7MH0gc2NvcGU9JHt0aGlzLl9vYnNlcnZlcn1dYDtcbiAgfVxuICAvKiogUG9zaXRpb24gb2YgdGhlIG9ic2VydmFibGUgcG9pbnQgb24gdGhlIHggYXhpcy4gKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgIHRoaXMuX29ic2VydmVyLl9vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBvYnNlcnZhYmxlIHBvaW50IG9uIHRoZSB5IGF4aXMuICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3kgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICB0aGlzLl9vYnNlcnZlci5fb25VcGRhdGUodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGVQb2ludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVBvaW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4973\n")},1134:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ Point)\n/* harmony export */ });\n\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\n\n//# sourceMappingURL=Point.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsSUFBSSxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9wb2ludC9Qb2ludC5tanM/N2QzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvaW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYFBvaW50YFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzICovXG4gICAgdGhpcy54ID0gMDtcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMgKi9cbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICogQHJldHVybnMgQSBjbG9uZSBvZiB0aGlzIHBvaW50XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGB4YCBhbmQgYHlgIGZyb20gdGhlIGdpdmVuIHBvaW50IGludG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAgICogQHJldHVybnMgVGhlIHBvaW50IGluc3RhbmNlIGl0c2VsZlxuICAgKi9cbiAgY29weUZyb20ocCkge1xuICAgIHRoaXMuc2V0KHAueCwgcC55KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9pbnQncyB4IGFuZCB5IGludG8gdGhlIGdpdmVuIHBvaW50IChgcGApLlxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjb3B5IHRvLiBDYW4gYmUgYW55IG9mIHR5cGUgdGhhdCBpcyBvciBleHRlbmRzIGBQb2ludERhdGFgXG4gICAqIEByZXR1cm5zIFRoZSBwb2ludCAoYHBgKSB3aXRoIHZhbHVlcyB1cGRhdGVkXG4gICAqL1xuICBjb3B5VG8ocCkge1xuICAgIHAuc2V0KHRoaXMueCwgdGhpcy55KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhbm90aGVyIHBvaW50IChgcGApIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgKiBAcGFyYW0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGB4YCBhbmQgYHlgIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLnggJiYgcC55ID09PSB0aGlzLnk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IGB4YCBhbmQgYHlgIHBvc2l0aW9uLlxuICAgKiBJZiBgeWAgaXMgb21pdHRlZCwgYm90aCBgeGAgYW5kIGB5YCB3aWxsIGJlIHNldCB0byBgeGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgYHhgIGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSBgeWAgYXhpc1xuICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW5zdGFuY2UgaXRzZWxmXG4gICAqL1xuICBzZXQoeCA9IDAsIHkgPSB4KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW3BpeGkuanMvbWF0aDpQb2ludCB4PSR7dGhpcy54fSB5PSR7dGhpcy55fV1gO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0YXRpYyBQb2ludCBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCB2YWx1ZXMgb2YgYDBgLiBDYW4gYmUgdXNlZCB0byBhdm9pZCBjcmVhdGluZyBuZXcgb2JqZWN0cyBtdWx0aXBsZSB0aW1lcy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICB0ZW1wUG9pbnQueCA9IDA7XG4gICAgdGVtcFBvaW50LnkgPSAwO1xuICAgIHJldHVybiB0ZW1wUG9pbnQ7XG4gIH1cbn1cbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuXG5leHBvcnQgeyBQb2ludCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1134\n")},3904:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1134);\n\n\n"use strict";\nconst tempPoints = [new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Point */ .E()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'rectangle\'\n     */\n    this.type = "rectangle";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can\'t intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTJDOztBQUUzQztBQUNBLHdCQUF3Qiw0REFBSyxRQUFRLDREQUFLLFFBQVEsNERBQUssUUFBUSw0REFBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUywrRUFBK0U7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxRQUFRLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDckc7QUFDQTs7QUFFcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcz9mMzM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vcG9pbnQvUG9pbnQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wUG9pbnRzID0gW25ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIG5ldyBQb2ludCgpXTtcbmNsYXNzIFJlY3RhbmdsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncmVjdGFuZ2xlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwicmVjdGFuZ2xlXCI7XG4gICAgdGhpcy54ID0gTnVtYmVyKHgpO1xuICAgIHRoaXMueSA9IE51bWJlcih5KTtcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE51bWJlcihoZWlnaHQpO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlLiAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGUuICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMueTtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZS4gKi9cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgUmVjdGFuZ2xlIGlzIGVtcHR5LiAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT09IHRoaXMucmlnaHQgfHwgdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG4gIC8qKiBBIGNvbnN0YW50IGVtcHR5IHJlY3RhbmdsZS4gVGhpcyBpcyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgKi9cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXG4gICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEJvdW5kcyBvYmplY3QgdG8gYSBSZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIGJvdW5kcyB0byBjb3B5IGFuZCBjb252ZXJ0IHRvIGEgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tQm91bmRzKGJvdW5kcykge1xuICAgIHRoaXMueCA9IGJvdW5kcy5taW5YO1xuICAgIHRoaXMueSA9IGJvdW5kcy5taW5ZO1xuICAgIHRoaXMud2lkdGggPSBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YO1xuICAgIHRoaXMuaGVpZ2h0ID0gYm91bmRzLm1heFkgLSBib3VuZHMubWluWTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGFub3RoZXIgcmVjdGFuZ2xlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLmNvcHlGcm9tKHRoaXMpO1xuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdGFuZ2xlIGluY2x1ZGluZyB0aGUgc3Ryb2tlLlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSBzdHJva2VXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHJlY3RhbmdsZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgX3ggPSB0aGlzLng7XG4gICAgY29uc3QgX3kgPSB0aGlzLnk7XG4gICAgY29uc3Qgb3V0ZXJMZWZ0ID0gX3ggLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3Qgb3V0ZXJSaWdodCA9IF94ICsgd2lkdGggKyBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3Qgb3V0ZXJUb3AgPSBfeSAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBvdXRlckJvdHRvbSA9IF95ICsgaGVpZ2h0ICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyTGVmdCA9IF94ICsgc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyUmlnaHQgPSBfeCArIHdpZHRoIC0gc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IGlubmVyVG9wID0gX3kgKyBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaW5uZXJCb3R0b20gPSBfeSArIGhlaWdodCAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgICByZXR1cm4geCA+PSBvdXRlckxlZnQgJiYgeCA8PSBvdXRlclJpZ2h0ICYmIHkgPj0gb3V0ZXJUb3AgJiYgeSA8PSBvdXRlckJvdHRvbSAmJiAhKHggPiBpbm5lckxlZnQgJiYgeCA8IGlubmVyUmlnaHQgJiYgeSA+IGlubmVyVG9wICYmIHkgPCBpbm5lckJvdHRvbSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYG90aGVyYCBSZWN0YW5nbGUgdHJhbnNmb3JtZWQgYnkgYHRyYW5zZm9ybWAgaW50ZXJzZWN0cyB3aXRoIGB0aGlzYCBSZWN0YW5nbGUgb2JqZWN0LlxuICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgYXJlYSBvZiB0aGUgaW50ZXJzZWN0aW9uIGlzID4wLCB0aGlzIG1lYW5zIHRoYXQgUmVjdGFuZ2xlc1xuICAgKiBzaGFyaW5nIGEgc2lkZSBhcmUgbm90IG92ZXJsYXBwaW5nLiBBbm90aGVyIHNpZGUgZWZmZWN0IGlzIHRoYXQgYW4gYXJlYWxlc3MgcmVjdGFuZ2xlXG4gICAqICh3aWR0aCBvciBoZWlnaHQgZXF1YWwgdG8gemVybykgY2FuJ3QgaW50ZXJzZWN0IGFueSBvdGhlciByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBvdGhlciAtIFRoZSBSZWN0YW5nbGUgdG8gaW50ZXJzZWN0IHdpdGggYHRoaXNgLlxuICAgKiBAcGFyYW0ge01hdHJpeH0gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiBgb3RoZXJgLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSB2YWx1ZSBvZiBgdHJ1ZWAgaWYgdGhlIHRyYW5zZm9ybWVkIGBvdGhlcmAgUmVjdGFuZ2xlIGludGVyc2VjdHMgd2l0aCBgdGhpc2A7IG90aGVyd2lzZSBgZmFsc2VgLlxuICAgKi9cbiAgaW50ZXJzZWN0cyhvdGhlciwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnN0IHgwMiA9IHRoaXMueCA8IG90aGVyLnggPyBvdGhlci54IDogdGhpcy54O1xuICAgICAgY29uc3QgeDEyID0gdGhpcy5yaWdodCA+IG90aGVyLnJpZ2h0ID8gb3RoZXIucmlnaHQgOiB0aGlzLnJpZ2h0O1xuICAgICAgaWYgKHgxMiA8PSB4MDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgeTAyID0gdGhpcy55IDwgb3RoZXIueSA/IG90aGVyLnkgOiB0aGlzLnk7XG4gICAgICBjb25zdCB5MTIgPSB0aGlzLmJvdHRvbSA+IG90aGVyLmJvdHRvbSA/IG90aGVyLmJvdHRvbSA6IHRoaXMuYm90dG9tO1xuICAgICAgcmV0dXJuIHkxMiA+IHkwMjtcbiAgICB9XG4gICAgY29uc3QgeDAgPSB0aGlzLmxlZnQ7XG4gICAgY29uc3QgeDEgPSB0aGlzLnJpZ2h0O1xuICAgIGNvbnN0IHkwID0gdGhpcy50b3A7XG4gICAgY29uc3QgeTEgPSB0aGlzLmJvdHRvbTtcbiAgICBpZiAoeDEgPD0geDAgfHwgeTEgPD0geTApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbHQgPSB0ZW1wUG9pbnRzWzBdLnNldChvdGhlci5sZWZ0LCBvdGhlci50b3ApO1xuICAgIGNvbnN0IGxiID0gdGVtcFBvaW50c1sxXS5zZXQob3RoZXIubGVmdCwgb3RoZXIuYm90dG9tKTtcbiAgICBjb25zdCBydCA9IHRlbXBQb2ludHNbMl0uc2V0KG90aGVyLnJpZ2h0LCBvdGhlci50b3ApO1xuICAgIGNvbnN0IHJiID0gdGVtcFBvaW50c1szXS5zZXQob3RoZXIucmlnaHQsIG90aGVyLmJvdHRvbSk7XG4gICAgaWYgKHJ0LnggPD0gbHQueCB8fCBsYi55IDw9IGx0LnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcyA9IE1hdGguc2lnbih0cmFuc2Zvcm0uYSAqIHRyYW5zZm9ybS5kIC0gdHJhbnNmb3JtLmIgKiB0cmFuc2Zvcm0uYyk7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtLmFwcGx5KGx0LCBsdCk7XG4gICAgdHJhbnNmb3JtLmFwcGx5KGxiLCBsYik7XG4gICAgdHJhbnNmb3JtLmFwcGx5KHJ0LCBydCk7XG4gICAgdHJhbnNmb3JtLmFwcGx5KHJiLCByYik7XG4gICAgaWYgKE1hdGgubWF4KGx0LngsIGxiLngsIHJ0LngsIHJiLngpIDw9IHgwIHx8IE1hdGgubWluKGx0LngsIGxiLngsIHJ0LngsIHJiLngpID49IHgxIHx8IE1hdGgubWF4KGx0LnksIGxiLnksIHJ0LnksIHJiLnkpIDw9IHkwIHx8IE1hdGgubWluKGx0LnksIGxiLnksIHJ0LnksIHJiLnkpID49IHkxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG54ID0gcyAqIChsYi55IC0gbHQueSk7XG4gICAgY29uc3QgbnkgPSBzICogKGx0LnggLSBsYi54KTtcbiAgICBjb25zdCBuMDAgPSBueCAqIHgwICsgbnkgKiB5MDtcbiAgICBjb25zdCBuMTAgPSBueCAqIHgxICsgbnkgKiB5MDtcbiAgICBjb25zdCBuMDEgPSBueCAqIHgwICsgbnkgKiB5MTtcbiAgICBjb25zdCBuMTEgPSBueCAqIHgxICsgbnkgKiB5MTtcbiAgICBpZiAoTWF0aC5tYXgobjAwLCBuMTAsIG4wMSwgbjExKSA8PSBueCAqIGx0LnggKyBueSAqIGx0LnkgfHwgTWF0aC5taW4objAwLCBuMTAsIG4wMSwgbjExKSA+PSBueCAqIHJiLnggKyBueSAqIHJiLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbXggPSBzICogKGx0LnkgLSBydC55KTtcbiAgICBjb25zdCBteSA9IHMgKiAocnQueCAtIGx0LngpO1xuICAgIGNvbnN0IG0wMCA9IG14ICogeDAgKyBteSAqIHkwO1xuICAgIGNvbnN0IG0xMCA9IG14ICogeDEgKyBteSAqIHkwO1xuICAgIGNvbnN0IG0wMSA9IG14ICogeDAgKyBteSAqIHkxO1xuICAgIGNvbnN0IG0xMSA9IG14ICogeDEgKyBteSAqIHkxO1xuICAgIGlmIChNYXRoLm1heChtMDAsIG0xMCwgbTAxLCBtMTEpIDw9IG14ICogbHQueCArIG15ICogbHQueSB8fCBNYXRoLm1pbihtMDAsIG0xMCwgbTAxLCBtMTEpID49IG14ICogcmIueCArIG15ICogcmIueSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgdGhpcy54IC09IHBhZGRpbmdYO1xuICAgIHRoaXMueSAtPSBwYWRkaW5nWTtcbiAgICB0aGlzLndpZHRoICs9IHBhZGRpbmdYICogMjtcbiAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZpdHMgdGhpcyByZWN0YW5nbGUgYXJvdW5kIHRoZSBwYXNzZWQgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBmaXQuXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgZml0KHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgY29uc3QgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICBjb25zdCB5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHgxO1xuICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh4MiAtIHgxLCAwKTtcbiAgICB0aGlzLnkgPSB5MTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHkyIC0geTEsIDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmxhcmdlcyByZWN0YW5nbGUgdGhhdCB3YXkgaXRzIGNvcm5lcnMgbGllIG9uIGdyaWRcbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSByZXNvbHV0aW9uXG4gICAqIEBwYXJhbSBlcHMgLSBwcmVjaXNpb25cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjZWlsKHJlc29sdXRpb24gPSAxLCBlcHMgPSAxZS0zKSB7XG4gICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmxhcmdlcyB0aGlzIHJlY3RhbmdsZSB0byBpbmNsdWRlIHRoZSBwYXNzZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBpbmNsdWRlLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGVubGFyZ2UocmVjdGFuZ2xlKSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcmVjdGFuZ2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcGFyYW0gb3V0IC0gb3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICogQHJldHVybnMgVGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAqL1xuICBnZXRCb3VuZHMob3V0KSB7XG4gICAgb3V0ID0gb3V0IHx8IG5ldyBSZWN0YW5nbGUoKTtcbiAgICBvdXQuY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6UmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3904\n')},2971:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ BatchGeometry)\n/* harmony export */ });\n/* harmony import */ var _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7494);\n/* harmony import */ var _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n/* harmony import */ var _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1980);\n\n\n\n\n"use strict";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .Z {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderBufferData,\n      label: "attribute-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.VERTEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Buffer */ .l({\n      data: placeHolderIndexData,\n      label: "index-batch-buffer",\n      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.INDEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: "float32x2",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: "unorm8x4",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: "uint16x2",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0U7QUFDSTtBQUNFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0ZBQVE7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxnRkFBTTtBQUN0QztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxVQUFVLG9GQUFXO0FBQzdDO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixnRkFBTTtBQUNsQztBQUNBO0FBQ0EsYUFBYSxvRkFBVyxTQUFTLG9GQUFXO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9ncHUvQmF0Y2hHZW9tZXRyeS5tanM/NzRhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBsYWNlSG9sZGVyQnVmZmVyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCBwbGFjZUhvbGRlckluZGV4RGF0YSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHZlcnRleFNpemUgPSA2O1xuICAgIGNvbnN0IGF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogcGxhY2VIb2xkZXJCdWZmZXJEYXRhLFxuICAgICAgbGFiZWw6IFwiYXR0cmlidXRlLWJhdGNoLWJ1ZmZlclwiLFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHBsYWNlSG9sZGVySW5kZXhEYXRhLFxuICAgICAgbGFiZWw6IFwiaW5kZXgtYmF0Y2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuSU5ERVggfCBCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgIC8vIHwgQnVmZmVyVXNhZ2UuU1RBVElDLFxuICAgICAgc2hyaW5rVG9GaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3Qgc3RyaWRlID0gdmVydGV4U2l6ZSAqIDQ7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICBsb2NhdGlvbjogMVxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IGF0dHJpYnV0ZUJ1ZmZlcixcbiAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogMiAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDNcbiAgICAgICAgfSxcbiAgICAgICAgYUNvbG9yOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVub3JtOHg0XCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNCAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgYVRleHR1cmVJZEFuZFJvdW5kOiB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICAgICAgZm9ybWF0OiBcInVpbnQxNngyXCIsXG4gICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgIG9mZnNldDogNSAqIDQsXG4gICAgICAgICAgbG9jYXRpb246IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGV4QnVmZmVyXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2971\n')},3018:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ getTextureBatchBindGroup)\n/* harmony export */ });\n/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9818);\n/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4589);\n\n\n\n\n"use strict";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 0;\n  for (let i = 0; i < size; i++) {\n    uid = uid * 31 + textures[i].uid >>> 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, uid);\n}\nfunction generateTextureBatchBindGroup(textures, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  for (let i = 0; i < _shared_const_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MAX_TEXTURES */ .A; i++) {\n    const texture = i < textures.length ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BindGroup */ .v(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\n\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUU7QUFDQTtBQUNsQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLG9FQUFZLEVBQUU7QUFDcEMsd0RBQXdELG1GQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRkFBUztBQUNqQztBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L2dldFRleHR1cmVCYXRjaEJpbmRHcm91cC5tanM/MjQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5kR3JvdXAgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvZ3B1L3NoYWRlci9CaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgTUFYX1RFWFRVUkVTIH0gZnJvbSAnLi4vc2hhcmVkL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2FjaGVkR3JvdXBzID0ge307XG5mdW5jdGlvbiBnZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIHNpemUpIHtcbiAgbGV0IHVpZCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdWlkID0gdWlkICogMzEgKyB0ZXh0dXJlc1tpXS51aWQgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZEdyb3Vwc1t1aWRdIHx8IGdlbmVyYXRlVGV4dHVyZUJhdGNoQmluZEdyb3VwKHRleHR1cmVzLCB1aWQpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaW5kR3JvdXAodGV4dHVyZXMsIGtleSkge1xuICBjb25zdCBiaW5kR3JvdXBSZXNvdXJjZXMgPSB7fTtcbiAgbGV0IGJpbmRJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1RFWFRVUkVTOyBpKyspIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gaSA8IHRleHR1cmVzLmxlbmd0aCA/IHRleHR1cmVzW2ldIDogVGV4dHVyZS5FTVBUWS5zb3VyY2U7XG4gICAgYmluZEdyb3VwUmVzb3VyY2VzW2JpbmRJbmRleCsrXSA9IHRleHR1cmUuc291cmNlO1xuICAgIGJpbmRHcm91cFJlc291cmNlc1tiaW5kSW5kZXgrK10gPSB0ZXh0dXJlLnN0eWxlO1xuICB9XG4gIGNvbnN0IGJpbmRHcm91cCA9IG5ldyBCaW5kR3JvdXAoYmluZEdyb3VwUmVzb3VyY2VzKTtcbiAgY2FjaGVkR3JvdXBzW2tleV0gPSBiaW5kR3JvdXA7XG4gIHJldHVybiBiaW5kR3JvdXA7XG59XG5cbmV4cG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGV4dHVyZUJhdGNoQmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3018\n')},2067:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  m: () => (/* binding */ Batcher)\n});\n\n// UNUSED EXPORTS: Batch\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs\n\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs\nvar fastCopy = __webpack_require__(6633);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs\nvar state_const = __webpack_require__(2475);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\n\n\n"use strict";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === "no-premultiply-alpha") {\n    return state_const/* BLEND_TO_NPM */.f[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\n\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs\n\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs\nvar shared_const = __webpack_require__(4589);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs\n\n\n\n\n\n\n\n"use strict";\nclass Batch {\n  constructor() {\n    this.renderPipeId = "batch";\n    this.action = "startBatch";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = "normal";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = (0,uid/* uid */.h)("batcher");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = "startBatch";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= shared_const/* MAX_TEXTURES */.A || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = "renderBatch";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    (0,fastCopy/* fastCopy */.T)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      (0,fastCopy/* fastCopy */.T)(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\n\n//# sourceMappingURL=Batcher.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsSUFBSSw0QkFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvVmlld2FibGVCdWZmZXIubWpzP2UxM2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3RhdGUvZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZC5tanM/MjgxYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hUZXh0dXJlQXJyYXkubWpzPzc1ODkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL2JhdGNoZXIvc2hhcmVkL0JhdGNoZXIubWpzPzQwYTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBWaWV3YWJsZUJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHNpemVPckJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZU9yQnVmZmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZU9yQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNpemVPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlci5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IHNpemVPckJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLnJhd0JpbmFyeURhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEludDhBcnJheWAuICovXG4gIGdldCBpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDhWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQ4VmlldyA9IG5ldyBJbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDhWaWV3O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgVWludDhBcnJheWAuICovXG4gIGdldCB1aW50OFZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl91aW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX3VpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91aW50OFZpZXc7XG4gIH1cbiAgLyoqICBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgSW50MTZBcnJheWAuICovXG4gIGdldCBpbnQxNlZpZXcoKSB7XG4gICAgaWYgKCF0aGlzLl9pbnQxNlZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDE2VmlldyA9IG5ldyBJbnQxNkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pbnQxNlZpZXc7XG4gIH1cbiAgLyoqIFZpZXcgb24gdGhlIHJhdyBiaW5hcnkgZGF0YSBhcyBhIGBJbnQzMkFycmF5YC4gKi9cbiAgZ2V0IGludDMyVmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2ludDMyVmlldykge1xuICAgICAgdGhpcy5faW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ludDMyVmlldztcbiAgfVxuICAvKiogVmlldyBvbiB0aGUgcmF3IGJpbmFyeSBkYXRhIGFzIGEgYEZsb2F0NjRBcnJheWAuICovXG4gIGdldCBmbG9hdDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2Zsb2F0NjRBcnJheSkge1xuICAgICAgdGhpcy5fZmxvYXQ2NEFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmxvYXQ2NEFycmF5O1xuICB9XG4gIC8qKiBWaWV3IG9uIHRoZSByYXcgYmluYXJ5IGRhdGEgYXMgYSBgQmlnVWludDY0QXJyYXlgLiAqL1xuICBnZXQgYmlnVWludDY0VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX2JpZ1VpbnQ2NEFycmF5KSB7XG4gICAgICB0aGlzLl9iaWdVaW50NjRBcnJheSA9IG5ldyBCaWdVaW50NjRBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmlnVWludDY0QXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIC0gT25lIG9mIGBpbnQ4YCwgYHVpbnQ4YCwgYGludDE2YCxcbiAgICogICAgYHVpbnQxNmAsIGBpbnQzMmAsIGB1aW50MzJgLCBhbmQgYGZsb2F0MzJgLlxuICAgKiBAcmV0dXJucyAtIHR5cGVkIGFycmF5IG9mIGdpdmVuIHR5cGVcbiAgICovXG4gIHZpZXcodHlwZSkge1xuICAgIHJldHVybiB0aGlzW2Ake3R5cGV9Vmlld2BdO1xuICB9XG4gIC8qKiBEZXN0cm95cyBhbGwgYnVmZmVyIHJlZmVyZW5jZXMuIERvIG5vdCB1c2UgYWZ0ZXIgY2FsbGluZyB0aGlzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmF3QmluYXJ5RGF0YSA9IG51bGw7XG4gICAgdGhpcy5faW50OFZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5faW50MTZWaWV3ID0gbnVsbDtcbiAgICB0aGlzLnVpbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gdHlwZSBpbiBieXRlcy5cbiAgICogQHBhcmFtIHR5cGUgLSBPbmUgb2YgYGludDhgLCBgdWludDhgLCBgaW50MTZgLFxuICAgKiAgIGB1aW50MTZgLCBgaW50MzJgLCBgdWludDMyYCwgYW5kIGBmbG9hdDMyYC5cbiAgICogQHJldHVybnMgLSBzaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzXG4gICAqL1xuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9UT19OUE0gfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZChibGVuZE1vZGUsIHRleHR1cmVTb3VyY2UpIHtcbiAgaWYgKHRleHR1cmVTb3VyY2UuYWxwaGFNb2RlID09PSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCIpIHtcbiAgICByZXR1cm4gQkxFTkRfVE9fTlBNW2JsZW5kTW9kZV0gfHwgYmxlbmRNb2RlO1xuICB9XG4gIHJldHVybiBibGVuZE1vZGU7XG59XG5cbmV4cG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaFRleHR1cmVBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBSZXNwZWN0aXZlIGxvY2F0aW9ucyBmb3IgdGV4dHVyZXMuICovXG4gICAgdGhpcy5pZHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgLyoqIENsZWFyIHRoZSB0ZXh0dXJlcyBhbmQgdGhlaXIgbG9jYXRpb25zLiAqL1xuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdCA9IHRoaXMudGV4dHVyZXNbaV07XG4gICAgICB0aGlzLnRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIHRoaXMuaWRzW3QudWlkXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFRleHR1cmVBcnJheS5tanMubWFwXG4iLCJpbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL1ZpZXdhYmxlQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBmYXN0Q29weSB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL3V0aWxzL2Zhc3RDb3B5Lm1qcyc7XG5pbXBvcnQgeyBnZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kIH0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5pbXBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gJy4vQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcbmltcG9ydCB7IE1BWF9URVhUVVJFUyB9IGZyb20gJy4vY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCYXRjaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuYWN0aW9uID0gXCJzdGFydEJhdGNoXCI7XG4gICAgLy8gVE9ETyAtIGV2ZW50dWFsbHkgdGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGZsYWdnaW5nIGJhdGNoZXMgYXMgZGlydHkgYW5kIHRoZW4gb25seSByZWJ1aWxkaW5nIHRob3NlIG9uZXNcbiAgICAvLyBwdWJsaWMgZWxlbWVudFN0YXJ0ID0gMDtcbiAgICAvLyBwdWJsaWMgZWxlbWVudFNpemUgPSAwO1xuICAgIC8vIGZvciBkcmF3aW5nLi5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gXCJub3JtYWxcIjtcbiAgICB0aGlzLmNhbkJ1bmRsZSA9IHRydWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLmdwdUJpbmRHcm91cCA9IG51bGw7XG4gICAgdGhpcy5iaW5kR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gIH1cbn1cbmxldCBCQVRDSF9USUNLID0gMDtcbmNvbnN0IF9CYXRjaGVyID0gY2xhc3MgX0JhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImJhdGNoZXJcIik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXRjaEluZGV4ID0gMDtcbiAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAvLyBzcGVjaWZpY3MuXG4gICAgdGhpcy5fdmVydGV4U2l6ZSA9IDY7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9iYXRjaFBvb2wgPSBbXTtcbiAgICB0aGlzLl9iYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgdGhpcy5fdGV4dHVyZUJhdGNoUG9vbCA9IFtdO1xuICAgIHRoaXMuX3RleHR1cmVCYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgb3B0aW9ucyA9IHsgLi4uX0JhdGNoZXIuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICBjb25zdCB7IHZlcnRleFNpemUsIGluZGV4U2l6ZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcih2ZXJ0ZXhTaXplICogdGhpcy5fdmVydGV4U2l6ZSAqIDQpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoaW5kZXhTaXplKTtcbiAgfVxuICBiZWdpbigpIHtcbiAgICB0aGlzLmJhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSAwO1xuICAgIHRoaXMuZWxlbWVudFN0YXJ0ID0gMDtcbiAgICB0aGlzLmluZGV4U2l6ZSA9IDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVTaXplID0gMDtcbiAgICB0aGlzLl9iYXRjaFBvb2xJbmRleCA9IDA7XG4gICAgdGhpcy5fdGV4dHVyZUJhdGNoUG9vbEluZGV4ID0gMDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U3RhcnQgPSAwO1xuICAgIHRoaXMuX2JhdGNoSW5kZXhTaXplID0gMDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBhZGQoYmF0Y2hhYmxlT2JqZWN0KSB7XG4gICAgdGhpcy5fZWxlbWVudHNbdGhpcy5lbGVtZW50U2l6ZSsrXSA9IGJhdGNoYWJsZU9iamVjdDtcbiAgICBiYXRjaGFibGVPYmplY3QuaW5kZXhTdGFydCA9IHRoaXMuaW5kZXhTaXplO1xuICAgIGJhdGNoYWJsZU9iamVjdC5sb2NhdGlvbiA9IHRoaXMuYXR0cmlidXRlU2l6ZTtcbiAgICBiYXRjaGFibGVPYmplY3QuYmF0Y2hlciA9IHRoaXM7XG4gICAgdGhpcy5pbmRleFNpemUgKz0gYmF0Y2hhYmxlT2JqZWN0LmluZGV4U2l6ZTtcbiAgICB0aGlzLmF0dHJpYnV0ZVNpemUgKz0gYmF0Y2hhYmxlT2JqZWN0LnZlcnRleFNpemUgKiB0aGlzLl92ZXJ0ZXhTaXplO1xuICB9XG4gIGNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVPYmplY3QsIHRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXh0dXJlSWQgPSBiYXRjaGFibGVPYmplY3QuYmF0Y2gudGV4dHVyZXMuaWRzW3RleHR1cmUuX3NvdXJjZS51aWRdO1xuICAgIGlmICghdGV4dHVyZUlkICYmIHRleHR1cmVJZCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBiYXRjaGFibGVPYmplY3QudGV4dHVyZUlkID0gdGV4dHVyZUlkO1xuICAgIGJhdGNoYWJsZU9iamVjdC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVFbGVtZW50KGJhdGNoYWJsZU9iamVjdCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIGJhdGNoYWJsZU9iamVjdC5wYWNrQXR0cmlidXRlcyhcbiAgICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3LFxuICAgICAgdGhpcy5hdHRyaWJ1dGVCdWZmZXIudWludDMyVmlldyxcbiAgICAgIGJhdGNoYWJsZU9iamVjdC5sb2NhdGlvbixcbiAgICAgIGJhdGNoYWJsZU9iamVjdC50ZXh0dXJlSWRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBicmVha3MgdGhlIGJhdGNoZXIuIFRoaXMgaGFwcGVucyB3aGVuIGEgYmF0Y2ggZ2V0cyB0b28gYmlnLFxuICAgKiBvciB3ZSBuZWVkIHRvIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0eXBlIG9mIHJlbmRlcmluZyAoYSBmaWx0ZXIgZm9yIGV4YW1wbGUpXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvblNldFxuICAgKi9cbiAgYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzO1xuICAgIGxldCB0ZXh0dXJlQmF0Y2ggPSB0aGlzLl90ZXh0dXJlQmF0Y2hQb29sW3RoaXMuX3RleHR1cmVCYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2hUZXh0dXJlQXJyYXkoKTtcbiAgICB0ZXh0dXJlQmF0Y2guY2xlYXIoKTtcbiAgICBpZiAoIWVsZW1lbnRzW3RoaXMuZWxlbWVudFN0YXJ0XSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBlbGVtZW50c1t0aGlzLmVsZW1lbnRTdGFydF07XG4gICAgbGV0IGJsZW5kTW9kZSA9IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQoZmlyc3RFbGVtZW50LmJsZW5kTW9kZSwgZmlyc3RFbGVtZW50LnRleHR1cmUuX3NvdXJjZSk7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlU2l6ZSAqIDQgPiB0aGlzLmF0dHJpYnV0ZUJ1ZmZlci5zaXplKSB7XG4gICAgICB0aGlzLl9yZXNpemVBdHRyaWJ1dGVCdWZmZXIodGhpcy5hdHRyaWJ1dGVTaXplICogNCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluZGV4U2l6ZSA+IHRoaXMuaW5kZXhCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yZXNpemVJbmRleEJ1ZmZlcih0aGlzLmluZGV4U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGYzMiA9IHRoaXMuYXR0cmlidXRlQnVmZmVyLmZsb2F0MzJWaWV3O1xuICAgIGNvbnN0IHUzMiA9IHRoaXMuYXR0cmlidXRlQnVmZmVyLnVpbnQzMlZpZXc7XG4gICAgY29uc3QgaUJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXI7XG4gICAgbGV0IHNpemUgPSB0aGlzLl9iYXRjaEluZGV4U2l6ZTtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLl9iYXRjaEluZGV4U3RhcnQ7XG4gICAgbGV0IGFjdGlvbiA9IFwic3RhcnRCYXRjaFwiO1xuICAgIGxldCBiYXRjaCA9IHRoaXMuX2JhdGNoUG9vbFt0aGlzLl9iYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2goKTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5lbGVtZW50U3RhcnQ7IGkgPCB0aGlzLmVsZW1lbnRTaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsZW1lbnRzW2ldID0gbnVsbDtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBlbGVtZW50LnRleHR1cmU7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLl9zb3VyY2U7XG4gICAgICBjb25zdCBhZGp1c3RlZEJsZW5kTW9kZSA9IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQoZWxlbWVudC5ibGVuZE1vZGUsIHNvdXJjZSk7XG4gICAgICBjb25zdCBibGVuZE1vZGVDaGFuZ2UgPSBibGVuZE1vZGUgIT09IGFkanVzdGVkQmxlbmRNb2RlO1xuICAgICAgaWYgKHNvdXJjZS5fYmF0Y2hUaWNrID09PSBCQVRDSF9USUNLICYmICFibGVuZE1vZGVDaGFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC50ZXh0dXJlSWQgPSBzb3VyY2UuX3RleHR1cmVCaW5kTG9jYXRpb247XG4gICAgICAgIHNpemUgKz0gZWxlbWVudC5pbmRleFNpemU7XG4gICAgICAgIGVsZW1lbnQucGFja0F0dHJpYnV0ZXMoZjMyLCB1MzIsIGVsZW1lbnQubG9jYXRpb24sIGVsZW1lbnQudGV4dHVyZUlkKTtcbiAgICAgICAgZWxlbWVudC5wYWNrSW5kZXgoaUJ1ZmZlciwgZWxlbWVudC5pbmRleFN0YXJ0LCBlbGVtZW50LmxvY2F0aW9uIC8gdGhpcy5fdmVydGV4U2l6ZSk7XG4gICAgICAgIGVsZW1lbnQuYmF0Y2ggPSBiYXRjaDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuX2JhdGNoVGljayA9IEJBVENIX1RJQ0s7XG4gICAgICBpZiAodGV4dHVyZUJhdGNoLmNvdW50ID49IE1BWF9URVhUVVJFUyB8fCBibGVuZE1vZGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoQmF0Y2goXG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgc2l6ZSAtIHN0YXJ0LFxuICAgICAgICAgIHRleHR1cmVCYXRjaCxcbiAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25TZXQsXG4gICAgICAgICAgYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGFjdGlvbiA9IFwicmVuZGVyQmF0Y2hcIjtcbiAgICAgICAgc3RhcnQgPSBzaXplO1xuICAgICAgICBibGVuZE1vZGUgPSBhZGp1c3RlZEJsZW5kTW9kZTtcbiAgICAgICAgdGV4dHVyZUJhdGNoID0gdGhpcy5fdGV4dHVyZUJhdGNoUG9vbFt0aGlzLl90ZXh0dXJlQmF0Y2hQb29sSW5kZXgrK10gfHwgbmV3IEJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgICAgIHRleHR1cmVCYXRjaC5jbGVhcigpO1xuICAgICAgICBiYXRjaCA9IHRoaXMuX2JhdGNoUG9vbFt0aGlzLl9iYXRjaFBvb2xJbmRleCsrXSB8fCBuZXcgQmF0Y2goKTtcbiAgICAgICAgKytCQVRDSF9USUNLO1xuICAgICAgfVxuICAgICAgZWxlbWVudC50ZXh0dXJlSWQgPSBzb3VyY2UuX3RleHR1cmVCaW5kTG9jYXRpb24gPSB0ZXh0dXJlQmF0Y2guY291bnQ7XG4gICAgICB0ZXh0dXJlQmF0Y2guaWRzW3NvdXJjZS51aWRdID0gdGV4dHVyZUJhdGNoLmNvdW50O1xuICAgICAgdGV4dHVyZUJhdGNoLnRleHR1cmVzW3RleHR1cmVCYXRjaC5jb3VudCsrXSA9IHNvdXJjZTtcbiAgICAgIGVsZW1lbnQuYmF0Y2ggPSBiYXRjaDtcbiAgICAgIHNpemUgKz0gZWxlbWVudC5pbmRleFNpemU7XG4gICAgICBlbGVtZW50LnBhY2tBdHRyaWJ1dGVzKGYzMiwgdTMyLCBlbGVtZW50LmxvY2F0aW9uLCBlbGVtZW50LnRleHR1cmVJZCk7XG4gICAgICBlbGVtZW50LnBhY2tJbmRleChpQnVmZmVyLCBlbGVtZW50LmluZGV4U3RhcnQsIGVsZW1lbnQubG9jYXRpb24gLyB0aGlzLl92ZXJ0ZXhTaXplKTtcbiAgICB9XG4gICAgaWYgKHRleHR1cmVCYXRjaC5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpbmlzaEJhdGNoKFxuICAgICAgICBiYXRjaCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHNpemUgLSBzdGFydCxcbiAgICAgICAgdGV4dHVyZUJhdGNoLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluc3RydWN0aW9uU2V0LFxuICAgICAgICBhY3Rpb25cbiAgICAgICk7XG4gICAgICBzdGFydCA9IHNpemU7XG4gICAgICArK0JBVENIX1RJQ0s7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudFN0YXJ0ID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLl9iYXRjaEluZGV4U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9iYXRjaEluZGV4U2l6ZSA9IHNpemU7XG4gIH1cbiAgX2ZpbmlzaEJhdGNoKGJhdGNoLCBpbmRleFN0YXJ0LCBpbmRleFNpemUsIHRleHR1cmVCYXRjaCwgYmxlbmRNb2RlLCBpbnN0cnVjdGlvblNldCwgYWN0aW9uKSB7XG4gICAgYmF0Y2guZ3B1QmluZEdyb3VwID0gbnVsbDtcbiAgICBiYXRjaC5hY3Rpb24gPSBhY3Rpb247XG4gICAgYmF0Y2guYmF0Y2hlciA9IHRoaXM7XG4gICAgYmF0Y2gudGV4dHVyZXMgPSB0ZXh0dXJlQmF0Y2g7XG4gICAgYmF0Y2guYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIGJhdGNoLnN0YXJ0ID0gaW5kZXhTdGFydDtcbiAgICBiYXRjaC5zaXplID0gaW5kZXhTaXplO1xuICAgICsrQkFUQ0hfVElDSztcbiAgICBpbnN0cnVjdGlvblNldC5hZGQoYmF0Y2gpO1xuICB9XG4gIGZpbmlzaChpbnN0cnVjdGlvblNldCkge1xuICAgIHRoaXMuYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBhdHRyaWJ1dGUgYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XG4gICAgaWYgKHNpemUgKiA0IDw9IHRoaXMuYXR0cmlidXRlQnVmZmVyLnNpemUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUgKiA0KTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgaW5kZXggYnVmZmVyIHRvIHRoZSBnaXZlbiBzaXplICgxID0gMSBmbG9hdDMyKVxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIGluIHZlcnRpY2VzIHRvIGVuc3VyZSAobm90IGJ5dGVzISlcbiAgICovXG4gIGVuc3VyZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSB0aGlzLmluZGV4QnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9yZXNpemVJbmRleEJ1ZmZlcihzaXplKTtcbiAgfVxuICBfcmVzaXplQXR0cmlidXRlQnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBuZXdTaXplID0gTWF0aC5tYXgoc2l6ZSwgdGhpcy5hdHRyaWJ1dGVCdWZmZXIuc2l6ZSAqIDIpO1xuICAgIGNvbnN0IG5ld0FycmF5QnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKG5ld1NpemUpO1xuICAgIGZhc3RDb3B5KHRoaXMuYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEsIG5ld0FycmF5QnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyID0gbmV3QXJyYXlCdWZmZXI7XG4gIH1cbiAgX3Jlc2l6ZUluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IHRoaXMuaW5kZXhCdWZmZXI7XG4gICAgbGV0IG5ld1NpemUgPSBNYXRoLm1heChzaXplLCBpbmRleEJ1ZmZlci5sZW5ndGggKiAxLjUpO1xuICAgIG5ld1NpemUgKz0gbmV3U2l6ZSAlIDI7XG4gICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXdTaXplID4gNjU1MzUgPyBuZXcgVWludDMyQXJyYXkobmV3U2l6ZSkgOiBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gICAgaWYgKG5ld0luZGV4QnVmZmVyLkJZVEVTX1BFUl9FTEVNRU5UICE9PSBpbmRleEJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdJbmRleEJ1ZmZlcltpXSA9IGluZGV4QnVmZmVyW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYXN0Q29weShpbmRleEJ1ZmZlci5idWZmZXIsIG5ld0luZGV4QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmJhdGNoZXNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VsZW1lbnRzW2ldLmJhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudHMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlQnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlciA9IG51bGw7XG4gIH1cbn07XG5fQmF0Y2hlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdmVydGV4U2l6ZTogNCxcbiAgaW5kZXhTaXplOiA2XG59O1xubGV0IEJhdGNoZXIgPSBfQmF0Y2hlcjtcblxuZXhwb3J0IHsgQmF0Y2gsIEJhdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2067\n')},4589:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ MAX_TEXTURES)\n/* harmony export */ });\n\nconst MAX_TEXTURES = 16;\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU4OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9iYXRjaGVyL3NoYXJlZC9jb25zdC5tanM/OGM4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IE1BWF9URVhUVVJFUyA9IDE2O1xuXG5leHBvcnQgeyBNQVhfVEVYVFVSRVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4589\n")},9846:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs\nvar Sprite = __webpack_require__(5263);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs\n\n\n\n"use strict";\nconst tempBounds = new Bounds/* Bounds */.Y();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  (0,getGlobalBounds/* getGlobalBounds */.qW)(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\n\n//# sourceMappingURL=addMaskBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(2692);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs\n\n\n\n\n"use strict";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = matrixAndBoundsPool/* boundsPool */.W.get();\n  mask.measurable = true;\n  const tempMatrix = matrixAndBoundsPool/* matrixPool */.N.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  (0,getLocalBounds/* getLocalBounds */.a)(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixAndBoundsPool/* matrixPool */.N.return(tempMatrix);\n  matrixAndBoundsPool/* boundsPool */.W.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    (0,warn/* warn */.Z)("Mask bounds, renderable is not inside the root container");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\n\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs\n\n\n\n\n\n"use strict";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "alphaMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite/* Sprite */.j);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite/* Sprite */.j;\n  }\n}\nAlphaMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=AlphaMask.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs\n\n\n"use strict";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "colorMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === "number";\n  }\n}\nColorMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=ColorMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs + 12 modules\nvar Container = __webpack_require__(8400);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs\n\n\n\n\n\n"use strict";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = "stencilMask";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container/* Container */.W2;\n  }\n}\nStencilMask.extension = Extensions/* ExtensionType */.nw.MaskEffect;\n\n\n//# sourceMappingURL=StencilMask.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs\nvar BufferSource = __webpack_require__(4758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs\nvar CanvasSource = __webpack_require__(6914);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(9160);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(9366);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs\n\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement("canvas");\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      return "premultiply-alpha-on-upload";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement("video");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = "anonymous";\n      video2.preload = "auto";\n      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";\n      video2.load();\n    });\n    if (!video) {\n      return "premultiply-alpha-on-upload";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension("WEBGL_lose_context")?.loseContext();\n    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";\n  })());\n  return promise;\n}\n\n\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs\n\n\n\n\n\n"use strict";\nconst _VideoSource = class _VideoSource extends TextureSource/* TextureSource */.p {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = "video";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker/* Ticker */.v.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart);\n    source.addEventListener("pause", this._onPlayStop);\n    source.addEventListener("seeked", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener("canplay", this._onCanPlay);\n      }\n      source.addEventListener("canplaythrough", this._onCanPlayThrough);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener("error", this._onError, true);\n    this.emit("error", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener("canplay", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener("play", this._onPlayStart);\n      source.removeEventListener("pause", this._onPlayStop);\n      source.removeEventListener("seeked", this._onSeeked);\n      source.removeEventListener("canplay", this._onCanPlay);\n      source.removeEventListener("canplaythrough", this._onCanPlayThrough);\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser\'s native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video\'s state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn\'t playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.source.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker/* Ticker */.v.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker/* Ticker */.v.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker/* Ticker */.v.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n};\n_VideoSource.extension = Extensions/* ExtensionType */.nw.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource/* TextureSource */.p.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can\'t be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\nlet VideoSource = _VideoSource;\n\n\n//# sourceMappingURL=VideoSource.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs\nvar textureFrom = __webpack_require__(4325);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/init.mjs\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nExtensions/* extensions */.Rw.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource/* ImageSource */.c, CanvasSource/* CanvasSource */.D, BufferSource/* BufferImageSource */.A);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBYTtBQUN0QztBQUNBO0FBQ0EsS0FBSyxrQ0FBYTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVCO0FBQ3ZCOzs7OztBQ3BVMEQ7QUFDSDtBQUNBO0FBQ007QUFDMkI7QUFDTDtBQUNGO0FBQ0E7QUFDdkI7QUFDcEI7O0FBRXRDO0FBQ0EsNkJBQVUsS0FBSyxTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsOEJBQVcsRUFBRSxnQ0FBWSxFQUFFLHFDQUFpQjtBQUMzRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL3V0aWxzL2FkZE1hc2tCb3VuZHMubWpzPzE1NTUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svdXRpbHMvYWRkTWFza0xvY2FsQm91bmRzLm1qcz9jZGVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9tYXNrL2FscGhhL0FscGhhTWFzay5tanM/Y2ZiYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvbWFzay9jb2xvci9Db2xvck1hc2subWpzP2E3NzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svc3RlbmNpbC9TdGVuY2lsTWFzay5tanM/MmQ4NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9icm93c2VyL2RldGVjdFZpZGVvQWxwaGFNb2RlLm1qcz9iMDVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9WaWRlb1NvdXJjZS5tanM/MjYzMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvaW5pdC5tanM/ZDgwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRHbG9iYWxCb3VuZHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gYWRkTWFza0JvdW5kcyhtYXNrLCBib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgY29uc3QgYm91bmRzVG9NYXNrID0gdGVtcEJvdW5kcztcbiAgbWFzay5tZWFzdXJhYmxlID0gdHJ1ZTtcbiAgZ2V0R2xvYmFsQm91bmRzKG1hc2ssIHNraXBVcGRhdGVUcmFuc2Zvcm0sIGJvdW5kc1RvTWFzayk7XG4gIGJvdW5kcy5hZGRCb3VuZHNNYXNrKGJvdW5kc1RvTWFzayk7XG4gIG1hc2subWVhc3VyYWJsZSA9IGZhbHNlO1xufVxuXG5leHBvcnQgeyBhZGRNYXNrQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRNYXNrQm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCB7IGdldExvY2FsQm91bmRzIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRMb2NhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgYm91bmRzUG9vbCwgbWF0cml4UG9vbCB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFkZE1hc2tMb2NhbEJvdW5kcyhtYXNrLCBib3VuZHMsIGxvY2FsUm9vdCkge1xuICBjb25zdCBib3VuZHNUb01hc2sgPSBib3VuZHNQb29sLmdldCgpO1xuICBtYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICBjb25zdCB0ZW1wTWF0cml4ID0gbWF0cml4UG9vbC5nZXQoKS5pZGVudGl0eSgpO1xuICBjb25zdCByZWxhdGl2ZU1hc2sgPSBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50KG1hc2ssIGxvY2FsUm9vdCwgdGVtcE1hdHJpeCk7XG4gIGdldExvY2FsQm91bmRzKG1hc2ssIGJvdW5kc1RvTWFzaywgcmVsYXRpdmVNYXNrKTtcbiAgbWFzay5tZWFzdXJhYmxlID0gZmFsc2U7XG4gIGJvdW5kcy5hZGRCb3VuZHNNYXNrKGJvdW5kc1RvTWFzayk7XG4gIG1hdHJpeFBvb2wucmV0dXJuKHRlbXBNYXRyaXgpO1xuICBib3VuZHNQb29sLnJldHVybihib3VuZHNUb01hc2spO1xufVxuZnVuY3Rpb24gZ2V0TWF0cml4UmVsYXRpdmVUb1BhcmVudCh0YXJnZXQsIHJvb3QsIG1hdHJpeCkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHdhcm4oXCJNYXNrIGJvdW5kcywgcmVuZGVyYWJsZSBpcyBub3QgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lclwiKTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIGlmICh0YXJnZXQgIT09IHJvb3QpIHtcbiAgICBnZXRNYXRyaXhSZWxhdGl2ZVRvUGFyZW50KHRhcmdldC5wYXJlbnQsIHJvb3QsIG1hdHJpeCk7XG4gICAgdGFyZ2V0LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgbWF0cml4LmFwcGVuZCh0YXJnZXQubG9jYWxUcmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmV4cG9ydCB7IGFkZE1hc2tMb2NhbEJvdW5kcywgZ2V0TWF0cml4UmVsYXRpdmVUb1BhcmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkTWFza0xvY2FsQm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJy4uLy4uLy4uL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzJztcbmltcG9ydCB7IGFkZE1hc2tCb3VuZHMgfSBmcm9tICcuLi91dGlscy9hZGRNYXNrQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBhZGRNYXNrTG9jYWxCb3VuZHMgfSBmcm9tICcuLi91dGlscy9hZGRNYXNrTG9jYWxCb3VuZHMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBbHBoYU1hc2sge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgdGhpcy5waXBlID0gXCJhbHBoYU1hc2tcIjtcbiAgICBpZiAob3B0aW9ucz8ubWFzaykge1xuICAgICAgdGhpcy5pbml0KG9wdGlvbnMubWFzayk7XG4gICAgfVxuICB9XG4gIGluaXQobWFzaykge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gICAgdGhpcy5yZW5kZXJNYXNrVG9UZXh0dXJlID0gIShtYXNrIGluc3RhbmNlb2YgU3ByaXRlKTtcbiAgICB0aGlzLm1hc2sucmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyTWFza1RvVGV4dHVyZTtcbiAgICB0aGlzLm1hc2suaW5jbHVkZUluQnVpbGQgPSAhdGhpcy5yZW5kZXJNYXNrVG9UZXh0dXJlO1xuICAgIHRoaXMubWFzay5tZWFzdXJhYmxlID0gZmFsc2U7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tYXNrLm1lYXN1cmFibGUgPSB0cnVlO1xuICAgIHRoaXMubWFzayA9IG51bGw7XG4gIH1cbiAgYWRkQm91bmRzKGJvdW5kcywgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICAgIGFkZE1hc2tCb3VuZHModGhpcy5tYXNrLCBib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pO1xuICB9XG4gIGFkZExvY2FsQm91bmRzKGJvdW5kcywgbG9jYWxSb290KSB7XG4gICAgYWRkTWFza0xvY2FsQm91bmRzKHRoaXMubWFzaywgYm91bmRzLCBsb2NhbFJvb3QpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQsIGhpdFRlc3RGbikge1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLm1hc2s7XG4gICAgcmV0dXJuIGhpdFRlc3RGbihtYXNrLCBwb2ludCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgc3RhdGljIHRlc3QobWFzaykge1xuICAgIHJldHVybiBtYXNrIGluc3RhbmNlb2YgU3ByaXRlO1xuICB9XG59XG5BbHBoYU1hc2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0O1xuXG5leHBvcnQgeyBBbHBoYU1hc2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFscGhhTWFzay5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQ29sb3JNYXNrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMucGlwZSA9IFwiY29sb3JNYXNrXCI7XG4gICAgaWYgKG9wdGlvbnM/Lm1hc2spIHtcbiAgICAgIHRoaXMuaW5pdChvcHRpb25zLm1hc2spO1xuICAgIH1cbiAgfVxuICBpbml0KG1hc2spIHtcbiAgICB0aGlzLm1hc2sgPSBtYXNrO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbiAgc3RhdGljIHRlc3QobWFzaykge1xuICAgIHJldHVybiB0eXBlb2YgbWFzayA9PT0gXCJudW1iZXJcIjtcbiAgfVxufVxuQ29sb3JNYXNrLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuTWFza0VmZmVjdDtcblxuZXhwb3J0IHsgQ29sb3JNYXNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvck1hc2subWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgYWRkTWFza0JvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tCb3VuZHMubWpzJztcbmltcG9ydCB7IGFkZE1hc2tMb2NhbEJvdW5kcyB9IGZyb20gJy4uL3V0aWxzL2FkZE1hc2tMb2NhbEJvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFN0ZW5jaWxNYXNrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgIHRoaXMucGlwZSA9IFwic3RlbmNpbE1hc2tcIjtcbiAgICBpZiAob3B0aW9ucz8ubWFzaykge1xuICAgICAgdGhpcy5pbml0KG9wdGlvbnMubWFzayk7XG4gICAgfVxuICB9XG4gIGluaXQobWFzaykge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gICAgdGhpcy5tYXNrLmluY2x1ZGVJbkJ1aWxkID0gZmFsc2U7XG4gICAgdGhpcy5tYXNrLm1lYXN1cmFibGUgPSBmYWxzZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1hc2subWVhc3VyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXNrLmluY2x1ZGVJbkJ1aWxkID0gdHJ1ZTtcbiAgICB0aGlzLm1hc2sgPSBudWxsO1xuICB9XG4gIGFkZEJvdW5kcyhib3VuZHMsIHNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICBhZGRNYXNrQm91bmRzKHRoaXMubWFzaywgYm91bmRzLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgfVxuICBhZGRMb2NhbEJvdW5kcyhib3VuZHMsIGxvY2FsUm9vdCkge1xuICAgIGFkZE1hc2tMb2NhbEJvdW5kcyh0aGlzLm1hc2ssIGJvdW5kcywgbG9jYWxSb290KTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50LCBoaXRUZXN0Rm4pIHtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5tYXNrO1xuICAgIHJldHVybiBoaXRUZXN0Rm4obWFzaywgcG9pbnQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIHN0YXRpYyB0ZXN0KG1hc2spIHtcbiAgICByZXR1cm4gbWFzayBpbnN0YW5jZW9mIENvbnRhaW5lcjtcbiAgfVxufVxuU3RlbmNpbE1hc2suZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0O1xuXG5leHBvcnQgeyBTdGVuY2lsTWFzayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RlbmNpbE1hc2subWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgcHJvbWlzZTtcbmFzeW5jIGZ1bmN0aW9uIGRldGVjdFZpZGVvQWxwaGFNb2RlKCkge1xuICBwcm9taXNlID8/IChwcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICByZXR1cm4gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW8gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgdmlkZW8yLm9ubG9hZGVkZGF0YSA9ICgpID0+IHJlc29sdmUodmlkZW8yKTtcbiAgICAgIHZpZGVvMi5vbmVycm9yID0gKCkgPT4gcmVzb2x2ZShudWxsKTtcbiAgICAgIHZpZGVvMi5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgdmlkZW8yLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgIHZpZGVvMi5wcmVsb2FkID0gXCJhdXRvXCI7XG4gICAgICB2aWRlbzIuc3JjID0gXCJkYXRhOnZpZGVvL3dlYm07YmFzZTY0LEdrWGZvNTlDaG9FQlF2ZUJBVUx5Z1FSQzg0RUlRb0tFZDJWaWJVS0hnUUpDaFlFQ0dGT0Fad0VBQUFBQUFBSFRFVTJiZExwTnU0dFRxNFFWU2FsbVU2eUJvVTI3aTFPcmhCWlVybXRUcklIR1RidU1VNnVFRWxURFoxT3NnZ0VYVGJ1TVU2dUVIRk83YTFPc2dnRzk3QUVBQUFBQUFBQlpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVZTYWxtb0NyWHNZTVBRa0JOZ0lSTVlYWm1WMEdFVEdGMlprU0ppRUJFQUFBQUFBQUFGbFN1YTh5dUFRQUFBQUFBQUVQWGdRRnp4WWdBQUFBQUFBQUFBWnlCQUNLMW5JTjFibVNJZ1FDR2hWWmZWbEE1ZzRFQkkrT0RoQUppV2dEZ2xMQ0JBcnFCQXBxQkFsUEFnUUZWc0lSVnVZRUJFbFREWjlWemM5Smp3SXRqeFlnQUFBQUFBQUFBQVdmSW5FV2poMFZPUTA5RVJWSkVoNDlNWVhaaklHeHBZblp3ZUMxMmNEbG55S0pGbzRoRVZWSkJWRWxQVGtTSGxEQXdPakF3T2pBd0xqQTBNREF3TURBd01BQUFIME8yZGNmbmdRQ2d3cUdnZ1FBQUFJSkpnMElBQUJBQUZnQTRKQndZU2dBQUlDQUFFYi8vLzRyK0FBQjFvWjJtbSs2QkFhV1dna21EUWdBQUVBQVdBRGdrSEJoS0FBQWdJQUJJUUJ4VHUydVJ1NCt6Z1FDM2l2ZUJBZkdDQVhId2dRTT1cIjtcbiAgICAgIHZpZGVvMi5sb2FkKCk7XG4gICAgfSk7XG4gICAgaWYgKCF2aWRlbykge1xuICAgICAgcmV0dXJuIFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCI7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0ZXh0dXJlLFxuICAgICAgMFxuICAgICk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZ2wuTk9ORSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB2aWRlbyk7XG4gICAgY29uc3QgcGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVsKTtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik/Lmxvc2VDb250ZXh0KCk7XG4gICAgcmV0dXJuIHBpeGVsWzBdIDw9IHBpeGVsWzNdID8gXCJwcmVtdWx0aXBsaWVkLWFscGhhXCIgOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiO1xuICB9KSgpKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmV4cG9ydCB7IGRldGVjdFZpZGVvQWxwaGFNb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RWaWRlb0FscGhhTW9kZS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi90aWNrZXIvVGlja2VyLm1qcyc7XG5pbXBvcnQgeyBkZXRlY3RWaWRlb0FscGhhTW9kZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2Jyb3dzZXIvZGV0ZWN0VmlkZW9BbHBoYU1vZGUubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL1RleHR1cmVTb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVmlkZW9Tb3VyY2UgPSBjbGFzcyBfVmlkZW9Tb3VyY2UgZXh0ZW5kcyBUZXh0dXJlU291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIC8vIFB1YmxpY1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheS4gKi9cbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgICAvKiogVGhlIHVwbG9hZCBtZXRob2QgZm9yIHRoaXMgdGV4dHVyZS4gKi9cbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJ2aWRlb1wiO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5fVmlkZW9Tb3VyY2UuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLl9hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlRlBTID0gb3B0aW9ucy51cGRhdGVGUFMgfHwgMDtcbiAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IDA7XG4gICAgdGhpcy5hdXRvUGxheSA9IG9wdGlvbnMuYXV0b1BsYXkgIT09IGZhbHNlO1xuICAgIHRoaXMuYWxwaGFNb2RlID0gb3B0aW9ucy5hbHBoYU1vZGUgPz8gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrID0gdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DYW5QbGF5VGhyb3VnaCA9IHRoaXMuX29uQ2FuUGxheVRocm91Z2guYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUGxheVN0YXJ0ID0gdGhpcy5fb25QbGF5U3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBsYXlTdG9wID0gdGhpcy5fb25QbGF5U3RvcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Vla2VkID0gdGhpcy5fb25TZWVrZWQuYmluZCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIC8qKiBVcGRhdGUgdGhlIHZpZGVvIGZyYW1lIGlmIHRoZSBzb3VyY2UgaXMgbm90IGRlc3Ryb3llZCBhbmQgbWVldHMgY2VydGFpbiBjb25kaXRpb25zLiAqL1xuICB1cGRhdGVGcmFtZSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VwZGF0ZUZQUykge1xuICAgICAgY29uc3QgZWxhcHNlZE1TID0gVGlja2VyLnNoYXJlZC5lbGFwc2VkTVMgKiB0aGlzLnJlc291cmNlLnBsYXliYWNrUmF0ZTtcbiAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9tc1RvTmV4dFVwZGF0ZSAtIGVsYXBzZWRNUyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fdXBkYXRlRlBTIHx8IHRoaXMuX21zVG9OZXh0VXBkYXRlIDw9IDApIHtcbiAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxZTMgLyB0aGlzLl91cGRhdGVGUFMpIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqIENhbGxiYWNrIHRvIHVwZGF0ZSB0aGUgdmlkZW8gZnJhbWUgYW5kIHBvdGVudGlhbGx5IHJlcXVlc3QgdGhlIG5leHQgZnJhbWUgdXBkYXRlLiAqL1xuICBfdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFjaygpIHtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lKCk7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICB0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9IHRoaXMuc291cmNlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soXG4gICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHJlc291cmNlIGhhcyB2YWxpZCBkaW1lbnNpb25zLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzZXQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVzb3VyY2UudmlkZW9XaWR0aCAmJiAhIXRoaXMucmVzb3VyY2UudmlkZW9IZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHByZWxvYWRpbmcgdGhlIHZpZGVvIHJlc291cmNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx0aGlzPn0gSGFuZGxlIHRoZSB2YWxpZGF0ZSBldmVudFxuICAgKi9cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XG4gICAgICBzb3VyY2UuY29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIiwgdGhpcy5fb25QbGF5U3RhcnQpO1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCk7XG4gICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgdGhpcy5fb25TZWVrZWQpO1xuICAgIGlmICghdGhpcy5faXNTb3VyY2VSZWFkeSgpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucHJlbG9hZCkge1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5VGhyb3VnaCk7XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tZWRpYVJlYWR5KCk7XG4gICAgfVxuICAgIHRoaXMuYWxwaGFNb2RlID0gYXdhaXQgZGV0ZWN0VmlkZW9BbHBoYU1vZGUoKTtcbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlbG9hZFRpbWVvdXRNcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5fcHJlbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yRXZlbnQoYFByZWxvYWQgZXhjZWVkZWQgdGltZW91dCBvZiAke29wdGlvbnMucHJlbG9hZFRpbWVvdXRNc31tc2ApKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgdmlkZW8gZXJyb3IgZXZlbnRzLlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXJyb3IgZXZlbnRcbiAgICovXG4gIF9vbkVycm9yKGV2ZW50KSB7XG4gICAgdGhpcy5yZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXZlbnQpO1xuICAgIGlmICh0aGlzLl9yZWplY3QpIHtcbiAgICAgIHRoaXMuX3JlamVjdChldmVudCk7XG4gICAgICB0aGlzLl9yZWplY3QgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHBsYXlpbmcuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgcGxheWluZy5cbiAgICovXG4gIF9pc1NvdXJjZVBsYXlpbmcoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICByZXR1cm4gIXNvdXJjZS5wYXVzZWQgJiYgIXNvdXJjZS5lbmRlZDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyByZWFkeSBmb3IgcGxheWluZy5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiByZWFkeS5cbiAgICovXG4gIF9pc1NvdXJjZVJlYWR5KCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgcmV0dXJuIHNvdXJjZS5yZWFkeVN0YXRlID4gMjtcbiAgfVxuICAvKiogUnVucyB0aGUgdXBkYXRlIGxvb3Agd2hlbiB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheS4gKi9cbiAgX29uUGxheVN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICB0aGlzLl9tZWRpYVJlYWR5KCk7XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgfVxuICAvKiogU3RvcHMgdGhlIHVwZGF0ZSBsb29wIHdoZW4gYSBwYXVzZSBldmVudCBpcyB0cmlnZ2VyZWQuICovXG4gIF9vblBsYXlTdG9wKCkge1xuICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgfVxuICAvKiogSGFuZGxlcyBiZWhhdmlvciB3aGVuIHRoZSB2aWRlbyBjb21wbGV0ZXMgc2Vla2luZyB0byB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbi4gKi9cbiAgX29uU2Vla2VkKCkge1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgdGhpcy51cGRhdGVGcmFtZSgpO1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgIH1cbiAgfVxuICBfb25DYW5QbGF5KCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgdGhpcy5fbWVkaWFSZWFkeSgpO1xuICB9XG4gIF9vbkNhblBsYXlUaHJvdWdoKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgIGlmICh0aGlzLl9wcmVsb2FkVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByZWxvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3ByZWxvYWRUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLl9tZWRpYVJlYWR5KCk7XG4gIH1cbiAgLyoqIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gcGxheS4gKi9cbiAgX21lZGlhUmVhZHkoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yZXNvdXJjZTtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoc291cmNlLnZpZGVvV2lkdGgsIHNvdXJjZS52aWRlb0hlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lKCk7XG4gICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgIGlmICh0aGlzLl9yZXNvbHZlKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlKHRoaXMpO1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZWplY3QgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9QbGF5KSB7XG4gICAgICB2b2lkIHRoaXMucmVzb3VyY2UucGxheSgpO1xuICAgIH1cbiAgfVxuICAvKiogQ2xlYW5zIHVwIHJlc291cmNlcyBhbmQgZXZlbnQgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRleHR1cmUuICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIHRoaXMuX29uUGxheVN0YXJ0KTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgdGhpcy5fb25QbGF5U3RvcCk7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCB0aGlzLl9vblNlZWtlZCk7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fb25DYW5QbGF5VGhyb3VnaCk7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICBzb3VyY2Uuc3JjID0gXCJcIjtcbiAgICAgIHNvdXJjZS5sb2FkKCk7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICAvKiogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0LiAqL1xuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fY29uZmlndXJlQXV0b1VwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSG93IG1hbnkgdGltZXMgYSBzZWNvbmQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIHZpZGVvLlxuICAgKiBMZWF2ZSBhdCAwIHRvIHVwZGF0ZSBhdCBldmVyeSByZW5kZXIuXG4gICAqIEEgbG93ZXIgZnBzIGNhbiBoZWxwIHBlcmZvcm1hbmNlLCBhcyB1cGRhdGluZyB0aGUgdGV4dHVyZSBhdCA2MGZwcyBvbiBhIDMwcHMgdmlkZW8gbWF5IG5vdCBiZSBlZmZpY2llbnQuXG4gICAqL1xuICBnZXQgdXBkYXRlRlBTKCkge1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVGUFM7XG4gIH1cbiAgc2V0IHVwZGF0ZUZQUyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdXBkYXRlRlBTKSB7XG4gICAgICB0aGlzLl91cGRhdGVGUFMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2NvbmZpZ3VyZUF1dG9VcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIHVwZGF0aW5nIG1lY2hhbmlzbSBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgc2V0dGluZ3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRlY2lkZXMgYmV0d2VlbiB1c2luZyB0aGUgYnJvd3NlcidzIG5hdGl2ZSB2aWRlbyBmcmFtZSBjYWxsYmFjayBvciBhIGN1c3RvbSB0aWNrZXJcbiAgICogZm9yIHVwZGF0aW5nIHRoZSB2aWRlbyBmcmFtZS4gSXQgZW5zdXJlcyBvcHRpbWFsIHBlcmZvcm1hbmNlIGFuZCByZXNwb25zaXZlbmVzc1xuICAgKiBiYXNlZCBvbiB0aGUgdmlkZW8ncyBzdGF0ZSwgcGxheWJhY2sgc3RhdHVzLCBhbmQgdGhlIGRlc2lyZWQgZnJhbWVzLXBlci1zZWNvbmQgc2V0dGluZy5cbiAgICpcbiAgICogLSBJZiBgX2F1dG9VcGRhdGVgIGlzIGVuYWJsZWQgYW5kIHRoZSB2aWRlbyBzb3VyY2UgaXMgcGxheWluZzpcbiAgICogICAtIEl0IHdpbGwgcHJlZmVyIHRoZSBuYXRpdmUgdmlkZW8gZnJhbWUgY2FsbGJhY2sgaWYgYXZhaWxhYmxlIGFuZCBubyBzcGVjaWZpYyBGUFMgaXMgc2V0LlxuICAgKiAgIC0gT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSBhIGN1c3RvbSB0aWNrZXIgZm9yIG1hbnVhbCB1cGRhdGVzLlxuICAgKiAtIElmIGBfYXV0b1VwZGF0ZWAgaXMgZGlzYWJsZWQgb3IgdGhlIHZpZGVvIGlzbid0IHBsYXlpbmcsIGFueSBhY3RpdmUgdXBkYXRlIG1lY2hhbmlzbXMgYXJlIGhhbHRlZC5cbiAgICovXG4gIF9jb25maWd1cmVBdXRvVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZUZQUyAmJiB0aGlzLnNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSB0aGlzLnNvdXJjZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKFxuICAgICAgICAgICAgdGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl92aWRlb0ZyYW1lUmVxdWVzdENhbGxiYWNrSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zb3VyY2UuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUpO1xuICAgICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgICAgIFRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlRnJhbWUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNvdXJjZS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2sodGhpcy5fdmlkZW9GcmFtZVJlcXVlc3RDYWxsYmFja0hhbmRsZSk7XG4gICAgICAgIHRoaXMuX3ZpZGVvRnJhbWVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGVGcmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxWaWRlb0VsZW1lbnQgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8IGdsb2JhbFRoaXMuVmlkZW9GcmFtZSAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIFZpZGVvRnJhbWU7XG4gIH1cbn07XG5fVmlkZW9Tb3VyY2UuZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5UZXh0dXJlU291cmNlO1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHZpZGVvIHNvdXJjZXMuICovXG5fVmlkZW9Tb3VyY2UuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC4uLlRleHR1cmVTb3VyY2UuZGVmYXVsdE9wdGlvbnMsXG4gIC8qKiBJZiB0cnVlLCB0aGUgdmlkZW8gd2lsbCBzdGFydCBsb2FkaW5nIGltbWVkaWF0ZWx5LiAqL1xuICBhdXRvTG9hZDogdHJ1ZSxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIHN0YXJ0IHBsYXlpbmcgYXMgc29vbiBhcyBpdCBpcyBsb2FkZWQuICovXG4gIGF1dG9QbGF5OiB0cnVlLFxuICAvKiogVGhlIG51bWJlciBvZiB0aW1lcyBhIHNlY29uZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgZnJvbSB0aGUgdmlkZW8uIExlYXZlIGF0IDAgdG8gdXBkYXRlIGF0IGV2ZXJ5IHJlbmRlci4gKi9cbiAgdXBkYXRlRlBTOiAwLFxuICAvKiogSWYgdHJ1ZSwgdGhlIHZpZGVvIHdpbGwgYmUgbG9hZGVkIHdpdGggdGhlIGBjcm9zc29yaWdpbmAgYXR0cmlidXRlLiAqL1xuICBjcm9zc29yaWdpbjogdHJ1ZSxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIGxvb3Agd2hlbiBpdCBlbmRzLiAqL1xuICBsb29wOiBmYWxzZSxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIGJlIG11dGVkLiAqL1xuICBtdXRlZDogdHJ1ZSxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIHBsYXkgaW5saW5lLiAqL1xuICBwbGF5c2lubGluZTogdHJ1ZSxcbiAgLyoqIElmIHRydWUsIHRoZSB2aWRlbyB3aWxsIGJlIHByZWxvYWRlZC4gKi9cbiAgcHJlbG9hZDogZmFsc2Vcbn07XG4vKipcbiAqIE1hcCBvZiB2aWRlbyBNSU1FIHR5cGVzIHRoYXQgY2FuJ3QgYmUgZGlyZWN0bHkgZGVyaXZlZCBmcm9tIGZpbGUgZXh0ZW5zaW9ucy5cbiAqIEByZWFkb25seVxuICovXG5fVmlkZW9Tb3VyY2UuTUlNRV9UWVBFUyA9IHtcbiAgb2d2OiBcInZpZGVvL29nZ1wiLFxuICBtb3Y6IFwidmlkZW8vcXVpY2t0aW1lXCIsXG4gIG00djogXCJ2aWRlby9tcDRcIlxufTtcbmxldCBWaWRlb1NvdXJjZSA9IF9WaWRlb1NvdXJjZTtcblxuZXhwb3J0IHsgVmlkZW9Tb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvU291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEFscGhhTWFzayB9IGZyb20gJy4vbWFzay9hbHBoYS9BbHBoYU1hc2subWpzJztcbmltcG9ydCB7IENvbG9yTWFzayB9IGZyb20gJy4vbWFzay9jb2xvci9Db2xvck1hc2subWpzJztcbmltcG9ydCB7IFN0ZW5jaWxNYXNrIH0gZnJvbSAnLi9tYXNrL3N0ZW5jaWwvU3RlbmNpbE1hc2subWpzJztcbmltcG9ydCB7IEJ1ZmZlckltYWdlU291cmNlIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9CdWZmZXJTb3VyY2UubWpzJztcbmltcG9ydCB7IENhbnZhc1NvdXJjZSB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvQ2FudmFzU291cmNlLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVNvdXJjZSB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IFZpZGVvU291cmNlIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9WaWRlb1NvdXJjZS5tanMnO1xuaW1wb3J0ICcuL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanMnO1xuaW1wb3J0ICcuL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChBbHBoYU1hc2ssIENvbG9yTWFzaywgU3RlbmNpbE1hc2ssIFZpZGVvU291cmNlLCBJbWFnZVNvdXJjZSwgQ2FudmFzU291cmNlLCBCdWZmZXJJbWFnZVNvdXJjZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9846\n')},6582:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ CLEAR)\n/* harmony export */ });\n\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";\n  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";\n  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";\n  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";\n  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";\n  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";\n  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";\n  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";\n  return CLEAR2;\n})(CLEAR || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOztBQUVHO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9nbC9jb25zdC5tanM/NDRhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBDTEVBUiA9IC8qIEBfX1BVUkVfXyAqLyAoKENMRUFSMikgPT4ge1xuICBDTEVBUjJbQ0xFQVIyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIENMRUFSMltDTEVBUjJbXCJDT0xPUlwiXSA9IDE2Mzg0XSA9IFwiQ09MT1JcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIlNURU5DSUxcIl0gPSAxMDI0XSA9IFwiU1RFTkNJTFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiREVQVEhcIl0gPSAyNTZdID0gXCJERVBUSFwiO1xuICBDTEVBUjJbQ0xFQVIyW1wiQ09MT1JfREVQVEhcIl0gPSAxNjY0MF0gPSBcIkNPTE9SX0RFUFRIXCI7XG4gIENMRUFSMltDTEVBUjJbXCJDT0xPUl9TVEVOQ0lMXCJdID0gMTc0MDhdID0gXCJDT0xPUl9TVEVOQ0lMXCI7XG4gIENMRUFSMltDTEVBUjJbXCJERVBUSF9TVEVOQ0lMXCJdID0gMTI4MF0gPSBcIkRFUFRIX1NURU5DSUxcIjtcbiAgQ0xFQVIyW0NMRUFSMltcIkFMTFwiXSA9IDE3NjY0XSA9IFwiQUxMXCI7XG4gIHJldHVybiBDTEVBUjI7XG59KShDTEVBUiB8fCB7fSk7XG5cbmV4cG9ydCB7IENMRUFSIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6582\n')},9818:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ BindGroup)\n/* harmony export */ });\n\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join("|");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    resource.on?.("change", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to \'touch\' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.("change", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange() {\n    this._dirty = true;\n    this._updateKey();\n  }\n}\n\n\n//# sourceMappingURL=BindGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanM/MTE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJpbmRHcm91cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UgZW9mIHRoZSBCaW5kIEdyb3VwLlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIC0gVGhlIHJlc291cmNlcyB0aGF0IGFyZSBib3VuZCB0b2dldGhlciBmb3IgdXNlIGJ5IGEgc2hhZGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzb3VyY2VzKSB7XG4gICAgLyoqIFRoZSByZXNvdXJjZXMgdGhhdCBhcmUgYm91bmQgdG9nZXRoZXIgZm9yIHVzZSBieSBhIHNoYWRlci4gKi9cbiAgICB0aGlzLnJlc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgrKyk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUtleSgpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBrZXkgaWYgaXRzIGZsYWdnZWQgYXMgZGlydHkuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvXG4gICAqIG1hdGNoIHRoaXMgYmluZCBncm91cCB0byBhIFdlYkdQVSBCaW5kR3JvdXAuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdXBkYXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fZGlydHkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICBjb25zdCBrZXlQYXJ0cyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICBrZXlQYXJ0c1tpbmRleCsrXSA9IHRoaXMucmVzb3VyY2VzW2ldLl9yZXNvdXJjZUlkO1xuICAgIH1cbiAgICB0aGlzLl9rZXkgPSBrZXlQYXJ0cy5qb2luKFwifFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgcmVzb3VyY2UgYXQgYSBnaXZlbiBpbmRleC4gdGhpcyBmdW5jdGlvbiB3aWxsXG4gICAqIGVuc3VyZSB0aGF0IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3VycmVudCByZXNvdXJjZVxuICAgKiBhbmQgYWRkZWQgdG8gdGhlIG5ldyByZXNvdXJjZS5cbiAgICogQHBhcmFtIHJlc291cmNlIC0gVGhlIHJlc291cmNlIHRvIHNldC5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHNldCB0aGUgcmVzb3VyY2UgYXQuXG4gICAqL1xuICBzZXRSZXNvdXJjZShyZXNvdXJjZSwgaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50UmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1tpbmRleF07XG4gICAgaWYgKHJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGN1cnJlbnRSZXNvdXJjZSkge1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgcmVzb3VyY2Uub24/LihcImNoYW5nZVwiLCB0aGlzLm9uUmVzb3VyY2VDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMucmVzb3VyY2VzW2luZGV4XSA9IHJlc291cmNlO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb3VyY2UgYXQgdGhlIGN1cnJlbnQgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJlc291cmNlIHRvIGdldC5cbiAgICogQHJldHVybnMgLSBUaGUgcmVzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICovXG4gIGdldFJlc291cmNlKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzW2luZGV4XTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbnRlcm5hbGx5IHRvICd0b3VjaCcgZWFjaCByZXNvdXJjZSwgdG8gZW5zdXJlIHRoYXQgdGhlIEdDXG4gICAqIGtub3dzIHRoYXQgYWxsIHJlc291cmNlcyBpbiB0aGlzIGJpbmQgZ3JvdXAgYXJlIHN0aWxsIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSB0aWNrIC0gVGhlIGN1cnJlbnQgdGljay5cbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF90b3VjaCh0aWNrKSB7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5yZXNvdXJjZXM7XG4gICAgZm9yIChjb25zdCBpIGluIHJlc291cmNlcykge1xuICAgICAgcmVzb3VyY2VzW2ldLl90b3VjaGVkID0gdGljaztcbiAgICB9XG4gIH1cbiAgLyoqIERlc3Ryb3lzIHRoaXMgYmluZCBncm91cCBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMucmVzb3VyY2VzO1xuICAgIGZvciAoY29uc3QgaSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2ldO1xuICAgICAgcmVzb3VyY2Uub2ZmPy4oXCJjaGFuZ2VcIiwgdGhpcy5vblJlc291cmNlQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvdXJjZXMgPSBudWxsO1xuICB9XG4gIG9uUmVzb3VyY2VDaGFuZ2UoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZUtleSgpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJpbmRHcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluZEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9818\n')},7494:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ Buffer)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6258);\n/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5324);\n\n\n\n\n"use strict";\nclass Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("buffer");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = "buffer";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    } else {\n      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__/* .BufferUsage */ .F.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit("update", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit("update", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__/* .uid */ .h)("resource");\n        this.emit("change", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit("update", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit("update", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.emit("destroy", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFDWTtBQUNYOztBQUUxQztBQUNBLHFCQUFxQiw4REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNERBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFXO0FBQzFDLE1BQU07QUFDTixnQ0FBZ0MsNERBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDJCQUEyQixpRUFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2J1ZmZlci9CdWZmZXIubWpzPzAwOTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyBCdWZmZXJVc2FnZSB9IGZyb20gJy4vY29uc3QubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCdWZmZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCdWZmZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIGZvciB0aGUgYnVmZmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHsgZGF0YSwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHVzYWdlLCBsYWJlbCwgc2hyaW5rVG9GaXQgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBlbWl0cyB3aGVuIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgY2hhbmdlZCBzaGFwZSAoaS5lLiByZXNpemVkKVxuICAgICAqIGxldHRpbmcgdGhlIHJlbmRlcmVyIGtub3cgdGhhdCBpdCBuZWVkcyB0byBkaXNjYXJkIHRoZSBvbGQgYnVmZmVyIG9uIHRoZSBHUFUgYW5kIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogZW1pdHMgd2hlbiB0aGUgdW5kZXJseWluZyBidWZmZXIgZGF0YSBoYXMgYmVlbiB1cGRhdGVkLiBsZXR0aW5nIHRoZSByZW5kZXJlciBrbm93XG4gICAgICogdGhhdCBpdCBuZWVkcyB0byB1cGRhdGUgdGhlIGJ1ZmZlciBvbiB0aGUgR1BVXG4gICAgICogQGV2ZW50IHVwZGF0ZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGVtaXRzIHdoZW4gdGhlIGJ1ZmZlciBpcyBkZXN0cm95ZWQuIGxldHRpbmcgdGhlIHJlbmRlcmVyIGtub3cgdGhhdCBpdCBuZWVkcyB0byBkZXN0cm95IHRoZSBidWZmZXIgb24gdGhlIEdQVVxuICAgICAqIEBldmVudCBkZXN0cm95XG4gICAgICovXG4gICAgLyoqXG4gICAgICogYSB1bmlxdWUgaWQgZm9yIHRoaXMgdW5pZm9ybSBncm91cCB1c2VkIHRocm91Z2ggdGhlIHJlbmRlcmVyXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiYnVmZmVyXCIpO1xuICAgIC8qKlxuICAgICAqIGEgcmVzb3VyY2UgdHlwZSwgdXNlZCB0byBpZGVudGlmeSBob3cgdG8gaGFuZGxlIGl0IHdoZW4gaXRzIGluIGEgYmluZCBncm91cCAvIHNoYWRlciByZXNvdXJjZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZVR5cGUgPSBcImJ1ZmZlclwiO1xuICAgIC8qKlxuICAgICAqIHRoZSByZXNvdXJjZSBpZCB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGJ1aWxkIGJpbmQgZ3JvdXAga2V5c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvdXJjZUlkID0gdWlkKFwicmVzb3VyY2VcIik7XG4gICAgLyoqXG4gICAgICogdXNlZCBpbnRlcm5hbGx5IHRvIGtub3cgaWYgYSB1bmlmb3JtIGdyb3VwIHdhcyB1c2VkIGluIHRoZSBsYXN0IHJlbmRlciBwYXNzXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVJRCA9IDE7XG4gICAgLyoqXG4gICAgICogc2hvdWxkIHRoZSBHUFUgYnVmZmVyIGJlIHNocnVuayB3aGVuIHRoZSBkYXRhIGJlY29tZXMgc21hbGxlcj9cbiAgICAgKiBjaGFuZ2luZyB0aGlzIHdpbGwgY2F1c2UgdGhlIGJ1ZmZlciB0byBiZSBkZXN0cm95ZWQgYW5kIGEgbmV3IG9uZSBjcmVhdGVkIG9uIHRoZSBHUFVcbiAgICAgKiB0aGlzIGNhbiBiZSBleHBlbnNpdmUsIGVzcGVjaWFsbHkgaWYgdGhlIGJ1ZmZlciBpcyBhbHJlYWR5IGJpZyBlbm91Z2ghXG4gICAgICogc2V0dGluZyB0aGlzIHRvIGZhbHNlIHdpbGwgcHJldmVudCB0aGUgYnVmZmVyIGZyb20gYmVpbmcgc2hydW5rLiBUaGlzIHdpbGwgeWllbGQgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICogaWYgeW91IGFyZSBjb25zdGFudGx5IHNldHRpbmcgZGF0YSB0aGF0IGlzIGNoYW5naW5nIHNpemUgb2Z0ZW4uXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc2hyaW5rVG9GaXQgPSB0cnVlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICBzaXplID0gc2l6ZSA/PyBkYXRhPy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IG1hcHBlZEF0Q3JlYXRpb24gPSAhIWRhdGE7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0ge1xuICAgICAgc2l6ZSxcbiAgICAgIHVzYWdlLFxuICAgICAgbWFwcGVkQXRDcmVhdGlvbixcbiAgICAgIGxhYmVsXG4gICAgfTtcbiAgICB0aGlzLnNocmlua1RvRml0ID0gc2hyaW5rVG9GaXQgPz8gdHJ1ZTtcbiAgfVxuICAvKiogdGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0RGF0YVdpdGhTaXplKHZhbHVlLCB2YWx1ZS5sZW5ndGgsIHRydWUpO1xuICB9XG4gIC8qKiB3aGV0aGVyIHRoZSBidWZmZXIgaXMgc3RhdGljIG9yIG5vdCAqL1xuICBnZXQgc3RhdGljKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRlc2NyaXB0b3IudXNhZ2UgJiBCdWZmZXJVc2FnZS5TVEFUSUMpO1xuICB9XG4gIHNldCBzdGF0aWModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSB8PSBCdWZmZXJVc2FnZS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRvci51c2FnZSAmPSB+QnVmZmVyVXNhZ2UuU1RBVElDO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGF0YSBpbiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgYnVmZmVyIG9uIHRoZSBHUFUuXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgZGF0YS5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIGRhdGEgdG8gc2V0XG4gICAqIEBwYXJhbSBzaXplIC0gdGhlIHNpemUgb2YgdGhlIGRhdGEgaW4gYnl0ZXNcbiAgICogQHBhcmFtIHN5bmNHUFUgLSBzaG91bGQgdGhlIGJ1ZmZlciBiZSB1cGRhdGVkIG9uIHRoZSBHUFUgaW1tZWRpYXRlbHk/XG4gICAqL1xuICBzZXREYXRhV2l0aFNpemUodmFsdWUsIHNpemUsIHN5bmNHUFUpIHtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplICogdmFsdWUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgaWYgKHRoaXMuX2RhdGEgPT09IHZhbHVlKSB7XG4gICAgICBpZiAoc3luY0dQVSlcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XG4gICAgaWYgKG9sZERhdGEubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5zaHJpbmtUb0ZpdCAmJiB2YWx1ZS5ieXRlTGVuZ3RoIDwgb2xkRGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzeW5jR1BVKVxuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRvci5zaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzeW5jR1BVKVxuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiB1cGRhdGVzIHRoZSBidWZmZXIgb24gdGhlIEdQVSB0byByZWZsZWN0IHRoZSBkYXRhIGluIHRoZSBidWZmZXIuXG4gICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCB1cGRhdGUgdGhlIGVudGlyZSBidWZmZXIuIElmIHlvdSBvbmx5IHdhbnQgdG8gdXBkYXRlIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIsXG4gICAqIHlvdSBjYW4gcGFzcyBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHNpemVJbkJ5dGVzIC0gdGhlIG5ldyBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXNcbiAgICovXG4gIHVwZGF0ZShzaXplSW5CeXRlcykge1xuICAgIHRoaXMuX3VwZGF0ZVNpemUgPSBzaXplSW5CeXRlcyA/PyB0aGlzLl91cGRhdGVTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICB9XG4gIC8qKiBEZXN0cm95cyB0aGUgYnVmZmVyICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7494\n')},5324:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ BufferUsage)\n/* harmony export */ });\n\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";\n  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";\n  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";\n  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";\n  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";\n  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";\n  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";\n  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";\n  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";\n  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";\n  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";\n  return BufferUsage2;\n})(BufferUsage || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7O0FBRUc7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzPzkwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQnVmZmVyVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChCdWZmZXJVc2FnZTIpID0+IHtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIk1BUF9SRUFEXCJdID0gMV0gPSBcIk1BUF9SRUFEXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJNQVBfV1JJVEVcIl0gPSAyXSA9IFwiTUFQX1dSSVRFXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJDT1BZX1NSQ1wiXSA9IDRdID0gXCJDT1BZX1NSQ1wiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiQ09QWV9EU1RcIl0gPSA4XSA9IFwiQ09QWV9EU1RcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIklOREVYXCJdID0gMTZdID0gXCJJTkRFWFwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiVkVSVEVYXCJdID0gMzJdID0gXCJWRVJURVhcIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlVOSUZPUk1cIl0gPSA2NF0gPSBcIlVOSUZPUk1cIjtcbiAgQnVmZmVyVXNhZ2UyW0J1ZmZlclVzYWdlMltcIlNUT1JBR0VcIl0gPSAxMjhdID0gXCJTVE9SQUdFXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJJTkRJUkVDVFwiXSA9IDI1Nl0gPSBcIklORElSRUNUXCI7XG4gIEJ1ZmZlclVzYWdlMltCdWZmZXJVc2FnZTJbXCJRVUVSWV9SRVNPTFZFXCJdID0gNTEyXSA9IFwiUVVFUllfUkVTT0xWRVwiO1xuICBCdWZmZXJVc2FnZTJbQnVmZmVyVXNhZ2UyW1wiU1RBVElDXCJdID0gMTAyNF0gPSBcIlNUQVRJQ1wiO1xuICByZXR1cm4gQnVmZmVyVXNhZ2UyO1xufSkoQnVmZmVyVXNhZ2UgfHwge30pO1xuXG5leHBvcnQgeyBCdWZmZXJVc2FnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5324\n')},6633:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ fastCopy)\n/* harmony export */ });\n\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\n\n//# sourceMappingURL=fastCopy.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvdXRpbHMvZmFzdENvcHkubWpzPzg5YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBmYXN0Q29weShzb3VyY2VCdWZmZXIsIGRlc3RpbmF0aW9uQnVmZmVyKSB7XG4gIGNvbnN0IGxlbmd0aERvdWJsZSA9IHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoIC8gOCB8IDA7XG4gIGNvbnN0IHNvdXJjZUZsb2F0NjRWaWV3ID0gbmV3IEZsb2F0NjRBcnJheShzb3VyY2VCdWZmZXIsIDAsIGxlbmd0aERvdWJsZSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uRmxvYXQ2NFZpZXcgPSBuZXcgRmxvYXQ2NEFycmF5KGRlc3RpbmF0aW9uQnVmZmVyLCAwLCBsZW5ndGhEb3VibGUpO1xuICBkZXN0aW5hdGlvbkZsb2F0NjRWaWV3LnNldChzb3VyY2VGbG9hdDY0Vmlldyk7XG4gIGNvbnN0IHJlbWFpbmluZ0J5dGVzID0gc291cmNlQnVmZmVyLmJ5dGVMZW5ndGggLSBsZW5ndGhEb3VibGUgKiA4O1xuICBpZiAocmVtYWluaW5nQnl0ZXMgPiAwKSB7XG4gICAgY29uc3Qgc291cmNlVWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlQnVmZmVyLCBsZW5ndGhEb3VibGUgKiA4LCByZW1haW5pbmdCeXRlcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25VaW50OFZpZXcgPSBuZXcgVWludDhBcnJheShkZXN0aW5hdGlvbkJ1ZmZlciwgbGVuZ3RoRG91YmxlICogOCwgcmVtYWluaW5nQnl0ZXMpO1xuICAgIGRlc3RpbmF0aW9uVWludDhWaWV3LnNldChzb3VyY2VVaW50OFZpZXcpO1xuICB9XG59XG5cbmV4cG9ydCB7IGZhc3RDb3B5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYXN0Q29weS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6633\n")},1980:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: () => (/* binding */ Geometry)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs\nvar Buffer = __webpack_require__(7494);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs\nvar buffer_const = __webpack_require__(5324);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs\n\n\n\n"use strict";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer/* Buffer */.l)) {\n    let usage = index ? buffer_const/* BufferUsage */.F.INDEX : buffer_const/* BufferUsage */.F.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.INDEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = buffer_const/* BufferUsage */.F.VERTEX | buffer_const/* BufferUsage */.F.COPY_DST;\n      }\n    }\n    buffer = new Buffer/* Buffer */.l({\n      data: buffer,\n      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",\n      usage\n    });\n  }\n  return buffer;\n}\n\n\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs\n\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getGeometryBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs\n\n\n\n\n\n\n\n"use strict";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer/* Buffer */.l || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends eventemitter3/* default */.Z {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = (0,uid/* uid */.h)("geometry");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on("update", this.onBufferUpdate, this);\n        attribute.buffer.on("change", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || "triangle-list";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit("update", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, "aPosition", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNJOztBQUVyRDtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFNO0FBQ2hDLHdCQUF3QiwrQkFBVyxTQUFTLCtCQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBVyxTQUFTLCtCQUFXO0FBQy9DLFFBQVE7QUFDUjtBQUNBLGdCQUFnQiwrQkFBVyxVQUFVLCtCQUFXO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzFCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUN0Q3lDO0FBQzhCO0FBQ2xCO0FBQ1A7QUFDYztBQUNNOztBQUVsRTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2Vuc3VyZUlzQnVmZmVyLm1qcz9iZWY4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcz9kYTEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcz8wMTNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uLy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IEJ1ZmZlclVzYWdlIH0gZnJvbSAnLi4vLi4vYnVmZmVyL2NvbnN0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgbGV0IHVzYWdlID0gaW5kZXggPyBCdWZmZXJVc2FnZS5JTkRFWCA6IEJ1ZmZlclVzYWdlLlZFUlRFWDtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdXNhZ2UgPSBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICB1c2FnZSA9IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIGxhYmVsOiBpbmRleCA/IFwiaW5kZXgtbWVzaC1idWZmZXJcIiA6IFwidmVydGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICB1c2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmV4cG9ydCB7IGVuc3VyZUlzQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnN1cmVJc0J1ZmZlci5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldEdlb21ldHJ5Qm91bmRzKGdlb21ldHJ5LCBhdHRyaWJ1dGVJZCwgYm91bmRzKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVJZCk7XG4gIGlmICghYXR0cmlidXRlKSB7XG4gICAgYm91bmRzLm1pblggPSAwO1xuICAgIGJvdW5kcy5taW5ZID0gMDtcbiAgICBib3VuZHMubWF4WCA9IDA7XG4gICAgYm91bmRzLm1heFkgPSAwO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGF0dHJpYnV0ZS5idWZmZXIuZGF0YTtcbiAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gIGxldCBtYXhZID0gLUluZmluaXR5O1xuICBjb25zdCBieXRlU2l6ZSA9IGRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IG9mZnNldCA9IChhdHRyaWJ1dGUub2Zmc2V0IHx8IDApIC8gYnl0ZVNpemU7XG4gIGNvbnN0IHN0cmlkZSA9IChhdHRyaWJ1dGUuc3RyaWRlIHx8IDIgKiA0KSAvIGJ5dGVTaXplO1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICB9XG4gIGJvdW5kcy5taW5YID0gbWluWDtcbiAgYm91bmRzLm1pblkgPSBtaW5ZO1xuICBib3VuZHMubWF4WCA9IG1heFg7XG4gIGJvdW5kcy5tYXhZID0gbWF4WTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZXhwb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdlb21ldHJ5Qm91bmRzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2J1ZmZlci9CdWZmZXIubWpzJztcbmltcG9ydCB7IGVuc3VyZUlzQnVmZmVyIH0gZnJvbSAnLi91dGlscy9lbnN1cmVJc0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgZ2V0R2VvbWV0cnlCb3VuZHMgfSBmcm9tICcuL3V0aWxzL2dldEdlb21ldHJ5Qm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW5zdXJlSXNBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBCdWZmZXIgfHwgQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpIHx8IGF0dHJpYnV0ZS5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgIGJ1ZmZlcjogYXR0cmlidXRlXG4gICAgfTtcbiAgfVxuICBhdHRyaWJ1dGUuYnVmZmVyID0gZW5zdXJlSXNCdWZmZXIoYXR0cmlidXRlLmJ1ZmZlciwgZmFsc2UpO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuY2xhc3MgR2VvbWV0cnkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgZ2VvbWV0cnlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGdlb21ldHJ5LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgaW5kZXhCdWZmZXIsIHRvcG9sb2d5IH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWQgb2YgdGhlIGdlb21ldHJ5LiAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiZ2VvbWV0cnlcIik7XG4gICAgLyoqXG4gICAgICogdGhlIGxheW91dCBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgV2ViR1BVIGFsbCBnZW9tZXRyaWVzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmVcbiAgICAgKiB3aWxsIGhhdmUgdGhlIHNhbWUgbGF5b3V0IGtleS4gVGhpcyBpcyB1c2VkIHRvIGNhY2hlIHRoZSBwaXBlbGluZSBsYXlvdXRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fbGF5b3V0S2V5ID0gMDtcbiAgICAvKiogdGhlIGluc3RhbmNlIGNvdW50IG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3ICovXG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gb3B0aW9ucy5pbnN0YW5jZUNvdW50IHx8IDE7XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV0gPSBlbnN1cmVJc0F0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldKTtcbiAgICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYXR0cmlidXRlLmJ1ZmZlcik7XG4gICAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGF0dHJpYnV0ZS5idWZmZXIpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwidXBkYXRlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgICBhdHRyaWJ1dGUuYnVmZmVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25CdWZmZXJVcGRhdGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXhCdWZmZXIpIHtcbiAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBlbnN1cmVJc0J1ZmZlcihpbmRleEJ1ZmZlciwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy50b3BvbG9neSA9IHRvcG9sb2d5IHx8IFwidHJpYW5nbGUtbGlzdFwiO1xuICB9XG4gIG9uQnVmZmVyVXBkYXRlKCkge1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHJldHVybnMgLSBUaGUgYXR0cmlidXRlIHJlcXVlc3RlZC5cbiAgICovXG4gIGdldEF0dHJpYnV0ZShpZCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICogQHJldHVybnMgLSBUaGUgaW5kZXggYnVmZmVyLlxuICAgKi9cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCBidWZmZXIuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBuYW1lIG9mIHRoZSBidWZmZXIgcmVxdWlyZWQuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJ1ZmZlciByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXRCdWZmZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoaWQpLmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IGhvdyBtYW55IHZlcnRpY2VzIHRoZXJlIGFyZSBpbiB0aGlzIGdlb21ldHJ5XG4gICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdlb21ldHJ5XG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG4gICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgZ2VvbWV0cnkuICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKCF0aGlzLl9ib3VuZHNEaXJ0eSlcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICByZXR1cm4gZ2V0R2VvbWV0cnlCb3VuZHModGhpcywgXCJhUG9zaXRpb25cIiwgdGhpcy5fYm91bmRzKTtcbiAgfVxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0gZGVzdHJveUJ1ZmZlcnMgLSBkZXN0cm95IHRoZSBidWZmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGdlb21ldHJ5XG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCdWZmZXJzID0gZmFsc2UpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKGRlc3Ryb3lCdWZmZXJzKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiBidWZmZXIuZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1980\n')},1854:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ InstructionSet)\n/* harmony export */ });\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n"use strict";\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("instructionSet");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, ["type", "action"]);\n  }\n}\n\n\n//# sourceMappingURL=InstructionSet.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzP2QxODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZGF0YS91aWQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBJbnN0cnVjdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBhIHVuaXF1ZSBpZCBmb3IgdGhpcyBpbnN0cnVjdGlvbiBzZXQgdXNlZCB0aHJvdWdoIHRoZSByZW5kZXJlciAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwiaW5zdHJ1Y3Rpb25TZXRcIik7XG4gICAgLyoqIHRoZSBhcnJheSBvZiBpbnN0cnVjdGlvbnMgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKiB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGFycmF5IChhbnkgaW5zdHJ1Y3Rpb25zIHBhc3NlZCB0aGlzIHNob3VsZCBiZSBpZ25vcmVkKSAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25TaXplID0gMDtcbiAgfVxuICAvKiogcmVzZXQgdGhlIGluc3RydWN0aW9uIHNldCBzbyBpdCBjYW4gYmUgcmV1c2VkIHNldCBzaXplIGJhY2sgdG8gMCAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uU2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbiAtIGFkZCBhbiBpbnN0cnVjdGlvbiB0byB0aGUgc2V0XG4gICAqL1xuICBhZGQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9uU2l6ZSsrXSA9IGluc3RydWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBMb2cgdGhlIGluc3RydWN0aW9ucyB0byB0aGUgY29uc29sZSAoZm9yIGRlYnVnZ2luZylcbiAgICogQGludGVybmFsXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGxvZygpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLmluc3RydWN0aW9uU2l6ZTtcbiAgICBjb25zb2xlLnRhYmxlKHRoaXMuaW5zdHJ1Y3Rpb25zLCBbXCJ0eXBlXCIsIFwiYWN0aW9uXCJdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbnN0cnVjdGlvblNldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5zdHJ1Y3Rpb25TZXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1854\n')},2475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ STENCIL_MODES),\n/* harmony export */   f: () => (/* binding */ BLEND_TO_NPM)\n/* harmony export */ });\n\nconst BLEND_TO_NPM = {\n  normal: "normal-npm",\n  add: "add-npm",\n  screen: "screen-npm"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";\n  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";\n  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";\n  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFaUI7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9jb25zdC5tanM/MTk2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEJMRU5EX1RPX05QTSA9IHtcbiAgbm9ybWFsOiBcIm5vcm1hbC1ucG1cIixcbiAgYWRkOiBcImFkZC1ucG1cIixcbiAgc2NyZWVuOiBcInNjcmVlbi1ucG1cIlxufTtcbnZhciBTVEVOQ0lMX01PREVTID0gLyogQF9fUFVSRV9fICovICgoU1RFTkNJTF9NT0RFUzIpID0+IHtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJESVNBQkxFRFwiXSA9IDBdID0gXCJESVNBQkxFRFwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIlJFTkRFUklOR19NQVNLX0FERFwiXSA9IDFdID0gXCJSRU5ERVJJTkdfTUFTS19BRERcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJNQVNLX0FDVElWRVwiXSA9IDJdID0gXCJNQVNLX0FDVElWRVwiO1xuICBTVEVOQ0lMX01PREVTMltTVEVOQ0lMX01PREVTMltcIlJFTkRFUklOR19NQVNLX1JFTU9WRVwiXSA9IDNdID0gXCJSRU5ERVJJTkdfTUFTS19SRU1PVkVcIjtcbiAgU1RFTkNJTF9NT0RFUzJbU1RFTkNJTF9NT0RFUzJbXCJOT05FXCJdID0gNF0gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIFNURU5DSUxfTU9ERVMyO1xufSkoU1RFTkNJTF9NT0RFUyB8fCB7fSk7XG5cbmV4cG9ydCB7IEJMRU5EX1RPX05QTSwgU1RFTkNJTF9NT0RFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2475\n')},7199:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ AbstractRenderer)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8409);\n/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8400);\n/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1013);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _gl_const_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6582);\n/* harmony import */ var _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7051);\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1580);\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultRunners = [\n  "init",\n  "destroy",\n  "contextChange",\n  "resolutionChange",\n  "reset",\n  "renderEnd",\n  "renderStart",\n  "render",\n  "update",\n  "postrender",\n  "prerender"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    const combinedRunners = [...defaultRunners, ...config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._addSystems(config.systems);\n    this._addPipes(config.renderPipes, config.renderPipeAdaptors);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Container */ .W2) {\n      options = { container: options };\n      if (deprecated) {\n        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "passing a second argument is deprecated, please use render options instead");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit("resize", this.view.screen.width, this.view.screen.height);\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = _gl_const_mjs__WEBPACK_IMPORTED_MODULE_4__/* .CLEAR */ .E.ALL);\n    const { clear, clearColor, target } = options;\n    _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Color */ .I.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_5__/* .SystemRunner */ .P(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn\'t collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overrideable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn\'t support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_6__/* .unsafeEvalSupported */ .O)()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\n\n//# sourceMappingURL=AbstractRenderer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE5OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9EO0FBQ2tCO0FBQ2tCO0FBQ1I7QUFDM0M7QUFDTTtBQUNPO0FBQ1Q7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOERBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrRUFBUztBQUNwQyxrQkFBa0I7QUFDbEI7QUFDQSxRQUFRLG9GQUFXLENBQUMsMkVBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNERBQUs7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5REFBSztBQUMzQyxZQUFZLDRCQUE0QjtBQUN4QyxJQUFJLDREQUFLO0FBQ1QsK0NBQStDLDREQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0VBQVk7QUFDL0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0dBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL0Fic3RyYWN0UmVuZGVyZXIubWpzPzcyMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2NlbmUvY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2Jyb3dzZXIvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vdXRpbHMvdXRpbHMubWpzJztcbmltcG9ydCB7IENMRUFSIH0gZnJvbSAnLi4vLi4vZ2wvY29uc3QubWpzJztcbmltcG9ydCB7IFN5c3RlbVJ1bm5lciB9IGZyb20gJy4vU3lzdGVtUnVubmVyLm1qcyc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGRlZmF1bHRSdW5uZXJzID0gW1xuICBcImluaXRcIixcbiAgXCJkZXN0cm95XCIsXG4gIFwiY29udGV4dENoYW5nZVwiLFxuICBcInJlc29sdXRpb25DaGFuZ2VcIixcbiAgXCJyZXNldFwiLFxuICBcInJlbmRlckVuZFwiLFxuICBcInJlbmRlclN0YXJ0XCIsXG4gIFwicmVuZGVyXCIsXG4gIFwidXBkYXRlXCIsXG4gIFwicG9zdHJlbmRlclwiLFxuICBcInByZXJlbmRlclwiXG5dO1xuY29uc3QgX0Fic3RyYWN0UmVuZGVyZXIgPSBjbGFzcyBfQWJzdHJhY3RSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBTZXQgdXAgYSBzeXN0ZW0gd2l0aCBhIGNvbGxlY3Rpb24gb2YgU3lzdGVtQ2xhc3NlcyBhbmQgcnVubmVycy5cbiAgICogU3lzdGVtcyBhcmUgYXR0YWNoZWQgZHluYW1pY2FsbHkgdG8gdGhpcyBjbGFzcyB3aGVuIGFkZGVkLlxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGNvbmZpZyBmb3IgdGhlIHN5c3RlbSBtYW5hZ2VyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucnVubmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucmVuZGVyUGlwZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9pbml0T3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50eXBlID0gY29uZmlnLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgY29uc3QgY29tYmluZWRSdW5uZXJzID0gWy4uLmRlZmF1bHRSdW5uZXJzLCAuLi5jb25maWcucnVubmVycyA/PyBbXV07XG4gICAgdGhpcy5fYWRkUnVubmVycyguLi5jb21iaW5lZFJ1bm5lcnMpO1xuICAgIHRoaXMuX2FkZFN5c3RlbXMoY29uZmlnLnN5c3RlbXMpO1xuICAgIHRoaXMuX2FkZFBpcGVzKGNvbmZpZy5yZW5kZXJQaXBlcywgY29uZmlnLnJlbmRlclBpcGVBZGFwdG9ycyk7XG4gICAgdGhpcy5fdW5zYWZlRXZhbENoZWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVzZSB0byBjcmVhdGUgdGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IHN5c3RlbU5hbWUgaW4gdGhpcy5fc3lzdGVtc0hhc2gpIHtcbiAgICAgIGNvbnN0IHN5c3RlbSA9IHRoaXMuX3N5c3RlbXNIYXNoW3N5c3RlbU5hbWVdO1xuICAgICAgY29uc3QgZGVmYXVsdFN5c3RlbU9wdGlvbnMgPSBzeXN0ZW0uY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnM7XG4gICAgICBvcHRpb25zID0geyAuLi5kZWZhdWx0U3lzdGVtT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi5fQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gb3B0aW9ucy5yb3VuZFBpeGVscyA/IDEgOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uZXJzLmluaXQuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF3YWl0IHRoaXMucnVubmVycy5pbml0Lml0ZW1zW2ldLmluaXQob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICByZW5kZXIoYXJncywgZGVwcmVjYXRlZCkge1xuICAgIGxldCBvcHRpb25zID0gYXJncztcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGFpbmVyOiBvcHRpb25zIH07XG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwicGFzc2luZyBhIHNlY29uZCBhcmd1bWVudCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlbmRlciBvcHRpb25zIGluc3RlYWRcIik7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gZGVwcmVjYXRlZC5yZW5kZXJUZXh0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLnRhcmdldCB8fCAob3B0aW9ucy50YXJnZXQgPSB0aGlzLnZpZXcucmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQgPT09IHRoaXMudmlldy5yZW5kZXJUYXJnZXQpIHtcbiAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgb3B0aW9ucy5jbGVhckNvbG9yID0gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yUmdiYTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2xlYXJDb2xvcikge1xuICAgICAgY29uc3QgaXNSR0JBQXJyYXkgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2xlYXJDb2xvcikgJiYgb3B0aW9ucy5jbGVhckNvbG9yLmxlbmd0aCA9PT0gNDtcbiAgICAgIG9wdGlvbnMuY2xlYXJDb2xvciA9IGlzUkdCQUFycmF5ID8gb3B0aW9ucy5jbGVhckNvbG9yIDogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY2xlYXJDb2xvcikudG9BcnJheSgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJhbnNmb3JtKSB7XG4gICAgICBvcHRpb25zLmNvbnRhaW5lci51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgb3B0aW9ucy50cmFuc2Zvcm0gPSBvcHRpb25zLmNvbnRhaW5lci5sb2NhbFRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5ydW5uZXJzLnByZXJlbmRlci5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXJTdGFydC5lbWl0KG9wdGlvbnMpO1xuICAgIHRoaXMucnVubmVycy5yZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgICB0aGlzLnJ1bm5lcnMucmVuZGVyRW5kLmVtaXQob3B0aW9ucyk7XG4gICAgdGhpcy5ydW5uZXJzLnBvc3RyZW5kZXIuZW1pdChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplcyB0aGUgV2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSBkZXNpcmVkU2NyZWVuV2lkdGggLSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gZGVzaXJlZFNjcmVlbkhlaWdodCAtIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gcmVzb2x1dGlvbiAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSByZW5kZXJlci5cbiAgICovXG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnZpZXcucmVzaXplKGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCwgcmVzb2x1dGlvbik7XG4gICAgdGhpcy5lbWl0KFwicmVzaXplXCIsIHRoaXMudmlldy5zY3JlZW4ud2lkdGgsIHRoaXMudmlldy5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBjbGVhcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXM7XG4gICAgb3B0aW9ucy50YXJnZXQgfHwgKG9wdGlvbnMudGFyZ2V0ID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclRhcmdldCk7XG4gICAgb3B0aW9ucy5jbGVhckNvbG9yIHx8IChvcHRpb25zLmNsZWFyQ29sb3IgPSB0aGlzLmJhY2tncm91bmQuY29sb3JSZ2JhKTtcbiAgICBvcHRpb25zLmNsZWFyID8/IChvcHRpb25zLmNsZWFyID0gQ0xFQVIuQUxMKTtcbiAgICBjb25zdCB7IGNsZWFyLCBjbGVhckNvbG9yLCB0YXJnZXQgfSA9IG9wdGlvbnM7XG4gICAgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNsZWFyQ29sb3IgPz8gdGhpcy5iYWNrZ3JvdW5kLmNvbG9yUmdiYSk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNsZWFyKHRhcmdldCwgY2xlYXIsIENvbG9yLnNoYXJlZC50b0FycmF5KCkpO1xuICB9XG4gIC8qKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuICovXG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMudmlldy5yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5ydW5uZXJzLnJlc29sdXRpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgYXMgdmlldy53aWR0aCwgYWN0dWFsIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlIGNhbnZhcyBieSBob3Jpem9udGFsLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVmYXVsdCA4MDBcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnRleHR1cmUuZnJhbWUud2lkdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgYXMgdmlldy5oZWlnaHQsIGFjdHVhbCBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBjYW52YXMgYnkgdmVydGljYWwuXG4gICAqIEBkZWZhdWx0IDYwMFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICB9XG4gIC8vIE5PVEU6IHRoaXMgd2FzIGB2aWV3YCBpbiB2N1xuICAvKipcbiAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0by5cbiAgICogQHR5cGUge2Vudmlyb25tZW50LklDYW52YXN9XG4gICAqL1xuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiB0aGUgbGFzdCBvYmplY3QgcmVuZGVyZWQgYnkgdGhlIHJlbmRlcmVyLiBVc2VmdWwgZm9yIG90aGVyIHBsdWdpbnMgbGlrZSBpbnRlcmFjdGlvbiBtYW5hZ2Vyc1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0T2JqZWN0UmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZDtcbiAgfVxuICAvKipcbiAgICogRmxhZyBpZiB3ZSBhcmUgcmVuZGVyaW5nIHRvIHRoZSBzY3JlZW4gdnMgcmVuZGVyVGV4dHVyZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2V0IHJlbmRlcmluZ1RvU2NyZWVuKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcztcbiAgICByZXR1cm4gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlcmluZ1RvU2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBNZWFzdXJlbWVudHMgb2YgdGhlIHNjcmVlbi4gKDAsIDAsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpLlxuICAgKlxuICAgKiBJdHMgc2FmZSB0byB1c2UgYXMgZmlsdGVyQXJlYSBvciBoaXRBcmVhIGZvciB0aGUgd2hvbGUgc3RhZ2UuXG4gICAqL1xuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc2NyZWVuO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBidW5jaCBvZiBydW5uZXJzIGJhc2VkIG9mIGEgY29sbGVjdGlvbiBvZiBpZHNcbiAgICogQHBhcmFtIHJ1bm5lcklkcyAtIHRoZSBydW5uZXIgaWRzIHRvIGFkZFxuICAgKi9cbiAgX2FkZFJ1bm5lcnMoLi4ucnVubmVySWRzKSB7XG4gICAgcnVubmVySWRzLmZvckVhY2goKHJ1bm5lcklkKSA9PiB7XG4gICAgICB0aGlzLnJ1bm5lcnNbcnVubmVySWRdID0gbmV3IFN5c3RlbVJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZFN5c3RlbXMoc3lzdGVtcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiBzeXN0ZW1zKSB7XG4gICAgICBjb25zdCB2YWwgPSBzeXN0ZW1zW2ldO1xuICAgICAgdGhpcy5fYWRkU3lzdGVtKHZhbC52YWx1ZSwgdmFsLm5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgbmV3IHN5c3RlbSB0byB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSBDbGFzc1JlZiAtIENsYXNzIHJlZmVyZW5jZVxuICAgKiBAcGFyYW0gbmFtZSAtIFByb3BlcnR5IG5hbWUgZm9yIHN5c3RlbSwgaWYgbm90IHNwZWNpZmllZFxuICAgKiAgICAgICAgd2lsbCB1c2UgYSBzdGF0aWMgYG5hbWVgIHByb3BlcnR5IG9uIHRoZSBjbGFzcyBpdHNlbGYuIFRoaXNcbiAgICogICAgICAgIG5hbWUgd2lsbCBiZSBhc3NpZ25lZCBhcyBzIHByb3BlcnR5IG9uIHRoZSBSZW5kZXJlciBzbyBtYWtlXG4gICAqICAgICAgICBzdXJlIGl0IGRvZXNuJ3QgY29sbGlkZSB3aXRoIHByb3BlcnRpZXMgb24gUmVuZGVyZXIuXG4gICAqIEByZXR1cm5zIFJldHVybiBpbnN0YW5jZSBvZiByZW5kZXJlclxuICAgKi9cbiAgX2FkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xuICAgIGNvbnN0IHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcbiAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaG9vcHMhIFRoZSBuYW1lIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlYCk7XG4gICAgfVxuICAgIHRoaXNbbmFtZV0gPSBzeXN0ZW07XG4gICAgdGhpcy5fc3lzdGVtc0hhc2hbbmFtZV0gPSBzeXN0ZW07XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMucnVubmVycykge1xuICAgICAgdGhpcy5ydW5uZXJzW2ldLmFkZChzeXN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfYWRkUGlwZXMocGlwZXMsIHBpcGVBZGFwdG9ycykge1xuICAgIGNvbnN0IGFkYXB0b3JzID0gcGlwZUFkYXB0b3JzLnJlZHVjZSgoYWNjLCBhZGFwdG9yKSA9PiB7XG4gICAgICBhY2NbYWRhcHRvci5uYW1lXSA9IGFkYXB0b3IudmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBwaXBlcy5mb3JFYWNoKChwaXBlKSA9PiB7XG4gICAgICBjb25zdCBQaXBlQ2xhc3MgPSBwaXBlLnZhbHVlO1xuICAgICAgY29uc3QgbmFtZSA9IHBpcGUubmFtZTtcbiAgICAgIGNvbnN0IEFkYXB0b3IgPSBhZGFwdG9yc1tuYW1lXTtcbiAgICAgIHRoaXMucmVuZGVyUGlwZXNbbmFtZV0gPSBuZXcgUGlwZUNsYXNzKFxuICAgICAgICB0aGlzLFxuICAgICAgICBBZGFwdG9yID8gbmV3IEFkYXB0b3IoKSA6IG51bGxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zID0gZmFsc2UpIHtcbiAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5pdGVtcy5yZXZlcnNlKCk7XG4gICAgdGhpcy5ydW5uZXJzLmRlc3Ryb3kuZW1pdChvcHRpb25zKTtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMucnVubmVycykuZm9yRWFjaCgocnVubmVyKSA9PiB7XG4gICAgICBydW5uZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclBpcGVzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0ZXh0dXJlIGZyb20gYSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBvciBjb250YWluZXIgdGFyZ2V0IHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgdGhlIHRleHR1cmVcbiAgICogQHJldHVybnMgYSB0ZXh0dXJlXG4gICAqL1xuICBnZW5lcmF0ZVRleHR1cmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVHZW5lcmF0b3IuZ2VuZXJhdGVUZXh0dXJlKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZW5kZXJlciB3aWxsIHJvdW5kIGNvb3JkaW5hdGVzIHRvIHdob2xlIHBpeGVscyB3aGVuIHJlbmRlcmluZy5cbiAgICogQ2FuIGJlIG92ZXJyaWRkZW4gb24gYSBwZXIgc2NlbmUgaXRlbSBiYXNpcy5cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIGJ5IGBwaXhpLmpzL3Vuc2FmZS1ldmFsYCB0byBzaWxlbmNlXG4gICAqIHRocm93aW5nIGFuIGVycm9yIGlmIHBsYXRmb3JtIGRvZXNuJ3Qgc3VwcG9ydCB1bnNhZmUtZXZhbHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF91bnNhZmVFdmFsQ2hlY2soKSB7XG4gICAgaWYgKCF1bnNhZmVFdmFsU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3QgYWxsb3cgdW5zYWZlLWV2YWwsIHBsZWFzZSB1c2UgcGl4aS5qcy91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuXCIpO1xuICAgIH1cbiAgfVxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgcmVuZGVyZXIuICovXG5fQWJzdHJhY3RSZW5kZXJlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIuXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHJlc29sdXRpb246IDEsXG4gIC8qKlxuICAgKiBTaG91bGQgdGhlIGBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0YCBmbGFnIGJlIGVuYWJsZWQgYXMgYSBjb250ZXh0IG9wdGlvbiB1c2VkIGluIHRoZSBgaXNXZWJHTFN1cHBvcnRlZGBcbiAgICogZnVuY3Rpb24uIElmIHNldCB0byB0cnVlLCBhIFdlYkdMIHJlbmRlcmVyIGNhbiBmYWlsIHRvIGJlIGNyZWF0ZWQgaWYgdGhlIGJyb3dzZXIgdGhpbmtzIHRoZXJlIGNvdWxkIGJlXG4gICAqIHBlcmZvcm1hbmNlIGlzc3VlcyB3aGVuIHVzaW5nIFdlYkdMLlxuICAgKlxuICAgKiBJbiBQaXhpSlMgdjYgdGhpcyBoYXMgY2hhbmdlZCBmcm9tIHRydWUgdG8gZmFsc2UgYnkgZGVmYXVsdCwgdG8gYWxsb3cgV2ViR0wgdG8gd29yayBpbiBhcyBtYW55XG4gICAqIHNjZW5hcmlvcyBhcyBwb3NzaWJsZS4gSG93ZXZlciwgc29tZSB1c2VycyBtYXkgaGF2ZSBhIHBvb3IgZXhwZXJpZW5jZSwgZm9yIGV4YW1wbGUsIGlmIGEgdXNlciBoYXMgYSBncHUgb3JcbiAgICogZHJpdmVyIHZlcnNpb24gYmxhY2tsaXN0ZWQgYnkgdGhlXG4gICAqIGJyb3dzZXIuXG4gICAqXG4gICAqIElmIHlvdXIgYXBwbGljYXRpb24gcmVxdWlyZXMgaGlnaCBwZXJmb3JtYW5jZSByZW5kZXJpbmcsIHlvdSBtYXkgd2lzaCB0byBzZXQgdGhpcyB0byBmYWxzZS5cbiAgICogV2UgcmVjb21tZW5kIG9uZSBvZiB0d28gb3B0aW9ucyBpZiB5b3UgZGVjaWRlIHRvIHNldCB0aGlzIGZsYWcgdG8gZmFsc2U6XG4gICAqXG4gICAqIDE6IFVzZSB0aGUgQ2FudmFzIHJlbmRlcmVyIGFzIGEgZmFsbGJhY2sgaW4gY2FzZSBoaWdoIHBlcmZvcm1hbmNlIFdlYkdMIGlzXG4gICAqICAgIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIDI6IENhbGwgYGlzV2ViR0xTdXBwb3J0ZWRgICh3aGljaCBpZiBmb3VuZCBpbiB0aGUgdXRpbHMgcGFja2FnZSkgaW4geW91ciBjb2RlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhXG4gICAqICAgIFBpeGlKUyByZW5kZXJlciwgYW5kIHNob3cgYW4gZXJyb3IgbWVzc2FnZSB0byB0aGUgdXNlciBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgZXhwbGFpbmluZyB0aGF0IHRoZWlyXG4gICAqICAgIGRldmljZSAmIGJyb3dzZXIgY29tYmluYXRpb24gZG9lcyBub3Qgc3VwcG9ydCBoaWdoIHBlcmZvcm1hbmNlIFdlYkdMLlxuICAgKiAgICBUaGlzIGlzIGEgbXVjaCBiZXR0ZXIgc3RyYXRlZ3kgdGhhbiB0cnlpbmcgdG8gY3JlYXRlIGEgUGl4aUpTIHJlbmRlcmVyIGFuZCBmaW5kaW5nIGl0IHRoZW4gZmFpbHMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgLyoqXG4gICAqIFNob3VsZCByb3VuZCBwaXhlbHMgYmUgZm9yY2VkIHdoZW4gcmVuZGVyaW5nP1xuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcm91bmRQaXhlbHM6IGZhbHNlXG59O1xubGV0IEFic3RyYWN0UmVuZGVyZXIgPSBfQWJzdHJhY3RSZW5kZXJlcjtcblxuZXhwb3J0IHsgQWJzdHJhY3RSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RSZW5kZXJlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7199\n')},7051:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ SystemRunner)\n/* harmony export */ });\n\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\n\n//# sourceMappingURL=SystemRunner.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA1MS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc3lzdGVtL1N5c3RlbVJ1bm5lci5tanM/ZGRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNsYXNzIFN5c3RlbVJ1bm5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBmdW5jdGlvbiBuYW1lIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBvbiB0aGUgbGlzdGVuZXJzIGFkZGVkIHRvIHRoaXMgUnVubmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLXBhcmFtLCBqc2RvYy9jaGVjay1wYXJhbS1uYW1lcyAqL1xuICAvKipcbiAgICogRGlzcGF0Y2gvQnJvYWRjYXN0IFJ1bm5lciB0byBhbGwgbGlzdGVuZXJzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtcyAtIChvcHRpb25hbCkgcGFyYW1ldGVycyB0byBwYXNzIHRvIGVhY2ggbGlzdGVuZXJcbiAgICovXG4gIC8qICBlc2xpbnQtZW5hYmxlIGpzZG9jL3JlcXVpcmUtcGFyYW0sIGpzZG9jL2NoZWNrLXBhcmFtLW5hbWVzICovXG4gIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgY29uc3QgeyBuYW1lLCBpdGVtcyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW1zW2ldW25hbWVdKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgUnVubmVyXG4gICAqXG4gICAqIFJ1bm5lcnMgZG8gbm90IG5lZWQgdG8gaGF2ZSBzY29wZSBvciBmdW5jdGlvbnMgcGFzc2VkIHRvIHRoZW0uXG4gICAqIEFsbCB0aGF0IGlzIHJlcXVpcmVkIGlzIHRvIHBhc3MgdGhlIGxpc3RlbmluZyBvYmplY3QgYW5kIGVuc3VyZSB0aGF0IGl0IGhhcyBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWVcbiAgICogYXMgdGhlIG5hbWUgcHJvdmlkZWQgdG8gdGhlIFJ1bm5lciB3aGVuIGl0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBFZyBBIGxpc3RlbmVyIHBhc3NlZCB0byB0aGlzIFJ1bm5lciB3aWxsIHJlcXVpcmUgYSAnY29tcGxldGUnIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBgYGBcbiAgICogaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IGNvbXBsZXRlID0gbmV3IFJ1bm5lcignY29tcGxldGUnKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBzY29wZSB1c2VkIHdpbGwgYmUgdGhlIG9iamVjdCBpdHNlbGYuXG4gICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgbGlzdGVuaW5nLlxuICAgKi9cbiAgYWRkKGl0ZW0pIHtcbiAgICBpZiAoaXRlbVt0aGlzLl9uYW1lXSkge1xuICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbmVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGlzIGFscmVhZHkgaW4gdGhlIFJ1bm5lclxuICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBsaXN0ZW5lciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIGNoZWNrLlxuICAgKi9cbiAgY29udGFpbnMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICB9XG4gIC8qKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHRoZSBSdW5uZXIgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogUmVtb3ZlIGFsbCByZWZlcmVuY2VzLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBgdHJ1ZWAgaWYgdGhlcmUgYXJlIG5vIHRoaXMgUnVubmVyIGNvbnRhaW5zIG5vIGxpc3RlbmVyc1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBydW5uZXIuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3lzdGVtUnVubmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TeXN0ZW1SdW5uZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7051\n")},9853:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  x: () => (/* binding */ Texture)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs\n\n\n"use strict";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix/* Matrix */.y();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don\'t.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn\'t work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/misc/NOOP.mjs\n\nconst NOOP = () => {\n};\n\n\n//# sourceMappingURL=NOOP.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferSource.mjs\nvar BufferSource = __webpack_require__(4758);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs + 2 modules\nvar TextureSource = __webpack_require__(5206);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs\nvar TextureMatrix = __webpack_require__(575);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass Texture extends eventemitter3/* default */.Z {\n  /**\n   * @param {TextureOptions} param0 - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = (0,uid/* uid */.h)("texture");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle/* Rectangle */.A();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on(\'update\', () => {});\n     */\n    this.noFrame = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource/* TextureSource */.p();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off("resize", this.update, this);\n    }\n    this._source = value;\n    value.on("resize", this.update, this);\n    this.emit("update", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix/* TextureMatrix */.U(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit("update", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Texture.baseTexture is now Texture.source");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: "EMPTY",\n  source: new TextureSource/* TextureSource */.p({\n    label: "EMPTY"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferSource/* BufferImageSource */.A({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: "premultiply-alpha-on-upload",\n    label: "WHITE"\n  }),\n  label: "WHITE"\n});\nTexture.WHITE.destroy = NOOP;\n\n\n//# sourceMappingURL=Texture.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7QUFDbkI7Ozs7Ozs7OztBQ3JRYTtBQUNiO0FBQ0E7O0FBRWdCO0FBQ2hCOzs7Ozs7Ozs7QUNMeUM7QUFDc0I7QUFDSTtBQUNkO0FBQzJCO0FBQ3pCO0FBQ1E7QUFDSDtBQUNSOztBQUVwRDtBQUNBLHNCQUFzQiw0QkFBWTtBQUNsQztBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBLGVBQWUsa0JBQUc7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxhQUFhLE9BQU87QUFDMUMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMsZUFBZSxPQUFPO0FBQ3RCLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLGVBQWUsT0FBTztBQUN0Qix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyxlQUFlLE9BQU87QUFDdEIseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBVyxDQUFDLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFhO0FBQzNCO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx3QkFBd0IsSUFBSTtBQUM1QjtBQUNBLGNBQWMscUNBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLElBQUk7O0FBRVQ7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9tYXRyaXgvZ3JvdXBEOC5tanM/OTRkNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9taXNjL05PT1AubWpzPzdjYjAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcz80NTU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07XG5jb25zdCB1eSA9IFswLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbmNvbnN0IHZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuY29uc3QgdnkgPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMV07XG5jb25zdCByb3RhdGlvbkNheWxleSA9IFtdO1xuY29uc3Qgcm90YXRpb25NYXRyaWNlcyA9IFtdO1xuY29uc3Qgc2lnbnVtID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gW107XG4gICAgcm90YXRpb25DYXlsZXkucHVzaChyb3cpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgY29uc3QgX3V4ID0gc2lnbnVtKHV4W2ldICogdXhbal0gKyB2eFtpXSAqIHV5W2pdKTtcbiAgICAgIGNvbnN0IF91eSA9IHNpZ251bSh1eVtpXSAqIHV4W2pdICsgdnlbaV0gKiB1eVtqXSk7XG4gICAgICBjb25zdCBfdnggPSBzaWdudW0odXhbaV0gKiB2eFtqXSArIHZ4W2ldICogdnlbal0pO1xuICAgICAgY29uc3QgX3Z5ID0gc2lnbnVtKHV5W2ldICogdnhbal0gKyB2eVtpXSAqIHZ5W2pdKTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMTY7IGsrKykge1xuICAgICAgICBpZiAodXhba10gPT09IF91eCAmJiB1eVtrXSA9PT0gX3V5ICYmIHZ4W2tdID09PSBfdnggJiYgdnlba10gPT09IF92eSkge1xuICAgICAgICAgIHJvdy5wdXNoKGspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXQuc2V0KHV4W2ldLCB1eVtpXSwgdnhbaV0sIHZ5W2ldLCAwLCAwKTtcbiAgICByb3RhdGlvbk1hdHJpY2VzLnB1c2gobWF0KTtcbiAgfVxufVxuaW5pdCgpO1xuY29uc3QgZ3JvdXBEOCA9IHtcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAwwrAgICAgICAgfCBFYXN0ICAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgRTogMCxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA0NcKw4oa7ICAgICB8IFNvdXRoZWFzdCB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBTRTogMSxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gfCBEaXJlY3Rpb24gfFxuICAgKiB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCA5MMKw4oa7ICAgICB8IFNvdXRoICAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBTOiAyLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDEzNcKw4oa7ICAgIHwgU291dGh3ZXN0IHxcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIFNXOiAzLFxuICAvKipcbiAgICogfCBSb3RhdGlvbiB8IERpcmVjdGlvbiB8XG4gICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8IDE4MMKwICAgICB8IFdlc3QgICAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBXOiA0LFxuICAvKipcbiAgICogfCBSb3RhdGlvbiAgICB8IERpcmVjdGlvbiAgICB8XG4gICAqIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfFxuICAgKiB8IC0xMzXCsC8yMjXCsOKGuyB8IE5vcnRod2VzdCAgICB8XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBOVzogNSxcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtOTDCsC8yNzDCsOKGuyAgfCBOb3J0aCAgICAgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTjogNixcbiAgLyoqXG4gICAqIHwgUm90YXRpb24gICAgfCBEaXJlY3Rpb24gICAgfFxuICAgKiB8LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLXxcbiAgICogfCAtNDXCsC8zMTXCsOKGuyAgfCBOb3J0aGVhc3QgICAgfFxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTkU6IDcsXG4gIC8qKlxuICAgKiBSZWZsZWN0aW9uIGFib3V0IFktYXhpcy5cbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQGNvbnN0YW50IHtHRDhTeW1tZXRyeX1cbiAgICovXG4gIE1JUlJPUl9WRVJUSUNBTDogOCxcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgdGhlIG1haW4gZGlhZ29uYWwuXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBjb25zdGFudCB7R0Q4U3ltbWV0cnl9XG4gICAqL1xuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgLyoqXG4gICAqIFJlZmxlY3Rpb24gYWJvdXQgWC1heGlzLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICAvKipcbiAgICogUmVmbGVjdGlvbiBhYm91dCByZXZlcnNlIGRpYWdvbmFsLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAY29uc3RhbnQge0dEOFN5bW1ldHJ5fVxuICAgKi9cbiAgUkVWRVJTRV9ESUFHT05BTDogMTQsXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gVGhlIFgtY29tcG9uZW50IG9mIHRoZSBVLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB1WDogKGluZCkgPT4gdXhbaW5kXSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IGluZCAtIHNwcml0ZSByb3RhdGlvbiBhbmdsZS5cbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBUaGUgWS1jb21wb25lbnQgb2YgdGhlIFUtYXhpc1xuICAgKiAgICBhZnRlciByb3RhdGluZyB0aGUgYXhlcy5cbiAgICovXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICAvKipcbiAgICogQG1lbWJlcm9mIG1hdGhzLmdyb3VwRDhcbiAgICogQHBhcmFtIHtHRDhTeW1tZXRyeX0gaW5kIC0gc3ByaXRlIHJvdGF0aW9uIGFuZ2xlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBYLWNvbXBvbmVudCBvZiB0aGUgVi1heGlzXG4gICAqICAgIGFmdGVyIHJvdGF0aW5nIHRoZSBheGVzLlxuICAgKi9cbiAgdlg6IChpbmQpID0+IHZ4W2luZF0sXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSBpbmQgLSBzcHJpdGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gVGhlIFktY29tcG9uZW50IG9mIHRoZSBWLWF4aXNcbiAgICogICAgYWZ0ZXIgcm90YXRpbmcgdGhlIGF4ZXMuXG4gICAqL1xuICB2WTogKGluZCkgPT4gdnlbaW5kXSxcbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uIC0gc3ltbWV0cnkgd2hvc2Ugb3Bwb3NpdGVcbiAgICogICBpcyBuZWVkZWQuIE9ubHkgcm90YXRpb25zIGhhdmUgb3Bwb3NpdGUgc3ltbWV0cmllcyB3aGlsZVxuICAgKiAgIHJlZmxlY3Rpb25zIGRvbid0LlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IFRoZSBvcHBvc2l0ZSBzeW1tZXRyeSBvZiBgcm90YXRpb25gXG4gICAqL1xuICBpbnY6IChyb3RhdGlvbikgPT4ge1xuICAgIGlmIChyb3RhdGlvbiAmIDgpIHtcbiAgICAgIHJldHVybiByb3RhdGlvbiAmIDE1O1xuICAgIH1cbiAgICByZXR1cm4gLXJvdGF0aW9uICYgNztcbiAgfSxcbiAgLyoqXG4gICAqIENvbXBvc2VzIHRoZSB0d28gRDggb3BlcmF0aW9ucy5cbiAgICpcbiAgICogVGFraW5nIGBeYCBhcyByZWZsZWN0aW9uOlxuICAgKlxuICAgKiB8ICAgICAgIHwgRT0wIHwgUz0yIHwgVz00IHwgTj02IHwgRV49OCB8IFNePTEwIHwgV149MTIgfCBOXj0xNCB8XG4gICAqIHwtLS0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tLXwtLS0tLS0tfC0tLS0tLS18LS0tLS0tLXxcbiAgICogfCBFPTAgICB8IEUgICB8IFMgICB8IFcgICB8IE4gICB8IEVeICAgfCBTXiAgICB8IFdeICAgIHwgTl4gICAgfFxuICAgKiB8IFM9MiAgIHwgUyAgIHwgVyAgIHwgTiAgIHwgRSAgIHwgU14gICB8IFdeICAgIHwgTl4gICAgfCBFXiAgICB8XG4gICAqIHwgVz00ICAgfCBXICAgfCBOICAgfCBFICAgfCBTICAgfCBXXiAgIHwgTl4gICAgfCBFXiAgICB8IFNeICAgIHxcbiAgICogfCBOPTYgICB8IE4gICB8IEUgICB8IFMgICB8IFcgICB8IE5eICAgfCBFXiAgICB8IFNeICAgIHwgV14gICAgfFxuICAgKiB8IEVePTggIHwgRV4gIHwgTl4gIHwgV14gIHwgU14gIHwgRSAgICB8IE4gICAgIHwgVyAgICAgfCBTICAgICB8XG4gICAqIHwgU149MTAgfCBTXiAgfCBFXiAgfCBOXiAgfCBXXiAgfCBTICAgIHwgRSAgICAgfCBOICAgICB8IFcgICAgIHxcbiAgICogfCBXXj0xMiB8IFdeICB8IFNeICB8IEVeICB8IE5eICB8IFcgICAgfCBTICAgICB8IEUgICAgIHwgTiAgICAgfFxuICAgKiB8IE5ePTE0IHwgTl4gIHwgV14gIHwgU14gIHwgRV4gIHwgTiAgICB8IFcgICAgIHwgUyAgICAgfCBFICAgICB8XG4gICAqXG4gICAqIFtUaGlzIGlzIGEgQ2F5bGV5IHRhYmxlXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXlsZXlfdGFibGV9XG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvbiwgd2hpY2hcbiAgICogICBpcyB0aGUgcm93IGluIHRoZSBhYm92ZSBjYXlsZXkgdGFibGUuXG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uRmlyc3QgLSBGaXJzdCBvcGVyYXRpb24sIHdoaWNoXG4gICAqICAgaXMgdGhlIGNvbHVtbiBpbiB0aGUgYWJvdmUgY2F5bGV5IHRhYmxlLlxuICAgKiBAcmV0dXJucyB7R0Q4U3ltbWV0cnl9IENvbXBvc2VkIG9wZXJhdGlvblxuICAgKi9cbiAgYWRkOiAocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpID0+IHJvdGF0aW9uQ2F5bGV5W3JvdGF0aW9uU2Vjb25kXVtyb3RhdGlvbkZpcnN0XSxcbiAgLyoqXG4gICAqIFJldmVyc2Ugb2YgYGFkZGAuXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uU2Vjb25kIC0gU2Vjb25kIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbkZpcnN0IC0gRmlyc3Qgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtHRDhTeW1tZXRyeX0gUmVzdWx0XG4gICAqL1xuICBzdWI6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW2dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXSxcbiAgLyoqXG4gICAqIEFkZHMgMTgwIGRlZ3JlZXMgdG8gcm90YXRpb24sIHdoaWNoIGlzIGEgY29tbXV0YXRpdmVcbiAgICogb3BlcmF0aW9uLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBUaGUgbnVtYmVyIHRvIHJvdGF0ZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUm90YXRlZCBudW1iZXJcbiAgICovXG4gIHJvdGF0ZTE4MDogKHJvdGF0aW9uKSA9PiByb3RhdGlvbiBeIDQsXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHJvdGF0aW9uIGFuZ2xlIGlzIHZlcnRpY2FsLCBpLmUuIHNvdXRoXG4gICAqIG9yIG5vcnRoLiBJdCBkb2Vzbid0IHdvcmsgZm9yIHJlZmxlY3Rpb25zLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge0dEOFN5bW1ldHJ5fSByb3RhdGlvbiAtIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiAocm90YXRpb24pID0+IChyb3RhdGlvbiAmIDMpID09PSAyLFxuICAvLyByb3RhdGlvbiAlIDQgPT09IDJcbiAgLyoqXG4gICAqIEFwcHJveGltYXRlcyB0aGUgdmVjdG9yIGBWKGR4LGR5KWAgaW50byBvbmUgb2YgdGhlXG4gICAqIGVpZ2h0IGRpcmVjdGlvbnMgcHJvdmlkZWQgYnkgYGdyb3VwRDhgLlxuICAgKiBAbWVtYmVyb2YgbWF0aHMuZ3JvdXBEOFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBYLWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIFktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAgICogQHJldHVybnMge0dEOFN5bW1ldHJ5fSBBcHByb3hpbWF0aW9uIG9mIHRoZSB2ZWN0b3IgaW50b1xuICAgKiAgb25lIG9mIHRoZSBlaWdodCBzeW1tZXRyaWVzLlxuICAgKi9cbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5OO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cEQ4Llc7XG4gICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguU0U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5TVztcbiAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwRDguTkU7XG4gICAgfVxuICAgIHJldHVybiBncm91cEQ4Lk5XO1xuICB9LFxuICAvKipcbiAgICogSGVscHMgc3ByaXRlIHRvIGNvbXBlbnNhdGUgdGV4dHVyZSBwYWNrZXIgcm90YXRpb24uXG4gICAqIEBtZW1iZXJvZiBtYXRocy5ncm91cEQ4XG4gICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXggLSBzcHJpdGUgd29ybGQgbWF0cml4XG4gICAqIEBwYXJhbSB7R0Q4U3ltbWV0cnl9IHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIGZhY3RvciB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIHNwcml0ZSBhbmNob3JpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gc3ByaXRlIGFuY2hvcmluZ1xuICAgKi9cbiAgbWF0cml4QXBwZW5kUm90YXRpb25JbnY6IChtYXRyaXgsIHJvdGF0aW9uLCB0eCA9IDAsIHR5ID0gMCkgPT4ge1xuICAgIGNvbnN0IG1hdCA9IHJvdGF0aW9uTWF0cmljZXNbZ3JvdXBEOC5pbnYocm90YXRpb24pXTtcbiAgICBtYXQudHggPSB0eDtcbiAgICBtYXQudHkgPSB0eTtcbiAgICBtYXRyaXguYXBwZW5kKG1hdCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGdyb3VwRDggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwRDgubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcblxuZXhwb3J0IHsgTk9PUCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tk9PUC5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9ncm91cEQ4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IE5PT1AgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9taXNjL05PT1AubWpzJztcbmltcG9ydCB7IEJ1ZmZlckltYWdlU291cmNlIH0gZnJvbSAnLi9zb3VyY2VzL0J1ZmZlclNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vc291cmNlcy9UZXh0dXJlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlTWF0cml4IH0gZnJvbSAnLi9UZXh0dXJlTWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR1cmVPcHRpb25zfSBwYXJhbTAgLSBPcHRpb25zIGZvciB0aGUgdGV4dHVyZVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHNvdXJjZSxcbiAgICBsYWJlbCxcbiAgICBmcmFtZSxcbiAgICBvcmlnLFxuICAgIHRyaW0sXG4gICAgZGVmYXVsdEFuY2hvcixcbiAgICBkZWZhdWx0Qm9yZGVycyxcbiAgICByb3RhdGVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIHRleHR1cmUgKi9cbiAgICB0aGlzLnVpZCA9IHVpZChcInRleHR1cmVcIik7XG4gICAgLyoqIEEgdXZzIG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZnJhbWUgYW5kIHRoZSB0ZXh0dXJlIHNvdXJjZSAqL1xuICAgIHRoaXMudXZzID0geyB4MDogMCwgeTA6IDAsIHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAwLCB4MzogMCwgeTM6IDAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICovXG4gICAgdGhpcy5mcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogVGhpcyBtb2RlIGlzIGVuYWJsZWQgYXV0b21hdGljYWxseSBpZiBubyBmcmFtZSB3YXMgcGFzc2VkIGluc2lkZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgbW9kZSB0ZXh0dXJlIGlzIHN1YnNjcmliZWQgdG8gYmFzZVRleHR1cmUgZXZlbnRzLCBhbmQgZmlyZXMgYHVwZGF0ZWAgb24gYW55IGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEJld2FyZSwgYWZ0ZXIgbG9hZGluZyBvciByZXNpemUgb2YgYmFzZVRleHR1cmUgZXZlbnQgY2FuIGZpcmVkIHR3byB0aW1lcyFcbiAgICAgKiBJZiB5b3Ugd2FudCBtb3JlIGNvbnRyb2wsIHN1YnNjcmliZSBvbiBiYXNlVGV4dHVyZSBpdHNlbGYuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0ZXh0dXJlLm9uKCd1cGRhdGUnLCAoKSA9PiB7fSk7XG4gICAgICovXG4gICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG4gICAgLyoqIGlzIGl0IGEgdGV4dHVyZT8geWVzISB1c2VkIGZvciB0eXBlIGNoZWNraW5nICovXG4gICAgdGhpcy5pc1RleHR1cmUgPSB0cnVlO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZT8uc291cmNlID8/IG5ldyBUZXh0dXJlU291cmNlKCk7XG4gICAgdGhpcy5ub0ZyYW1lID0gIWZyYW1lO1xuICAgIGlmIChmcmFtZSkge1xuICAgICAgdGhpcy5mcmFtZS5jb3B5RnJvbShmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fc291cmNlO1xuICAgICAgdGhpcy5mcmFtZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5mcmFtZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMub3JpZyA9IG9yaWcgfHwgdGhpcy5mcmFtZTtcbiAgICB0aGlzLnRyaW0gPSB0cmltO1xuICAgIHRoaXMucm90YXRlID0gcm90YXRlID8/IDA7XG4gICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gZGVmYXVsdEFuY2hvcjtcbiAgICB0aGlzLmRlZmF1bHRCb3JkZXJzID0gZGVmYXVsdEJvcmRlcnM7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIHNldCBzb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2Uub2ZmKFwicmVzaXplXCIsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fc291cmNlID0gdmFsdWU7XG4gICAgdmFsdWUub24oXCJyZXNpemVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogdGhlIHVuZGVybHlpbmcgc291cmNlIG9mIHRoZSB0ZXh0dXJlIChlcXVpdmFsZW50IG9mIGJhc2VUZXh0dXJlIGluIHY3KSAqL1xuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cbiAgLyoqIHJldHVybnMgYSBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIHRleHR1cmUuIEJ5IGRlZmF1bHQsIHRoYXQgb2JqZWN0IGlzIG5vdCBjcmVhdGVkIGJlY2F1c2UgaXRzIGhlYXZ5LiAqL1xuICBnZXQgdGV4dHVyZU1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3RleHR1cmVNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVNYXRyaXg7XG4gIH1cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICB9XG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLmhlaWdodDtcbiAgfVxuICAvKiogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4geW91IGhhdmUgbW9kaWZpZWQgdGhlIGZyYW1lIG9mIHRoaXMgdGV4dHVyZS4gKi9cbiAgdXBkYXRlVXZzKCkge1xuICAgIGNvbnN0IHsgdXZzLCBmcmFtZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3NvdXJjZTtcbiAgICBjb25zdCBuWCA9IGZyYW1lLnggLyB3aWR0aDtcbiAgICBjb25zdCBuWSA9IGZyYW1lLnkgLyBoZWlnaHQ7XG4gICAgY29uc3QgblcgPSBmcmFtZS53aWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IG5IID0gZnJhbWUuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGxldCByb3RhdGUgPSB0aGlzLnJvdGF0ZTtcbiAgICBpZiAocm90YXRlKSB7XG4gICAgICBjb25zdCB3MiA9IG5XIC8gMjtcbiAgICAgIGNvbnN0IGgyID0gbkggLyAyO1xuICAgICAgY29uc3QgY1ggPSBuWCArIHcyO1xuICAgICAgY29uc3QgY1kgPSBuWSArIGgyO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCBncm91cEQ4Lk5XKTtcbiAgICAgIHV2cy54MCA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTAgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MSA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTEgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MiA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTIgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHV2cy54MyA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB1dnMueTMgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dnMueDAgPSBuWDtcbiAgICAgIHV2cy55MCA9IG5ZO1xuICAgICAgdXZzLngxID0gblggKyBuVztcbiAgICAgIHV2cy55MSA9IG5ZO1xuICAgICAgdXZzLngyID0gblggKyBuVztcbiAgICAgIHV2cy55MiA9IG5ZICsgbkg7XG4gICAgICB1dnMueDMgPSBuWDtcbiAgICAgIHV2cy55MyA9IG5ZICsgbkg7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICogQHBhcmFtIGRlc3Ryb3lTb3VyY2UgLSBEZXN0cm95IHRoZSBzb3VyY2Ugd2hlbiB0aGUgdGV4dHVyZSBpcyBkZXN0cm95ZWQuXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lTb3VyY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChkZXN0cm95U291cmNlKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmVNYXRyaXggPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqIGNhbGwgdGhpcyBpZiB5b3UgaGF2ZSBtb2RpZmllZCB0aGUgYHRleHR1cmUgb3V0c2lkZWAgb2YgdGhlIGNvbnN0cnVjdG9yICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICB0aGlzLmZyYW1lLndpZHRoID0gdGhpcy5fc291cmNlLndpZHRoO1xuICAgICAgdGhpcy5mcmFtZS5oZWlnaHQgPSB0aGlzLl9zb3VyY2UuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgKi9cbiAgZ2V0IGJhc2VUZXh0dXJlKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJUZXh0dXJlLmJhc2VUZXh0dXJlIGlzIG5vdyBUZXh0dXJlLnNvdXJjZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICB9XG59XG5UZXh0dXJlLkVNUFRZID0gbmV3IFRleHR1cmUoe1xuICBsYWJlbDogXCJFTVBUWVwiLFxuICBzb3VyY2U6IG5ldyBUZXh0dXJlU291cmNlKHtcbiAgICBsYWJlbDogXCJFTVBUWVwiXG4gIH0pXG59KTtcblRleHR1cmUuRU1QVFkuZGVzdHJveSA9IE5PT1A7XG5UZXh0dXJlLldISVRFID0gbmV3IFRleHR1cmUoe1xuICBzb3VyY2U6IG5ldyBCdWZmZXJJbWFnZVNvdXJjZSh7XG4gICAgcmVzb3VyY2U6IG5ldyBVaW50OEFycmF5KFsyNTUsIDI1NSwgMjU1LCAyNTVdKSxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICAgIGxhYmVsOiBcIldISVRFXCJcbiAgfSksXG4gIGxhYmVsOiBcIldISVRFXCJcbn0pO1xuVGV4dHVyZS5XSElURS5kZXN0cm95ID0gTk9PUDtcblxuZXhwb3J0IHsgVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9853\n')},575:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ TextureMatrix)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n\n\n"use strict";\nconst tempMat = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === "undefined") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener("update", this.update, this);\n    this._texture = value;\n    this._texture.addListener("update", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.pixelWidth;\n    this.uClampOffset[1] = offset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBNkQ7O0FBRTdEO0FBQ0Esb0JBQW9CLHFFQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxRUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlTWF0cml4Lm1qcz81NGRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wTWF0ID0gbmV3IE1hdHJpeCgpO1xuY2xhc3MgVGV4dHVyZU1hdHJpeCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIG9ic2VydmVkIHRleHR1cmVcbiAgICogQHBhcmFtIGNsYW1wTWFyZ2luIC0gQ2hhbmdlcyBmcmFtZSBjbGFtcGluZywgMC41IGJ5IGRlZmF1bHQuIFVzZSAtMC41IGZvciBleHRyYSBib3JkZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBjbGFtcE1hcmdpbikge1xuICAgIHRoaXMubWFwQ29vcmQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdGhpcy51Q2xhbXBPZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmNsYW1wT2Zmc2V0ID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYW1wTWFyZ2luID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmNsYW1wTWFyZ2luID0gdGV4dHVyZS53aWR0aCA8IDEwID8gMCA6IDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGFtcE1hcmdpbiA9IGNsYW1wTWFyZ2luO1xuICAgIH1cbiAgICB0aGlzLmlzU2ltcGxlID0gZmFsc2U7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgfVxuICAvKiogVGV4dHVyZSBwcm9wZXJ0eS4gKi9cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90ZXh0dXJlPy5yZW1vdmVMaXN0ZW5lcihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuICAgIHRoaXMuX3RleHR1cmUuYWRkTGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdXZzIGFycmF5IHRvIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0gdXZzIC0gbWVzaCB1dnNcbiAgICogQHBhcmFtIFtvdXQ9dXZzXSAtIG91dHB1dFxuICAgKiBAcmV0dXJucyAtIG91dHB1dFxuICAgKi9cbiAgbXVsdGlwbHlVdnModXZzLCBvdXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHtcbiAgICAgIG91dCA9IHV2cztcbiAgICB9XG4gICAgY29uc3QgbWF0ID0gdGhpcy5tYXBDb29yZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHV2c1tpXTtcbiAgICAgIGNvbnN0IHkgPSB1dnNbaSArIDFdO1xuICAgICAgb3V0W2ldID0geCAqIG1hdC5hICsgeSAqIG1hdC5jICsgbWF0LnR4O1xuICAgICAgb3V0W2kgKyAxXSA9IHggKiBtYXQuYiArIHkgKiBtYXQuZCArIG1hdC50eTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBtYXRyaWNlcyBpZiB0ZXh0dXJlIHdhcyBjaGFuZ2VkXG4gICAqIEByZXR1cm5zIC0gd2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB0ZXggPSB0aGlzLl90ZXh0dXJlO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgY29uc3QgdXZzID0gdGV4LnV2cztcbiAgICB0aGlzLm1hcENvb3JkLnNldCh1dnMueDEgLSB1dnMueDAsIHV2cy55MSAtIHV2cy55MCwgdXZzLngzIC0gdXZzLngwLCB1dnMueTMgLSB1dnMueTAsIHV2cy54MCwgdXZzLnkwKTtcbiAgICBjb25zdCBvcmlnID0gdGV4Lm9yaWc7XG4gICAgY29uc3QgdHJpbSA9IHRleC50cmltO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB0ZW1wTWF0LnNldChcbiAgICAgICAgb3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsXG4gICAgICAgIC10cmltLnggLyB0cmltLndpZHRoLFxuICAgICAgICAtdHJpbS55IC8gdHJpbS5oZWlnaHRcbiAgICAgICk7XG4gICAgICB0aGlzLm1hcENvb3JkLmFwcGVuZCh0ZW1wTWF0KTtcbiAgICB9XG4gICAgY29uc3QgdGV4QmFzZSA9IHRleC5zb3VyY2U7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLl9yZXNvbHV0aW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2xhbXBPZmZzZXQ7XG4gICAgZnJhbWVbMF0gPSAodGV4LmZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICBmcmFtZVsxXSA9ICh0ZXguZnJhbWUueSArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcbiAgICBmcmFtZVsyXSA9ICh0ZXguZnJhbWUueCArIHRleC5mcmFtZS53aWR0aCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgIGZyYW1lWzNdID0gKHRleC5mcmFtZS55ICsgdGV4LmZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucGl4ZWxXaWR0aDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IG9mZnNldCAvIHRleEJhc2UucGl4ZWxIZWlnaHQ7XG4gICAgdGhpcy5pc1NpbXBsZSA9IHRleC5mcmFtZS53aWR0aCA9PT0gdGV4QmFzZS53aWR0aCAmJiB0ZXguZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodCAmJiB0ZXgucm90YXRlID09PSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHR1cmVNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///575\n')},4758:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ BufferImageSource)\n/* harmony export */ });\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n"use strict";\nclass BufferImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = "rgba32float";\n      } else if (buffer instanceof Int32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Uint32Array) {\n        format = "rgba32uint";\n      } else if (buffer instanceof Int16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Uint16Array) {\n        format = "rgba16uint";\n      } else if (buffer instanceof Int8Array) {\n        format = "bgra8unorm";\n      } else {\n        format = "bgra8unorm";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = "buffer";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=BufferSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc1OC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RTtBQUNyQjs7QUFFcEQ7QUFDQSxnQ0FBZ0Msc0VBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrRUFBYTs7QUFFZDtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9CdWZmZXJTb3VyY2UubWpzPzA4ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEJ1ZmZlckltYWdlU291cmNlIGV4dGVuZHMgVGV4dHVyZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBvcHRpb25zLnJlc291cmNlIHx8IG5ldyBGbG9hdDMyQXJyYXkob3B0aW9ucy53aWR0aCAqIG9wdGlvbnMuaGVpZ2h0ICogNCk7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTMyZmxvYXRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICBmb3JtYXQgPSBcInJnYmEzMnVpbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMzJ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJyZ2JhMTZ1aW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGZvcm1hdCA9IFwicmdiYTE2dWludFwiO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHtcbiAgICAgICAgZm9ybWF0ID0gXCJiZ3JhOHVub3JtXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBcImJncmE4dW5vcm1cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJlc291cmNlOiBidWZmZXIsXG4gICAgICBmb3JtYXRcbiAgICB9KTtcbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJidWZmZXJcIjtcbiAgfVxuICBzdGF0aWMgdGVzdChyZXNvdXJjZSkge1xuICAgIHJldHVybiByZXNvdXJjZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHwgcmVzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCByZXNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuQnVmZmVySW1hZ2VTb3VyY2UuZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5UZXh0dXJlU291cmNlO1xuXG5leHBvcnQgeyBCdWZmZXJJbWFnZVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4758\n')},6914:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ CanvasSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3489);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n"use strict";\nclass CanvasSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=CanvasSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkxNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0U7QUFDSztBQUNyQjs7QUFFcEQ7QUFDQSwyQkFBMkIsc0VBQWE7QUFDeEM7QUFDQTtBQUNBLHlCQUF5Qix5RUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRCxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtFQUFhOztBQUVkO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0NhbnZhc1NvdXJjZS5tanM/NTE4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4vVGV4dHVyZVNvdXJjZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc1NvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnJlc291cmNlKSB7XG4gICAgICBvcHRpb25zLnJlc291cmNlID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLndpZHRoKSB7XG4gICAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy5yZXNvdXJjZS53aWR0aDtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvRGVuc2l0eSkge1xuICAgICAgICBvcHRpb25zLndpZHRoIC89IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmhlaWdodCkge1xuICAgICAgb3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLnJlc291cmNlLmhlaWdodDtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvRGVuc2l0eSkge1xuICAgICAgICBvcHRpb25zLmhlaWdodCAvPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcImltYWdlXCI7XG4gICAgdGhpcy5hdXRvRGVuc2l0eSA9IG9wdGlvbnMuYXV0b0RlbnNpdHk7XG4gICAgY29uc3QgY2FudmFzID0gb3B0aW9ucy5yZXNvdXJjZTtcbiAgICBpZiAodGhpcy5waXhlbFdpZHRoICE9PSBjYW52YXMud2lkdGggfHwgdGhpcy5waXhlbFdpZHRoICE9PSBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zcGFyZW50ID0gISFvcHRpb25zLnRyYW5zcGFyZW50O1xuICB9XG4gIHJlc2l6ZUNhbnZhcygpIHtcbiAgICBpZiAodGhpcy5hdXRvRGVuc2l0eSkge1xuICAgICAgdGhpcy5yZXNvdXJjZS5zdHlsZS53aWR0aCA9IGAke3RoaXMud2lkdGh9cHhgO1xuICAgICAgdGhpcy5yZXNvdXJjZS5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmhlaWdodH1weGA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc291cmNlLndpZHRoICE9PSB0aGlzLnBpeGVsV2lkdGggfHwgdGhpcy5yZXNvdXJjZS5oZWlnaHQgIT09IHRoaXMucGl4ZWxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVzb3VyY2Uud2lkdGggPSB0aGlzLnBpeGVsV2lkdGg7XG4gICAgICB0aGlzLnJlc291cmNlLmhlaWdodCA9IHRoaXMucGl4ZWxIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJlc2l6ZSh3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LCByZXNvbHV0aW9uID0gdGhpcy5fcmVzb2x1dGlvbikge1xuICAgIGNvbnN0IGRpZFJlc2l6ZSA9IHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICBpZiAoZGlkUmVzaXplKSB7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgIH1cbiAgICByZXR1cm4gZGlkUmVzaXplO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTENhbnZhc0VsZW1lbnQgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBnbG9iYWxUaGlzLk9mZnNjcmVlbkNhbnZhcyAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcztcbiAgfVxufVxuQ2FudmFzU291cmNlLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZTtcblxuZXhwb3J0IHsgQ2FudmFzU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNTb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6914\n')},9160:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ ImageSource)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3646);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3489);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4796);\n/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5206);\n\n\n\n\n\n"use strict";\nclass ImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__/* .TextureSource */ .p {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__/* .DOMAdapter */ .z.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext("2d");\n      context.drawImage(options.resource, 0, 0);\n      options.resource = canvas;\n      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__/* .warn */ .Z)("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");\n    }\n    super(options);\n    this.uploadMethodId = "image";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap;\n  }\n}\nImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ExtensionType */ .nw.TextureSource;\n\n\n//# sourceMappingURL=ImageSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9FO0FBQ0s7QUFDWjtBQUNUOztBQUVwRDtBQUNBLDBCQUEwQixzRUFBYTtBQUN2QztBQUNBO0FBQ0EscUJBQXFCLHlFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0VBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0VBQWE7O0FBRWQ7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzPzI2NzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IFRleHR1cmVTb3VyY2UgfSBmcm9tICcuL1RleHR1cmVTb3VyY2UubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBJbWFnZVNvdXJjZSBleHRlbmRzIFRleHR1cmVTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVzb3VyY2UgJiYgKGdsb2JhbFRoaXMuSFRNTEltYWdlRWxlbWVudCAmJiBvcHRpb25zLnJlc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKG9wdGlvbnMucmVzb3VyY2Uud2lkdGgsIG9wdGlvbnMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2Uob3B0aW9ucy5yZXNvdXJjZSwgMCwgMCk7XG4gICAgICBvcHRpb25zLnJlc291cmNlID0gY2FudmFzO1xuICAgICAgd2FybihcIkltYWdlU291cmNlOiBJbWFnZSBlbGVtZW50IHBhc3NlZCwgY29udmVydGluZyB0byBjYW52YXMuIFVzZSBDYW52YXNTb3VyY2UgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudXBsb2FkTWV0aG9kSWQgPSBcImltYWdlXCI7XG4gICAgdGhpcy5hdXRvR2FyYmFnZUNvbGxlY3QgPSB0cnVlO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuSFRNTEltYWdlRWxlbWVudCAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gIH1cbn1cbkltYWdlU291cmNlLmV4dGVuc2lvbiA9IEV4dGVuc2lvblR5cGUuVGV4dHVyZVNvdXJjZTtcblxuZXhwb3J0IHsgSW1hZ2VTb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlU291cmNlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9160\n')},5206:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  p: () => (/* binding */ TextureSource)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(4181);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs\n\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=definedProps.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs\n\n\n\n\n"use strict";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = (0,uid/* uid */.h)("resource");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = "textureSampler";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "TextureStyle.wrapMode is now TextureStyle.addressMode");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = "linear";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit("change", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: "clamp-to-edge",\n  scaleMode: "linear"\n};\nlet TextureStyle = _TextureStyle;\n\n\n//# sourceMappingURL=TextureStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs\n\n\n\n\n\n\n"use strict";\nconst _TextureSource = class _TextureSource extends eventemitter3/* default */.Z {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = (0,uid/* uid */.h)("textureSource");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = "textureSource";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = "unknown";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = "rgba8unorm";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = "2d";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? "";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off("change", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on("change", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit("styleChange", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit("update", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit("destroy", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    this.emit("unload", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit("resize", this);\n    this._resourceId = (0,uid/* uid */.h)("resource");\n    this.emit("change", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don\'t want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit("updateMipmaps", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,pow2/* isPow2 */.wv)(this.pixelWidth) && (0,pow2/* isPow2 */.wv)(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error("Unimplemented");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: "bgra8unorm",\n  alphaMode: "premultiply-alpha-on-upload",\n  dimensions: "2d",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\n\n//# sourceMappingURL=TextureSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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IjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvZGVmaW5lZFByb3BzLm1qcz9iZGIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZVN0eWxlLm1qcz9mMDEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvc291cmNlcy9UZXh0dXJlU291cmNlLm1qcz8xZjk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZGVmaW5lZFByb3BzKG9iaikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGRlZmluZWRQcm9wcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmaW5lZFByb3BzLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpZEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlSWRGcm9tU3RyaW5nKHZhbHVlKSB7XG4gIGNvbnN0IGlkID0gaWRIYXNoW3ZhbHVlXTtcbiAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICBpZEhhc2hbdmFsdWVdID0gdWlkKFwicmVzb3VyY2VcIik7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuY29uc3QgX1RleHR1cmVTdHlsZSA9IGNsYXNzIF9UZXh0dXJlU3R5bGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgc3R5bGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJ0ZXh0dXJlU2FtcGxlclwiO1xuICAgIHRoaXMuX3RvdWNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbWF4aW11bSBhbmlzb3Ryb3B5IHZhbHVlIGNsYW1wIHVzZWQgYnkgdGhlIHNhbXBsZXIuXG4gICAgICogTm90ZTogTW9zdCBpbXBsZW1lbnRhdGlvbnMgc3VwcG9ydCB7QGxpbmsgR1BVU2FtcGxlckRlc2NyaXB0b3IjbWF4QW5pc290cm9weX0gdmFsdWVzIGluIHJhbmdlXG4gICAgICogYmV0d2VlbiAxIGFuZCAxNiwgaW5jbHVzaXZlLiBUaGUgdXNlZCB2YWx1ZSBvZiB7QGxpbmsgR1BVU2FtcGxlckRlc2NyaXB0b3IjbWF4QW5pc290cm9weX0gd2lsbFxuICAgICAqIGJlIGNsYW1wZWQgdG8gdGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgcGxhdGZvcm0gc3VwcG9ydHMuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX21heEFuaXNvdHJvcHkgPSAxO1xuICAgIG9wdGlvbnMgPSB7IC4uLl9UZXh0dXJlU3R5bGUuZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlID0gb3B0aW9ucy5hZGRyZXNzTW9kZTtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVSA9IG9wdGlvbnMuYWRkcmVzc01vZGVVID8/IHRoaXMuYWRkcmVzc01vZGVVO1xuICAgIHRoaXMuYWRkcmVzc01vZGVWID0gb3B0aW9ucy5hZGRyZXNzTW9kZVYgPz8gdGhpcy5hZGRyZXNzTW9kZVY7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVcgPSBvcHRpb25zLmFkZHJlc3NNb2RlVyA/PyB0aGlzLmFkZHJlc3NNb2RlVztcbiAgICB0aGlzLnNjYWxlTW9kZSA9IG9wdGlvbnMuc2NhbGVNb2RlO1xuICAgIHRoaXMubWFnRmlsdGVyID0gb3B0aW9ucy5tYWdGaWx0ZXIgPz8gdGhpcy5tYWdGaWx0ZXI7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciA/PyB0aGlzLm1pbkZpbHRlcjtcbiAgICB0aGlzLm1pcG1hcEZpbHRlciA9IG9wdGlvbnMubWlwbWFwRmlsdGVyID8/IHRoaXMubWlwbWFwRmlsdGVyO1xuICAgIHRoaXMubG9kTWluQ2xhbXAgPSBvcHRpb25zLmxvZE1pbkNsYW1wO1xuICAgIHRoaXMubG9kTWF4Q2xhbXAgPSBvcHRpb25zLmxvZE1heENsYW1wO1xuICAgIHRoaXMuY29tcGFyZSA9IG9wdGlvbnMuY29tcGFyZTtcbiAgICB0aGlzLm1heEFuaXNvdHJvcHkgPSBvcHRpb25zLm1heEFuaXNvdHJvcHkgPz8gMTtcbiAgfVxuICBzZXQgYWRkcmVzc01vZGUodmFsdWUpIHtcbiAgICB0aGlzLmFkZHJlc3NNb2RlVSA9IHZhbHVlO1xuICAgIHRoaXMuYWRkcmVzc01vZGVWID0gdmFsdWU7XG4gICAgdGhpcy5hZGRyZXNzTW9kZVcgPSB2YWx1ZTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IHdyYXBNb2RlVSx3cmFwTW9kZVYgYW5kIHdyYXBNb2RlVyBhbGwgYXQgb25jZSEgKi9cbiAgZ2V0IGFkZHJlc3NNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmFkZHJlc3NNb2RlVTtcbiAgfVxuICBzZXQgd3JhcE1vZGUodmFsdWUpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiVGV4dHVyZVN0eWxlLndyYXBNb2RlIGlzIG5vdyBUZXh0dXJlU3R5bGUuYWRkcmVzc01vZGVcIik7XG4gICAgdGhpcy5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCB3cmFwTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzTW9kZTtcbiAgfVxuICBzZXQgc2NhbGVNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5tYWdGaWx0ZXIgPSB2YWx1ZTtcbiAgICB0aGlzLm1pbkZpbHRlciA9IHZhbHVlO1xuICAgIHRoaXMubWlwbWFwRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIHNldHRpbmcgdGhpcyB3aWxsIHNldCBtYWdGaWx0ZXIsbWluRmlsdGVyIGFuZCBtaXBtYXBGaWx0ZXIgYWxsIGF0IG9uY2UhICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1hZ0ZpbHRlcjtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIGFuaXNvdHJvcHkgdmFsdWUgY2xhbXAgdXNlZCBieSB0aGUgc2FtcGxlci4gKi9cbiAgc2V0IG1heEFuaXNvdHJvcHkodmFsdWUpIHtcbiAgICB0aGlzLl9tYXhBbmlzb3Ryb3B5ID0gTWF0aC5taW4odmFsdWUsIDE2KTtcbiAgICBpZiAodGhpcy5fbWF4QW5pc290cm9weSA+IDEpIHtcbiAgICAgIHRoaXMuc2NhbGVNb2RlID0gXCJsaW5lYXJcIjtcbiAgICB9XG4gIH1cbiAgZ2V0IG1heEFuaXNvdHJvcHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heEFuaXNvdHJvcHk7XG4gIH1cbiAgLy8gVE9ETyAtIG1vdmUgdGhpcyB0byBXZWJHTD9cbiAgZ2V0IF9yZXNvdXJjZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGFyZWRSZXNvdXJjZUlkIHx8IHRoaXMuX2dlbmVyYXRlUmVzb3VyY2VJZCgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcyk7XG4gICAgdGhpcy5fc2hhcmVkUmVzb3VyY2VJZCA9IG51bGw7XG4gIH1cbiAgX2dlbmVyYXRlUmVzb3VyY2VJZCgpIHtcbiAgICBjb25zdCBiaWdLZXkgPSBgJHt0aGlzLmFkZHJlc3NNb2RlVX0tJHt0aGlzLmFkZHJlc3NNb2RlVn0tJHt0aGlzLmFkZHJlc3NNb2RlV30tJHt0aGlzLm1hZ0ZpbHRlcn0tJHt0aGlzLm1pbkZpbHRlcn0tJHt0aGlzLm1pcG1hcEZpbHRlcn0tJHt0aGlzLmxvZE1pbkNsYW1wfS0ke3RoaXMubG9kTWF4Q2xhbXB9LSR7dGhpcy5jb21wYXJlfS0ke3RoaXMuX21heEFuaXNvdHJvcHl9YDtcbiAgICB0aGlzLl9zaGFyZWRSZXNvdXJjZUlkID0gY3JlYXRlUmVzb3VyY2VJZEZyb21TdHJpbmcoYmlnS2V5KTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VJZDtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhlIHN0eWxlICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG59O1xuLyoqIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIHN0eWxlICovXG5fVGV4dHVyZVN0eWxlLmRlZmF1bHRPcHRpb25zID0ge1xuICBhZGRyZXNzTW9kZTogXCJjbGFtcC10by1lZGdlXCIsXG4gIHNjYWxlTW9kZTogXCJsaW5lYXJcIlxufTtcbmxldCBUZXh0dXJlU3R5bGUgPSBfVGV4dHVyZVN0eWxlO1xuXG5leHBvcnQgeyBUZXh0dXJlU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgaXNQb3cyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vbWF0aHMvbWlzYy9wb3cyLm1qcyc7XG5pbXBvcnQgeyBkZWZpbmVkUHJvcHMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zY2VuZS9jb250YWluZXIvdXRpbHMvZGVmaW5lZFByb3BzLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVN0eWxlIH0gZnJvbSAnLi4vVGV4dHVyZVN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1RleHR1cmVTb3VyY2UgPSBjbGFzcyBfVGV4dHVyZVNvdXJjZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgbmV3IFRleHR1cmVTb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvKiogdW5pcXVlIGlkIGZvciB0aGlzIFRleHR1cmUgc291cmNlICovXG4gICAgdGhpcy51aWQgPSB1aWQoXCJ0ZXh0dXJlU291cmNlXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNvdXJjZSB0eXBlIHVzZWQgYnkgdGhpcyBUZXh0dXJlU291cmNlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIGJpbmQgZ3JvdXBzIHRvIGRldGVybWluZVxuICAgICAqIGhvdyB0byBoYW5kbGUgdGhpcyByZXNvdXJjZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fcmVzb3VyY2VUeXBlID0gXCJ0ZXh0dXJlU291cmNlXCI7XG4gICAgLyoqXG4gICAgICogaSB1bmlxdWUgcmVzb3VyY2UgaWQsIHVzZWQgYnkgdGhlIGJpbmQgZ3JvdXAgc3lzdGVtcy5cbiAgICAgKiBUaGlzIGNhbiBjaGFuZ2UgaWYgdGhlIHRleHR1cmUgaXMgcmVzaXplZCBvciBpdHMgcmVzb3VyY2UgY2hhbmdlc1xuICAgICAqL1xuICAgIHRoaXMuX3Jlc291cmNlSWQgPSB1aWQoXCJyZXNvdXJjZVwiKTtcbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGhvdyB0aGUgYmFja2VuZHMga25vdyBob3cgdG8gdXBsb2FkIHRoaXMgdGV4dHVyZSB0byB0aGUgR1BVXG4gICAgICogSXQgY2hhbmdlcyBkZXBlbmRpbmcgb24gdGhlIHJlc291cmNlIHR5cGUuIENsYXNzZXMgdGhhdCBleHRlbmQgVGV4dHVyZVNvdXJjZVxuICAgICAqIHNob3VsZCBvdmVycmlkZSB0aGlzIHByb3BlcnR5LlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gXCJ1bmtub3duXCI7XG4gICAgLy8gZGltZW5zaW9uc1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSAxO1xuICAgIC8qKiB0aGUgcGl4ZWwgd2lkdGggb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZS4gVGhpcyBpcyB0aGUgUkVBTCBwdXJlIG51bWJlciwgbm90IGFjY291bnRpbmcgcmVzb2x1dGlvbiAqL1xuICAgIHRoaXMucGl4ZWxXaWR0aCA9IDE7XG4gICAgLyoqIHRoZSBwaXhlbCBoZWlnaHQgb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZS4gVGhpcyBpcyB0aGUgUkVBTCBwdXJlIG51bWJlciwgbm90IGFjY291bnRpbmcgcmVzb2x1dGlvbiAqL1xuICAgIHRoaXMucGl4ZWxIZWlnaHQgPSAxO1xuICAgIC8qKlxuICAgICAqIHRoZSB3aWR0aCBvZiB0aGlzIHRleHR1cmUgc291cmNlLCBhY2NvdW50aW5nIGZvciByZXNvbHV0aW9uXG4gICAgICogZWcgcGl4ZWxXaWR0aCAyMDAsIHJlc29sdXRpb24gMiwgdGhlbiB3aWR0aCB3aWxsIGJlIDEwMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIC8qKlxuICAgICAqIHRoZSBoZWlnaHQgb2YgdGhpcyB0ZXh0dXJlIHNvdXJjZSwgYWNjb3VudGluZyBmb3IgcmVzb2x1dGlvblxuICAgICAqIGVnIHBpeGVsSGVpZ2h0IDIwMCwgcmVzb2x1dGlvbiAyLCB0aGVuIGhlaWdodCB3aWxsIGJlIDEwMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgb2YgYSBtdWx0aXNhbXBsZSB0ZXh0dXJlLiBUaGlzIGlzIGFsd2F5cyAxIGZvciBub24tbXVsdGlzYW1wbGUgdGV4dHVyZXMuXG4gICAgICogVG8gZW5hYmxlIG11bHRpc2FtcGxlIGZvciBhIHRleHR1cmUsIHNldCBhbnRpYWxpYXMgdG8gdHJ1ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLnNhbXBsZUNvdW50ID0gMTtcbiAgICAvKiogVGhlIG51bWJlciBvZiBtaXAgbGV2ZWxzIHRvIGdlbmVyYXRlIGZvciB0aGlzIHRleHR1cmUuIHRoaXMgaXMgIG92ZXJyaWRkZW4gaWYgYXV0b0dlbmVyYXRlTWlwbWFwcyBpcyB0cnVlICovXG4gICAgdGhpcy5taXBMZXZlbENvdW50ID0gMTtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgd2UgYXV0byBnZW5lcmF0ZSBtaXBtYXBzIGZvciB0aGlzIHRleHR1cmU/IFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIG1pcG1hcHNcbiAgICAgKiBmb3IgdGhpcyB0ZXh0dXJlIHdoZW4gdXBsb2FkaW5nIHRvIHRoZSBHUFUuIE1pcG1hcHBlZCB0ZXh0dXJlcyB0YWtlIHVwIG1vcmUgbWVtb3J5LCBidXRcbiAgICAgKiBjYW4gbG9vayBiZXR0ZXIgd2hlbiBzY2FsZWQgZG93bi5cbiAgICAgKlxuICAgICAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyByZWNvbW1lbmRlZCB0byBOT1QgdXNlIHRoaXMgd2l0aCBSZW5kZXJUZXh0dXJlcywgYXMgdGhleSBhcmUgb2Z0ZW4gdXBkYXRlZCBldmVyeSBmcmFtZS5cbiAgICAgKiBJZiB5b3UgZG8sIG1ha2Ugc3VyZSB0byBjYWxsIGB1cGRhdGVNaXBtYXBzYCBhZnRlciB5b3UgdXBkYXRlIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHRoaXMuYXV0b0dlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIC8qKiB0aGUgZm9ybWF0IHRoYXQgdGhlIHRleHR1cmUgZGF0YSBoYXMgKi9cbiAgICB0aGlzLmZvcm1hdCA9IFwicmdiYTh1bm9ybVwiO1xuICAgIC8qKiBob3cgbWFueSBkaW1lbnNpb25zIGRvZXMgdGhpcyB0ZXh0dXJlIGhhdmU/IGN1cnJlbnRseSB2OCBvbmx5IHN1cHBvcnRzIDJkICovXG4gICAgdGhpcy5kaW1lbnNpb24gPSBcIjJkXCI7XG4gICAgLyoqXG4gICAgICogT25seSByZWFsbHkgYWZmZWN0cyBSZW5kZXJUZXh0dXJlcy5cbiAgICAgKiBTaG91bGQgd2UgdXNlIGFudGlhbGlhc2luZyBmb3IgdGhpcyB0ZXh0dXJlLiBJdCB3aWxsIGxvb2sgYmV0dGVyLCBidXQgbWF5IGltcGFjdCBwZXJmb3JtYW5jZSBhcyBhXG4gICAgICogQmxpdCBvcGVyYXRpb24gd2lsbCBiZSByZXF1aXJlZCB0byByZXNvbHZlIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHRoaXMuYW50aWFsaWFzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBhdXRvbWF0aWMgdGV4dHVyZSBHYXJiYWdlIENvbGxlY3Rpb24sIHN0b3JlcyBsYXN0IEdDIHRpY2sgd2hlbiBpdCB3YXMgYm91bmRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fdG91Y2hlZCA9IDA7XG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgYmF0Y2hlciB0byBidWlsZCB0ZXh0dXJlIGJhdGNoZXMuIGZhc3RlciB0byBoYXZlIHRoZSB2YXJpYWJsZSBoZXJlIVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9iYXRjaFRpY2sgPSAtMTtcbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSBiYXRjaCBsb2NhdGlvbiBmb3IgdGhlIHRleHR1cmUgYmF0Y2hpbmcuIEhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgb25seSFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fdGV4dHVyZUJpbmRMb2NhdGlvbiA9IC0xO1xuICAgIG9wdGlvbnMgPSB7IC4uLl9UZXh0dXJlU291cmNlLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5sYWJlbCA9IG9wdGlvbnMubGFiZWwgPz8gXCJcIjtcbiAgICB0aGlzLnJlc291cmNlID0gb3B0aW9ucy5yZXNvdXJjZTtcbiAgICB0aGlzLmF1dG9HYXJiYWdlQ29sbGVjdCA9IG9wdGlvbnMuYXV0b0dhcmJhZ2VDb2xsZWN0O1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHRoaXMucGl4ZWxXaWR0aCA9IG9wdGlvbnMud2lkdGggKiB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpeGVsV2lkdGggPSB0aGlzLnJlc291cmNlID8gdGhpcy5yZXNvdXJjZVdpZHRoID8/IDEgOiAxO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIHRoaXMucGl4ZWxIZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGl4ZWxIZWlnaHQgPSB0aGlzLnJlc291cmNlID8gdGhpcy5yZXNvdXJjZUhlaWdodCA/PyAxIDogMTtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucGl4ZWxXaWR0aCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBpeGVsSGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgIHRoaXMuZGltZW5zaW9uID0gb3B0aW9ucy5kaW1lbnNpb25zO1xuICAgIHRoaXMubWlwTGV2ZWxDb3VudCA9IG9wdGlvbnMubWlwTGV2ZWxDb3VudDtcbiAgICB0aGlzLmF1dG9HZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmF1dG9HZW5lcmF0ZU1pcG1hcHM7XG4gICAgdGhpcy5zYW1wbGVDb3VudCA9IG9wdGlvbnMuc2FtcGxlQ291bnQ7XG4gICAgdGhpcy5hbnRpYWxpYXMgPSBvcHRpb25zLmFudGlhbGlhcztcbiAgICB0aGlzLmFscGhhTW9kZSA9IG9wdGlvbnMuYWxwaGFNb2RlO1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgVGV4dHVyZVN0eWxlKGRlZmluZWRQcm9wcyhvcHRpb25zKSk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gIH1cbiAgLyoqIHJldHVybnMgaXRzZWxmICovXG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIHRoZSBzdHlsZSBvZiB0aGUgdGV4dHVyZSAqL1xuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0eWxlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zdHlsZT8ub2ZmKFwiY2hhbmdlXCIsIHRoaXMuX29uU3R5bGVDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMuX3N0eWxlID0gdmFsdWU7XG4gICAgdGhpcy5fc3R5bGU/Lm9uKFwiY2hhbmdlXCIsIHRoaXMuX29uU3R5bGVDaGFuZ2UsIHRoaXMpO1xuICAgIHRoaXMuX29uU3R5bGVDaGFuZ2UoKTtcbiAgfVxuICAvKiogc2V0dGluZyB0aGlzIHdpbGwgc2V0IHdyYXBNb2RlVSx3cmFwTW9kZVYgYW5kIHdyYXBNb2RlVyBhbGwgYXQgb25jZSEgKi9cbiAgZ2V0IGFkZHJlc3NNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZTtcbiAgfVxuICBzZXQgYWRkcmVzc01vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBzZXR0aW5nIHRoaXMgd2lsbCBzZXQgd3JhcE1vZGVVLHdyYXBNb2RlViBhbmQgd3JhcE1vZGVXIGFsbCBhdCBvbmNlISAqL1xuICBnZXQgcmVwZWF0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUuYWRkcmVzc01vZGU7XG4gIH1cbiAgc2V0IHJlcGVhdE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5hZGRyZXNzTW9kZSA9IHZhbHVlO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIHNhbXBsaW5nIGJlaGF2aW9yIHdoZW4gdGhlIHNhbXBsZSBmb290cHJpbnQgaXMgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIG9uZSB0ZXhlbC4gKi9cbiAgZ2V0IG1hZ0ZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubWFnRmlsdGVyO1xuICB9XG4gIHNldCBtYWdGaWx0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIHRoZSBzYW1wbGluZyBiZWhhdmlvciB3aGVuIHRoZSBzYW1wbGUgZm9vdHByaW50IGlzIGxhcmdlciB0aGFuIG9uZSB0ZXhlbC4gKi9cbiAgZ2V0IG1pbkZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubWluRmlsdGVyO1xuICB9XG4gIHNldCBtaW5GaWx0ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5taW5GaWx0ZXIgPSB2YWx1ZTtcbiAgfVxuICAvKiogU3BlY2lmaWVzIGJlaGF2aW9yIGZvciBzYW1wbGluZyBiZXR3ZWVuIG1pcG1hcCBsZXZlbHMuICovXG4gIGdldCBtaXBtYXBGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlLm1pcG1hcEZpbHRlcjtcbiAgfVxuICBzZXQgbWlwbWFwRmlsdGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubWlwbWFwRmlsdGVyID0gdmFsdWU7XG4gIH1cbiAgLyoqIFNwZWNpZmllcyB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZXZlbHMgb2YgZGV0YWlsLCByZXNwZWN0aXZlbHksIHVzZWQgaW50ZXJuYWxseSB3aGVuIHNhbXBsaW5nIGEgdGV4dHVyZS4gKi9cbiAgZ2V0IGxvZE1pbkNsYW1wKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5sb2RNaW5DbGFtcDtcbiAgfVxuICBzZXQgbG9kTWluQ2xhbXAodmFsdWUpIHtcbiAgICB0aGlzLl9zdHlsZS5sb2RNaW5DbGFtcCA9IHZhbHVlO1xuICB9XG4gIC8qKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGV2ZWxzIG9mIGRldGFpbCwgcmVzcGVjdGl2ZWx5LCB1c2VkIGludGVybmFsbHkgd2hlbiBzYW1wbGluZyBhIHRleHR1cmUuICovXG4gIGdldCBsb2RNYXhDbGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGUubG9kTWF4Q2xhbXA7XG4gIH1cbiAgc2V0IGxvZE1heENsYW1wKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUubG9kTWF4Q2xhbXAgPSB2YWx1ZTtcbiAgfVxuICBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICB0aGlzLmVtaXQoXCJzdHlsZUNoYW5nZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogY2FsbCB0aGlzIGlmIHlvdSBoYXZlIG1vZGlmaWVkIHRoZSB0ZXh0dXJlIG91dHNpZGUgb2YgdGhlIGNvbnN0cnVjdG9yICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuX3Jlc29sdXRpb247XG4gICAgICBjb25zdCBkaWRSZXNpemUgPSB0aGlzLnJlc2l6ZSh0aGlzLnJlc291cmNlV2lkdGggLyByZXNvbHV0aW9uLCB0aGlzLnJlc291cmNlSGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgICBpZiAoZGlkUmVzaXplKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICAvKiogRGVzdHJveXMgdGhpcyB0ZXh0dXJlIHNvdXJjZSAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIHRoaXMpO1xuICAgIGlmICh0aGlzLl9zdHlsZSkge1xuICAgICAgdGhpcy5fc3R5bGUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnVwbG9hZE1ldGhvZElkID0gbnVsbDtcbiAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgdW5sb2FkIHRoZSBUZXh0dXJlIHNvdXJjZSBmcm9tIHRoZSBHUFUuIFRoaXMgd2lsbCBmcmVlIHVwIHRoZSBHUFUgbWVtb3J5XG4gICAqIEFzIHNvb24gYXMgaXQgaXMgcmVxdWlyZWQgZm9yZSByZW5kZXJpbmcsIGl0IHdpbGwgYmUgcmUtdXBsb2FkZWQuXG4gICAqL1xuICB1bmxvYWQoKSB7XG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJ1bmxvYWRcIiwgdGhpcyk7XG4gIH1cbiAgLyoqIHRoZSB3aWR0aCBvZiB0aGUgcmVzb3VyY2UuIFRoaXMgaXMgdGhlIFJFQUwgcHVyZSBudW1iZXIsIG5vdCBhY2NvdW50aW5nIHJlc29sdXRpb24gICAqL1xuICBnZXQgcmVzb3VyY2VXaWR0aCgpIHtcbiAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzO1xuICAgIHJldHVybiByZXNvdXJjZS5uYXR1cmFsV2lkdGggfHwgcmVzb3VyY2UudmlkZW9XaWR0aCB8fCByZXNvdXJjZS5kaXNwbGF5V2lkdGggfHwgcmVzb3VyY2Uud2lkdGg7XG4gIH1cbiAgLyoqIHRoZSBoZWlnaHQgb2YgdGhlIHJlc291cmNlLiBUaGlzIGlzIHRoZSBSRUFMIHB1cmUgbnVtYmVyLCBub3QgYWNjb3VudGluZyByZXNvbHV0aW9uICovXG4gIGdldCByZXNvdXJjZUhlaWdodCgpIHtcbiAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzO1xuICAgIHJldHVybiByZXNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHJlc291cmNlLnZpZGVvSGVpZ2h0IHx8IHJlc291cmNlLmRpc3BsYXlIZWlnaHQgfHwgcmVzb3VyY2UuaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS4gQ2hhbmdpbmcgdGhpcyBudW1iZXIsIHdpbGwgbm90IGNoYW5nZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGUgYWN0dWFsIHRleHR1cmVcbiAgICogYnV0IHdpbGwgdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgd2hlbiByZW5kZXJlZC5cbiAgICpcbiAgICogY2hhbmdpbmcgdGhlIHJlc29sdXRpb24gb2YgdGhpcyB0ZXh0dXJlIHRvIDIgZm9yIGV4YW1wbGUgd2lsbCBtYWtlIGl0IGFwcGVhciB0d2ljZSBhcyBzbWFsbCB3aGVuIHJlbmRlcmVkIChhcyBwaXhlbFxuICAgKiBkZW5zaXR5IHdpbGwgaGF2ZSBpbmNyZWFzZWQpXG4gICAqL1xuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdXRpb24gPT09IHJlc29sdXRpb24pXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucGl4ZWxXaWR0aCAvIHJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBpeGVsSGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHRoZSB0ZXh0dXJlLCB0aGlzIGlzIGhhbmR5IGlmIHlvdSB3YW50IHRvIHVzZSB0aGUgdGV4dHVyZSBhcyBhIHJlbmRlciB0ZXh0dXJlXG4gICAqIEBwYXJhbSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICogQHBhcmFtIGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSByZXNvbHV0aW9uIC0gdGhlIG5ldyByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlXG4gICAqIEByZXR1cm5zIC0gaWYgdGhlIHRleHR1cmUgd2FzIHJlc2l6ZWRcbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG5ld1BpeGVsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgbmV3UGl4ZWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHJlc29sdXRpb24pO1xuICAgIHRoaXMud2lkdGggPSBuZXdQaXhlbFdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1BpeGVsSGVpZ2h0IC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLl9yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBpZiAodGhpcy5waXhlbFdpZHRoID09PSBuZXdQaXhlbFdpZHRoICYmIHRoaXMucGl4ZWxIZWlnaHQgPT09IG5ld1BpeGVsSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICB0aGlzLnBpeGVsV2lkdGggPSBuZXdQaXhlbFdpZHRoO1xuICAgIHRoaXMucGl4ZWxIZWlnaHQgPSBuZXdQaXhlbEhlaWdodDtcbiAgICB0aGlzLmVtaXQoXCJyZXNpemVcIiwgdGhpcyk7XG4gICAgdGhpcy5fcmVzb3VyY2VJZCA9IHVpZChcInJlc291cmNlXCIpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogTGV0cyB0aGUgcmVuZGVyZXIga25vdyB0aGF0IHRoaXMgdGV4dHVyZSBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgbWlwbWFwcyBzaG91bGQgYmUgcmUtZ2VuZXJhdGVkLlxuICAgKiBUaGlzIGlzIG9ubHkgaW1wb3J0YW50IGZvciBSZW5kZXJUZXh0dXJlIGluc3RhbmNlcywgYXMgc3RhbmRhcmQgVGV4dHVyZSBpbnN0YW5jZXMgd2lsbCBoYXZlIHRoZWlyXG4gICAqIG1pcG1hcHMgZ2VuZXJhdGVkIG9uIHVwbG9hZC4gWW91IHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGFmdGVyIHlvdSBtYWtlIGFueSBjaGFuZ2UgdG8gdGhlIHRleHR1cmVcbiAgICpcbiAgICogVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyBpcyBjYW4gYmUgcXVpdGUgZXhwZW5zaXZlIHRvIHVwZGF0ZSBtaXBtYXBzIGZvciBhIHRleHR1cmUuIFNvIGJ5IGRlZmF1bHQsXG4gICAqIFdlIHdhbnQgeW91LCB0aGUgZGV2ZWxvcGVyIHRvIHNwZWNpZnkgd2hlbiB0aGlzIGFjdGlvbiBzaG91bGQgaGFwcGVuLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgeW91IGRvbid0IHdhbnQgdG8gaGF2ZSBtaXBtYXBzIGdlbmVyYXRlZCBvbiBSZW5kZXIgdGFyZ2V0cyB0aGF0IGFyZSBjaGFuZ2VkIGV2ZXJ5IGZyYW1lLFxuICAgKi9cbiAgdXBkYXRlTWlwbWFwcygpIHtcbiAgICBpZiAodGhpcy5hdXRvR2VuZXJhdGVNaXBtYXBzICYmIHRoaXMubWlwTGV2ZWxDb3VudCA+IDEpIHtcbiAgICAgIHRoaXMuZW1pdChcInVwZGF0ZU1pcG1hcHNcIiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHNldCB3cmFwTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0eWxlLndyYXBNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHdyYXBNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS53cmFwTW9kZTtcbiAgfVxuICBzZXQgc2NhbGVNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3R5bGUuc2NhbGVNb2RlID0gdmFsdWU7XG4gIH1cbiAgLyoqIHNldHRpbmcgdGhpcyB3aWxsIHNldCBtYWdGaWx0ZXIsbWluRmlsdGVyIGFuZCBtaXBtYXBGaWx0ZXIgYWxsIGF0IG9uY2UhICAqL1xuICBnZXQgc2NhbGVNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZS5zY2FsZU1vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2ggY2hlY2sgZm9yIGlzUG93ZXJPZlR3byB0ZXh0dXJlIGJhc2VkIG9uIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWZyZXNoUE9UKCkge1xuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gaXNQb3cyKHRoaXMucGl4ZWxXaWR0aCkgJiYgaXNQb3cyKHRoaXMucGl4ZWxIZWlnaHQpO1xuICB9XG4gIHN0YXRpYyB0ZXN0KF9yZXNvdXJjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWRcIik7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgb3B0aW9ucyB1c2VkIHdoZW4gY3JlYXRpbmcgYSBuZXcgVGV4dHVyZVNvdXJjZS4gb3ZlcnJpZGUgdGhlc2UgdG8gYWRkIHlvdXIgb3duIGRlZmF1bHRzICovXG5fVGV4dHVyZVNvdXJjZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgZm9ybWF0OiBcImJncmE4dW5vcm1cIixcbiAgYWxwaGFNb2RlOiBcInByZW11bHRpcGx5LWFscGhhLW9uLXVwbG9hZFwiLFxuICBkaW1lbnNpb25zOiBcIjJkXCIsXG4gIG1pcExldmVsQ291bnQ6IDEsXG4gIGF1dG9HZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICBzYW1wbGVDb3VudDogMSxcbiAgYW50aWFsaWFzOiBmYWxzZSxcbiAgYXV0b0dhcmJhZ2VDb2xsZWN0OiBmYWxzZVxufTtcbmxldCBUZXh0dXJlU291cmNlID0gX1RleHR1cmVTb3VyY2U7XG5cbmV4cG9ydCB7IFRleHR1cmVTb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVTb3VyY2UubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5206\n')},4325:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* unused harmony exports autoDetectSource, resourceToTexture, textureFrom */\n/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4162);\n/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3489);\n/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5206);\n/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9853);\n\n\n\n\n\n"use strict";\nconst sources = [];\n_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .extensions */ .Rw.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ExtensionType */ .nw.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(resource);\n  }\n  const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: autoDetectSource(opts) });\n  texture.on("destroy", () => {\n    if (_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.has(resource)) {\n      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === "string") {\n    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Cache */ .C.get(id);\n  } else if (id instanceof _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__/* .TextureSource */ .p) {\n    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\n_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Texture */ .x.from = textureFrom;\n\n\n//# sourceMappingURL=textureFrom.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMyNS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RDtBQUN1QjtBQUN4QjtBQUNwQjs7QUFFekM7QUFDQTtBQUNBLDRFQUFVLGNBQWMsK0VBQWE7QUFDckMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQkFBb0IsbUVBQUs7QUFDekIsV0FBVyxtRUFBSztBQUNoQjtBQUNBLHNCQUFzQiwwREFBTyxHQUFHLGdDQUFnQztBQUNoRTtBQUNBLFFBQVEsbUVBQUs7QUFDYixNQUFNLG1FQUFLO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLG1FQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQUs7QUFDaEIsSUFBSSx1QkFBdUIsOEVBQWE7QUFDeEMsZUFBZSwwREFBTyxHQUFHLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMERBQU87O0FBRXFEO0FBQzVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS91dGlscy90ZXh0dXJlRnJvbS5tanM/YWU5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgZXh0ZW5zaW9ucywgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVNvdXJjZSB9IGZyb20gJy4uL3NvdXJjZXMvVGV4dHVyZVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL1RleHR1cmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzb3VyY2VzID0gW107XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLlRleHR1cmVTb3VyY2UsIHNvdXJjZXMpO1xuZnVuY3Rpb24gYXV0b0RldGVjdFNvdXJjZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaGFzUmVzb3VyY2UgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzb3VyY2U7XG4gIGNvbnN0IHJlcyA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKFNvdXJjZS50ZXN0KHJlcykpIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlKG9wdHMpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgc291cmNlIHR5cGUgZm9yIHJlc291cmNlOiAke29wdHMucmVzb3VyY2V9YCk7XG59XG5mdW5jdGlvbiByZXNvdXJjZVRvVGV4dHVyZShvcHRpb25zID0ge30sIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGhhc1Jlc291cmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc291cmNlO1xuICBjb25zdCByZXNvdXJjZSA9IGhhc1Jlc291cmNlID8gb3B0aW9ucy5yZXNvdXJjZSA6IG9wdGlvbnM7XG4gIGNvbnN0IG9wdHMgPSBoYXNSZXNvdXJjZSA/IG9wdGlvbnMgOiB7IHJlc291cmNlOiBvcHRpb25zIH07XG4gIGlmICghc2tpcENhY2hlICYmIENhY2hlLmhhcyhyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gQ2FjaGUuZ2V0KHJlc291cmNlKTtcbiAgfVxuICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoeyBzb3VyY2U6IGF1dG9EZXRlY3RTb3VyY2Uob3B0cykgfSk7XG4gIHRleHR1cmUub24oXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICBpZiAoQ2FjaGUuaGFzKHJlc291cmNlKSkge1xuICAgICAgQ2FjaGUucmVtb3ZlKHJlc291cmNlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXNraXBDYWNoZSkge1xuICAgIENhY2hlLnNldChyZXNvdXJjZSwgdGV4dHVyZSk7XG4gIH1cbiAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiB0ZXh0dXJlRnJvbShpZCwgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgaWYgKHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBDYWNoZS5nZXQoaWQpO1xuICB9IGVsc2UgaWYgKGlkIGluc3RhbmNlb2YgVGV4dHVyZVNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZSh7IHNvdXJjZTogaWQgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc291cmNlVG9UZXh0dXJlKGlkLCBza2lwQ2FjaGUpO1xufVxuVGV4dHVyZS5mcm9tID0gdGV4dHVyZUZyb207XG5cbmV4cG9ydCB7IGF1dG9EZXRlY3RTb3VyY2UsIHJlc291cmNlVG9UZXh0dXJlLCB0ZXh0dXJlRnJvbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZUZyb20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4325\n')},8400:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  W2: () => (/* binding */ Container),\n  pA: () => (/* binding */ UPDATE_BLEND),\n  wO: () => (/* binding */ UPDATE_COLOR),\n  Jm: () => (/* binding */ UPDATE_VISIBLE)\n});\n\n// UNUSED EXPORTS: UPDATE_TRANSFORM\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/culling/cullingMixin.mjs\n\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\n\n//# sourceMappingURL=cullingMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/const.mjs\nvar misc_const = __webpack_require__(5502);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs\nvar ObservablePoint = __webpack_require__(4973);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/removeItems.mjs\nvar removeItems = __webpack_require__(7040);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs\n\n\n\n"use strict";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        if (this.renderGroup) {\n          this.renderGroup.removeChild(child);\n        }\n        removed.push(child);\n        child.parent = null;\n      }\n      (0,removeItems/* removeItems */.E)(this.children, beginIndex, end);\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit("childRemoved", removed[i], this, i);\n        removed[i].emit("removed", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied Container must be a child of the caller");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChildAt: Only Containers will be allowed to add children in v8.0.0");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit("childAdded", child, this, index);\n    child.emit("added", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n};\n\n\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/filters/FilterEffect.mjs\nvar FilterEffect = __webpack_require__(6282);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs\n\n\n\n"use strict";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return PoolGroup/* BigPool */.u.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    PoolGroup/* BigPool */.u.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nExtensions/* extensions */.Rw.handleByList(Extensions/* ExtensionType */.nw.MaskEffect, MaskEffectManager._effectClasses);\n\n\n//# sourceMappingURL=MaskEffectManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs\n\n\n\n\n"use strict";\nconst effectsMixin = {\n  _mask: null,\n  _filters: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    if (this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (!this.isRenderGroupRoot && this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    this._mask || (this._mask = { mask: null, effect: null });\n    if (this._mask.mask === value)\n      return;\n    if (this._mask.effect) {\n      this.removeEffect(this._mask.effect);\n      MaskEffectManager.returnMaskEffect(this._mask.effect);\n      this._mask.effect = null;\n    }\n    this._mask.mask = value;\n    if (value === null || value === void 0)\n      return;\n    const effect = MaskEffectManager.getMaskEffect(value);\n    this._mask.effect = effect;\n    this.addEffect(effect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container\'s width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from \'pixi.js\';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._mask?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    value = value;\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    const hasFilters = value?.length > 0;\n    const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    this._filters.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        const effect = PoolGroup/* BigPool */.u.get(FilterEffect/* FilterEffect */.U);\n        this._filters.effect = effect;\n        this.addEffect(effect);\n      } else {\n        const effect = this._filters.effect;\n        this.removeEffect(effect);\n        effect.filterArea = null;\n        effect.filters = null;\n        this._filters.effect = null;\n        PoolGroup/* BigPool */.u.return(effect);\n      }\n    }\n    if (hasFilters) {\n      this._filters.effect.filters = value;\n      this._filters.effect.filterArea = this.filterArea;\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `\'null\'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filters?.filters;\n  },\n  set filterArea(value) {\n    this._filters || (this._filters = { filters: null, effect: null, filterArea: null });\n    this._filters.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filters?.filterArea;\n  }\n};\n\n\n//# sourceMappingURL=effectsMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs\n\n\n"use strict";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    return this.label;\n  },\n  set name(value) {\n    (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "Container.name property has been removed, use Container.label instead");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\n\n//# sourceMappingURL=findMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs\nvar getGlobalBounds = __webpack_require__(5128);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs\nvar getLocalBounds = __webpack_require__(3197);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs\n\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const changeId = (child.uid & 255) << 24 | child._didChangeId & 16777215;\n    if (previousData.data[previousData.index] !== changeId) {\n      previousData.data[previousData.index] = changeId;\n      previousData.didChange = true;\n    }\n    previousData.index++;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\n\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs\n\n\n\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds/* Bounds */.Y()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didChangeId >> 12) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didChangeId >> 12;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      (0,getLocalBounds/* getLocalBounds */.a)(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return (0,getGlobalBounds/* getGlobalBounds */.qW)(this, skipUpdate, bounds || new Bounds/* Bounds */.Y());\n  }\n};\n\n\n//# sourceMappingURL=measureMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs\n\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and "updateTransform" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\n\n//# sourceMappingURL=onRenderMixin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs\n\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child\'s zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\n\n//# sourceMappingURL=sortMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs\n\n\n\n\n"use strict";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point/* Point */.E(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = (0,getGlobalBounds/* updateTransformBackwards */.I_)(this, new Matrix/* Matrix */.y());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\n\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs\n\n\n\n"use strict";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = "renderGroup";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this._children = [];\n    this.worldTransform = new Matrix/* Matrix */.y();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet/* InstructionSet */.h();\n    this._onRenderContainers = [];\n    this.root = root;\n    this.addChild(root);\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.onChildUpdate(renderGroupChild.root);\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.root.didChange) {\n      this._removeChildFromUpdate(renderGroupChild.root);\n    }\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    if (child !== this.root) {\n      this._children.push(child);\n      child.updateTick = -1;\n      if (child.parent === this.root) {\n        child.relativeRenderGroupDepth = 1;\n      } else {\n        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n      }\n      if (child._onRender) {\n        this.addOnRender(child);\n      }\n    }\n    if (child.renderGroup) {\n      if (child.renderGroup.root === child) {\n        this.addRenderGroupChild(child.renderGroup);\n        return;\n      }\n    } else {\n      child.renderGroup = this;\n      child.didChange = true;\n    }\n    const children = child.children;\n    if (!child.isRenderGroupRoot) {\n      this.onChildUpdate(child);\n    }\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      this.removeOnRender(child);\n    }\n    if (child.renderGroup.root !== child) {\n      const children = child.children;\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      if (child.didChange) {\n        child.renderGroup._removeChildFromUpdate(child);\n      }\n      child.renderGroup = null;\n    } else {\n      this._removeRenderGroupChild(child.renderGroup);\n    }\n    const index = this._children.indexOf(child);\n    if (index > -1) {\n      this._children.splice(index, 1);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  _removeChildFromUpdate(child) {\n    const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      return;\n    }\n    const index = childrenToUpdate.list.indexOf(child);\n    if (index > -1) {\n      childrenToUpdate.list.splice(index, 1);\n    }\n    childrenToUpdate.index--;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined \'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n}\n\n\n//# sourceMappingURL=RenderGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs\n\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\n\n//# sourceMappingURL=assignWithIgnore.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/Container.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst defaultSkew = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultPivot = new ObservablePoint/* ObservablePoint */.A(null);\nconst defaultScale = new ObservablePoint/* ObservablePoint */.A(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends eventemitter3/* default */.Z {\n  constructor(options = {}) {\n    super();\n    /** @private */\n    this.uid = (0,uid/* uid */.h)("renderable");\n    /** @private */\n    this._updateFlags = 15;\n    // is this container the root of a renderGroup?\n    // TODO implement this in a few more places\n    /** @private */\n    this.isRenderGroupRoot = false;\n    // the render group this container belongs to OR owns\n    /** @private */\n    this.renderGroup = null;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix/* Matrix */.y();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix/* Matrix */.y();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = "inherit";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = "normal";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = renderable, 1 = not renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the container is modified\n     * the first 12 bits represent the container changes (eg transform, alpha, visible etc)\n     * the second 12 bits represent the view changes (eg texture swap, geometry change etc)\n     *\n     *  view          container\n     * [000000000000][00000000000]\n     * @ignore\n     */\n    this._didChangeId = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    this.effects = [];\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "addChild: Only Containers will be allowed to add children in v8.0.0");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.renderGroup && !this.isRenderGroupRoot) {\n        this.renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    if (this.renderGroup) {\n      this.renderGroup.addChild(child);\n    }\n    this.emit("childAdded", child, this, this.children.length - 1);\n    child.emit("added", this);\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit("childRemoved", child, this, index);\n      child.emit("removed", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didChangeId++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.isRenderGroupRoot) {\n      const renderGroupParent = this.renderGroup.renderGroupParent;\n      if (renderGroupParent) {\n        renderGroupParent.onChildUpdate(this);\n      }\n    } else if (this.renderGroup) {\n      this.renderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (this.isRenderGroupRoot && value === false) {\n      throw new Error("[Pixi] cannot undo a render group just yet");\n    }\n    if (value) {\n      this.enableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return this.isRenderGroupRoot;\n  }\n  /** This enables the container to be rendered as a render group. */\n  enableRenderGroup() {\n    if (this.renderGroup && this.renderGroup.root === this)\n      return;\n    this.isRenderGroupRoot = true;\n    const parentRenderGroup = this.renderGroup;\n    if (parentRenderGroup) {\n      parentRenderGroup.removeChild(this);\n    }\n    this.renderGroup = new RenderGroup(this);\n    if (parentRenderGroup) {\n      for (let i = 0; i < parentRenderGroup.renderGroupChildren.length; i++) {\n        const childRenderGroup = parentRenderGroup.renderGroupChildren[i];\n        let parent = childRenderGroup.root;\n        while (parent) {\n          if (parent === this) {\n            this.renderGroup.addRenderGroupChild(childRenderGroup);\n            break;\n          }\n          parent = parent.parent;\n        }\n      }\n      parentRenderGroup.addRenderGroupChild(this.renderGroup);\n    }\n    this._updateIsSimple();\n    this.groupTransform = Matrix/* Matrix */.y.IDENTITY;\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.isRenderGroupRoot && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix/* Matrix */.y());\n    if (this.renderGroup) {\n      if (this.isRenderGroupRoot) {\n        this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n      } else {\n        this._worldTransform.appendFrom(this.relativeGroupTransform, this.renderGroup.worldTransform);\n      }\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * \'rotation\' and \'angle\' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * misc_const/* RAD_TO_DEG */.jl;\n  }\n  set angle(value) {\n    this.rotation = value * misc_const/* DEG_TO_RAD */.ZX;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent\'s local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint/* ObservablePoint */.A(this, 0, 0);\n    }\n    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== "object") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, size.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, size.height);\n    }\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === "number" ? opts.x : this.position.x,\n      typeof opts.y === "number" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === "number" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    if ((this._didLocalTransformChangeId & 15) === this._didChangeId)\n      return;\n    this._didLocalTransformChangeId = this._didChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color/* Color */.I.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `\'normal\'` to reset the blend mode.\n   * @default \'normal\'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 2) >> 1 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 4) >> 2 === valueNumber)\n      return;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.renderGroup && !this.isRenderGroupRoot) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. \'options\' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    this.removeFromParent();\n    this.parent = null;\n    this._mask = null;\n    this._filters = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit("destroyed", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\n\n//# sourceMappingURL=Container.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBLHNCQUFzQixrREFBa0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQVU7QUFDckM7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQ0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixZQUFZOztBQUV1RDtBQUNuRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcz8wYzJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2NoaWxkcmVuSGVscGVyTWl4aW4ubWpzPzE2ZGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvcmVuZGVyaW5nL21hc2svTWFza0VmZmVjdE1hbmFnZXIubWpzP2ZkZjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvZWZmZWN0c01peGluLm1qcz8yMmQyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9jb250YWluZXItbWl4aW5zL2ZpbmRNaXhpbi5tanM/M2E0YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvY2hlY2tDaGlsZHJlbkRpZENoYW5nZS5tanM/YTFlZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9tZWFzdXJlTWl4aW4ubWpzP2FmZjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvb25SZW5kZXJNaXhpbi5tanM/MGQzYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvY29udGFpbmVyLW1peGlucy9zb3J0TWl4aW4ubWpzPzNiMjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcz9iNzRiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9SZW5kZXJHcm91cC5tanM/NGI0NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvdXRpbHMvYXNzaWduV2l0aElnbm9yZS5tanM/YjgzNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvQ29udGFpbmVyLm1qcz8yNDgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY3VsbGluZ01peGluID0ge1xuICBjdWxsQXJlYTogbnVsbCxcbiAgY3VsbGFibGU6IGZhbHNlLFxuICBjdWxsYWJsZUNoaWxkcmVuOiB0cnVlXG59O1xuXG5leHBvcnQgeyBjdWxsaW5nTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1bGxpbmdNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RhdGEvcmVtb3ZlSXRlbXMubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgY2hpbGRyZW5IZWxwZXJNaXhpbiA9IHtcbiAgYWxsb3dDaGlsZHJlbjogdHJ1ZSxcbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBjb250YWluZXIgdGhhdCBhcmUgd2l0aGluIHRoZSBiZWdpbiBhbmQgZW5kIGluZGV4ZXMuXG4gICAqIEBwYXJhbSBiZWdpbkluZGV4IC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cbiAgICogQHBhcmFtIGVuZEluZGV4IC0gVGhlIGVuZGluZyBwb3NpdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm5zIC0gTGlzdCBvZiByZW1vdmVkIGNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICByZW1vdmVDaGlsZHJlbihiZWdpbkluZGV4ID0gMCwgZW5kSW5kZXgpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRJbmRleCA/PyB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBjb25zdCByYW5nZSA9IGVuZCAtIGJlZ2luSW5kZXg7XG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICBmb3IgKGxldCBpID0gZW5kIC0gMTsgaSA+PSBiZWdpbkluZGV4OyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyR3JvdXAucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZWQucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBiZWdpbkluZGV4LCBlbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCByZW1vdmVkW2ldLCB0aGlzLCBpKTtcbiAgICAgICAgcmVtb3ZlZFtpXS5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS5cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBmcm9tXG4gICAqIEByZXR1cm5zIFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XG4gICAqIEByZXR1cm5zIC0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q2hpbGRBdDogSW5kZXggKCR7aW5kZXh9KSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICB9LFxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgYW4gZXhpc3RpbmcgY2hpbGQgaW4gdGhlIGNvbnRhaW5lciBjb250YWluZXJcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIENvbnRhaW5lciBpbnN0YW5jZSBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIHJlc3VsdGluZyBpbmRleCBudW1iZXIgZm9yIHRoZSBjaGlsZCBjb250YWluZXJcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgYSBjaGlsZCBDb250YWluZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIGNoaWxkIC0gVGhlIENvbnRhaW5lciBpbnN0YW5jZSB0byBpZGVudGlmeVxuICAgKiBAcmV0dXJucyAtIFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgY29udGFpbmVyIHRvIGlkZW50aWZ5XG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwbGllZCBDb250YWluZXIgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfSxcbiAgLyoqXG4gICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICogSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhpcyBjb250YWluZXIsIGl0IHdpbGwgYmUgbW92ZWQgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtDb250YWluZXJ9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGFic29sdXRlIGluZGV4IHdoZXJlIHRoZSBjaGlsZCB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBhZGRDaGlsZEF0KGNoaWxkLCBpbmRleCkge1xuICAgIGlmICghdGhpcy5hbGxvd0NoaWxkcmVuKSB7XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiYWRkQ2hpbGRBdDogT25seSBDb250YWluZXJzIHdpbGwgYmUgYWxsb3dlZCB0byBhZGQgY2hpbGRyZW4gaW4gdjguMC4wXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjaGlsZH1hZGRDaGlsZEF0OiBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke2NoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2hpbGQucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcyAmJiBjdXJyZW50SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICB9XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICBjaGlsZC5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgIGNoaWxkLmRpZFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICBjaGlsZC5fdXBkYXRlRmxhZ3MgPSAxNTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5hZGRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvcnRhYmxlQ2hpbGRyZW4pXG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0sXG4gIC8qKlxuICAgKiBTd2FwcyB0aGUgcG9zaXRpb24gb2YgMiBDb250YWluZXJzIHdpdGhpbiB0aGlzIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIGNoaWxkIC0gRmlyc3QgY29udGFpbmVyIHRvIHN3YXBcbiAgICogQHBhcmFtIGNoaWxkMiAtIFNlY29uZCBjb250YWluZXIgdG8gc3dhcFxuICAgKi9cbiAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICBpZiAoY2hpbGQgPT09IGNoaWxkMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgQ29udGFpbmVyIGZyb20gaXRzIHBhcmVudCBDb250YWluZXIuIElmIHRoZSBDb250YWluZXIgaGFzIG5vIHBhcmVudCwgZG8gbm90aGluZy5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjaGlsZHJlbkhlbHBlck1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbkhlbHBlck1peGluLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1hc2tFZmZlY3RNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMgPSBbXTtcbiAgICB0aGlzLl90ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2VmZmVjdENsYXNzZXMuZm9yRWFjaCgodGVzdCkgPT4ge1xuICAgICAgdGhpcy5hZGQoe1xuICAgICAgICB0ZXN0OiB0ZXN0LnRlc3QsXG4gICAgICAgIG1hc2tDbGFzczogdGVzdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkKHRlc3QpIHtcbiAgICB0aGlzLl90ZXN0cy5wdXNoKHRlc3QpO1xuICB9XG4gIGdldE1hc2tFZmZlY3QoaXRlbSkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICBpZiAodGVzdC50ZXN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBCaWdQb29sLmdldCh0ZXN0Lm1hc2tDbGFzcywgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIHJldHVybk1hc2tFZmZlY3QoZWZmZWN0KSB7XG4gICAgQmlnUG9vbC5yZXR1cm4oZWZmZWN0KTtcbiAgfVxufVxuY29uc3QgTWFza0VmZmVjdE1hbmFnZXIgPSBuZXcgTWFza0VmZmVjdE1hbmFnZXJDbGFzcygpO1xuZXh0ZW5zaW9ucy5oYW5kbGVCeUxpc3QoRXh0ZW5zaW9uVHlwZS5NYXNrRWZmZWN0LCBNYXNrRWZmZWN0TWFuYWdlci5fZWZmZWN0Q2xhc3Nlcyk7XG5cbmV4cG9ydCB7IE1hc2tFZmZlY3RNYW5hZ2VyLCBNYXNrRWZmZWN0TWFuYWdlckNsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXNrRWZmZWN0TWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXJFZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9maWx0ZXJzL0ZpbHRlckVmZmVjdC5tanMnO1xuaW1wb3J0IHsgTWFza0VmZmVjdE1hbmFnZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvbWFzay9NYXNrRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZWZmZWN0c01peGluID0ge1xuICBfbWFzazogbnVsbCxcbiAgX2ZpbHRlcnM6IG51bGwsXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAdHlwZSB7QXJyYXk8RWZmZWN0Pn1cbiAgICovXG4gIGVmZmVjdHM6IFtdLFxuICAvKipcbiAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICogQHBhcmFtIGVmZmVjdCAtIFRoZSBlZmZlY3QgdG8gYWRkLlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBhZGRFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB0aGlzLmVmZmVjdHMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGlmICh0aGlzLnJlbmRlckdyb3VwKSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgKiBAcGFyYW0gZWZmZWN0IC0gVGhlIGVmZmVjdCB0byByZW1vdmUuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlbW92ZUVmZmVjdChlZmZlY3QpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmVmZmVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAoIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QgJiYgdGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVJc1NpbXBsZSgpO1xuICB9LFxuICBzZXQgbWFzayh2YWx1ZSkge1xuICAgIHRoaXMuX21hc2sgfHwgKHRoaXMuX21hc2sgPSB7IG1hc2s6IG51bGwsIGVmZmVjdDogbnVsbCB9KTtcbiAgICBpZiAodGhpcy5fbWFzay5tYXNrID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5fbWFzay5lZmZlY3QpIHtcbiAgICAgIHRoaXMucmVtb3ZlRWZmZWN0KHRoaXMuX21hc2suZWZmZWN0KTtcbiAgICAgIE1hc2tFZmZlY3RNYW5hZ2VyLnJldHVybk1hc2tFZmZlY3QodGhpcy5fbWFzay5lZmZlY3QpO1xuICAgICAgdGhpcy5fbWFzay5lZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9tYXNrLm1hc2sgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlZmZlY3QgPSBNYXNrRWZmZWN0TWFuYWdlci5nZXRNYXNrRWZmZWN0KHZhbHVlKTtcbiAgICB0aGlzLl9tYXNrLmVmZmVjdCA9IGVmZmVjdDtcbiAgICB0aGlzLmFkZEVmZmVjdChlZmZlY3QpO1xuICB9LFxuICAvKipcbiAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuXG4gICAqIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC4gSW4gUGl4aUpTIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYVxuICAgKiB7QGxpbmsgR3JhcGhpY3N9IG9yIGEge0BsaW5rIFNwcml0ZX0gb2JqZWN0LiBUaGlzIGFsbG93cyBmb3IgbXVjaCBmYXN0ZXIgbWFza2luZyBpbiBjYW52YXMgYXMgaXRcbiAgICogdXRpbGl0aWVzIHNoYXBlIGNsaXBwaW5nLiBGdXJ0aGVybW9yZSwgYSBtYXNrIG9mIGFuIG9iamVjdCBtdXN0IGJlIGluIHRoZSBzdWJ0cmVlIG9mIGl0cyBwYXJlbnQuXG4gICAqIE90aGVyd2lzZSwgYGdldExvY2FsQm91bmRzYCBtYXkgY2FsY3VsYXRlIGluY29ycmVjdCBib3VuZHMsIHdoaWNoIG1ha2VzIHRoZSBjb250YWluZXIncyB3aWR0aCBhbmQgaGVpZ2h0IHdyb25nLlxuICAgKiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAqXG4gICAqIEZvciBzcHJpdGUgbWFzayBib3RoIGFscGhhIGFuZCByZWQgY2hhbm5lbCBhcmUgdXNlZC4gQmxhY2sgbWFzayBpcyB0aGUgc2FtZSBhcyB0cmFuc3BhcmVudCBtYXNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBHcmFwaGljcywgU3ByaXRlIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIGNvbnN0IGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCk7XG4gICAqIGdyYXBoaWNzLmJlZ2luRmlsbCgweEZGMzMwMCk7XG4gICAqIGdyYXBoaWNzLmRyYXdSZWN0KDUwLCAyNTAsIDEwMCwgMTAwKTtcbiAgICogZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgKlxuICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlKHRleHR1cmUpO1xuICAgKiBzcHJpdGUubWFzayA9IGdyYXBoaWNzO1xuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s/Lm1hc2s7XG4gIH0sXG4gIHNldCBmaWx0ZXJzKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSlcbiAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICB2YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX2ZpbHRlcnMgfHwgKHRoaXMuX2ZpbHRlcnMgPSB7IGZpbHRlcnM6IG51bGwsIGVmZmVjdDogbnVsbCwgZmlsdGVyQXJlYTogbnVsbCB9KTtcbiAgICBjb25zdCBoYXNGaWx0ZXJzID0gdmFsdWU/Lmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5fZmlsdGVycy5lZmZlY3QgJiYgIWhhc0ZpbHRlcnMgfHwgIXRoaXMuX2ZpbHRlcnMuZWZmZWN0ICYmIGhhc0ZpbHRlcnM7XG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKDApIDogdmFsdWU7XG4gICAgdGhpcy5fZmlsdGVycy5maWx0ZXJzID0gT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgaWYgKGhhc0ZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gQmlnUG9vbC5nZXQoRmlsdGVyRWZmZWN0KTtcbiAgICAgICAgdGhpcy5fZmlsdGVycy5lZmZlY3QgPSBlZmZlY3Q7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9maWx0ZXJzLmVmZmVjdDtcbiAgICAgICAgdGhpcy5yZW1vdmVFZmZlY3QoZWZmZWN0KTtcbiAgICAgICAgZWZmZWN0LmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICBlZmZlY3QuZmlsdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0ID0gbnVsbDtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4oZWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0ZpbHRlcnMpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0LmZpbHRlcnMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuZWZmZWN0LmZpbHRlckFyZWEgPSB0aGlzLmZpbHRlckFyZWE7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgJ251bGwnYC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBmaWx0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJzPy5maWx0ZXJzO1xuICB9LFxuICBzZXQgZmlsdGVyQXJlYSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZpbHRlcnMgfHwgKHRoaXMuX2ZpbHRlcnMgPSB7IGZpbHRlcnM6IG51bGwsIGVmZmVjdDogbnVsbCwgZmlsdGVyQXJlYTogbnVsbCB9KTtcbiAgICB0aGlzLl9maWx0ZXJzLmZpbHRlckFyZWEgPSB2YWx1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pemF0aW9uXG4gICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBBbHNvIHdvcmtzIGFzIGFuIGludGVyYWN0aW9uIG1hc2suXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgZmlsdGVyQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVycz8uZmlsdGVyQXJlYTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZWZmZWN0c01peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZmZlY3RzTWl4aW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmaW5kTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgbGFiZWwgb2YgdGhlIG9iamVjdC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxuICAgKi9cbiAgbGFiZWw6IG51bGwsXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMFxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNsYWJlbFxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJDb250YWluZXIubmFtZSBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkLCB1c2UgQ29udGFpbmVyLmxhYmVsIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gIH0sXG4gIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkNvbnRhaW5lci5uYW1lIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQsIHVzZSBDb250YWluZXIubGFiZWwgaW5zdGVhZFwiKTtcbiAgICB0aGlzLmxhYmVsID0gdmFsdWU7XG4gIH0sXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldENoaWxkQnlOYW1lXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gSW5zdGFuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufVtkZWVwPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2VhcmNoIHJlY3Vyc2l2ZWx5XG4gICAqIEByZXR1cm5zIHtDb250YWluZXJ9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICogQHNlZSBzY2VuZS5Db250YWluZXIjZ2V0Q2hpbGRCeUxhYmVsXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRDaGlsZEJ5TmFtZShuYW1lLCBkZWVwID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZEJ5TGFiZWwobmFtZSwgZGVlcCk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiB0aGUgY29udGFpbmVyIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICpcbiAgICogUmVjdXJzaXZlIHNlYXJjaGVzIGFyZSBkb25lIGluIGEgcHJlLW9yZGVyIHRyYXZlcnNhbC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBsYWJlbCAtIEluc3RhbmNlIGxhYmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59W2RlZXA9ZmFsc2VdIC0gV2hldGhlciB0byBzZWFyY2ggcmVjdXJzaXZlbHlcbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICovXG4gIGdldENoaWxkQnlMYWJlbChsYWJlbCwgZGVlcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQubGFiZWwgPT09IGxhYmVsIHx8IGxhYmVsIGluc3RhbmNlb2YgUmVnRXhwICYmIGxhYmVsLnRlc3QoY2hpbGQubGFiZWwpKVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IGZvdW5kID0gY2hpbGQuZ2V0Q2hpbGRCeUxhYmVsKGxhYmVsLCB0cnVlKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBzcGVjaWZpZWQgbGFiZWwuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gbGFiZWwgLSBJbnN0YW5jZSBsYWJlbC5cbiAgICogQHBhcmFtIHtib29sZWFufVtkZWVwPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2VhcmNoIHJlY3Vyc2l2ZWx5XG4gICAqIEBwYXJhbSB7Q29udGFpbmVyW119IFtvdXQ9W11dIC0gVGhlIGFycmF5IHRvIHN0b3JlIG1hdGNoaW5nIGNoaWxkcmVuIGluLlxuICAgKiBAcmV0dXJucyB7Q29udGFpbmVyW119IEFuIGFycmF5IG9mIGNoaWxkcmVuIHdpdGggdGhlIHNwZWNpZmllZCBsYWJlbC5cbiAgICovXG4gIGdldENoaWxkcmVuQnlMYWJlbChsYWJlbCwgZGVlcCA9IGZhbHNlLCBvdXQgPSBbXSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLmxhYmVsID09PSBsYWJlbCB8fCBsYWJlbCBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBsYWJlbC50ZXN0KGNoaWxkLmxhYmVsKSkge1xuICAgICAgICBvdXQucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmdldENoaWxkcmVuQnlMYWJlbChsYWJlbCwgdHJ1ZSwgb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgZmluZE1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja0NoaWxkcmVuRGlkQ2hhbmdlKGNvbnRhaW5lciwgcHJldmlvdXNEYXRhKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBjaGFuZ2VJZCA9IChjaGlsZC51aWQgJiAyNTUpIDw8IDI0IHwgY2hpbGQuX2RpZENoYW5nZUlkICYgMTY3NzcyMTU7XG4gICAgaWYgKHByZXZpb3VzRGF0YS5kYXRhW3ByZXZpb3VzRGF0YS5pbmRleF0gIT09IGNoYW5nZUlkKSB7XG4gICAgICBwcmV2aW91c0RhdGEuZGF0YVtwcmV2aW91c0RhdGEuaW5kZXhdID0gY2hhbmdlSWQ7XG4gICAgICBwcmV2aW91c0RhdGEuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJldmlvdXNEYXRhLmluZGV4Kys7XG4gICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY2hlY2tDaGlsZHJlbkRpZENoYW5nZShjaGlsZCwgcHJldmlvdXNEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXZpb3VzRGF0YS5kaWRDaGFuZ2U7XG59XG5cbmV4cG9ydCB7IGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzL2dldEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0TG9jYWxCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMvZ2V0TG9jYWxCb3VuZHMubWpzJztcbmltcG9ydCB7IGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UgfSBmcm9tICcuLi91dGlscy9jaGVja0NoaWxkcmVuRGlkQ2hhbmdlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNvbnN0IG1lYXN1cmVNaXhpbiA9IHtcbiAgX2xvY2FsQm91bmRzQ2FjaGVJZDogLTEsXG4gIF9sb2NhbEJvdW5kc0NhY2hlRGF0YTogbnVsbCxcbiAgX3NldFdpZHRoKHZhbHVlLCBsb2NhbFdpZHRoKSB7XG4gICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgaWYgKGxvY2FsV2lkdGggIT09IDApIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gbG9jYWxXaWR0aCAqIHNpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHNpZ247XG4gICAgfVxuICB9LFxuICBfc2V0SGVpZ2h0KHZhbHVlLCBsb2NhbEhlaWdodCkge1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIGlmIChsb2NhbEhlaWdodCAhPT0gMCkge1xuICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyBsb2NhbEhlaWdodCAqIHNpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueSA9IHNpZ247XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGNvbnRhaW5lciBhcyBhIEJvdW5kcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIC0gVGhlIGJvdW5kaW5nIGFyZWEuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRMb2NhbEJvdW5kcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzQ2FjaGVEYXRhKSB7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kc0NhY2hlRGF0YSA9IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGluZGV4OiAxLFxuICAgICAgICBkaWRDaGFuZ2U6IGZhbHNlLFxuICAgICAgICBsb2NhbEJvdW5kczogbmV3IEJvdW5kcygpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBsb2NhbEJvdW5kc0NhY2hlRGF0YSA9IHRoaXMuX2xvY2FsQm91bmRzQ2FjaGVEYXRhO1xuICAgIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmluZGV4ID0gMTtcbiAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5kaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICBpZiAobG9jYWxCb3VuZHNDYWNoZURhdGEuZGF0YVswXSAhPT0gdGhpcy5fZGlkQ2hhbmdlSWQgPj4gMTIpIHtcbiAgICAgIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmRpZENoYW5nZSA9IHRydWU7XG4gICAgICBsb2NhbEJvdW5kc0NhY2hlRGF0YS5kYXRhWzBdID0gdGhpcy5fZGlkQ2hhbmdlSWQgPj4gMTI7XG4gICAgfVxuICAgIGNoZWNrQ2hpbGRyZW5EaWRDaGFuZ2UodGhpcywgbG9jYWxCb3VuZHNDYWNoZURhdGEpO1xuICAgIGlmIChsb2NhbEJvdW5kc0NhY2hlRGF0YS5kaWRDaGFuZ2UpIHtcbiAgICAgIGdldExvY2FsQm91bmRzKHRoaXMsIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmxvY2FsQm91bmRzLCB0ZW1wTWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsQm91bmRzQ2FjaGVEYXRhLmxvY2FsQm91bmRzO1xuICB9LFxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgKHdvcmxkKSBib3VuZHMgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGEgW1JlY3RhbmdsZV17QGxpbmsgUmVjdGFuZ2xlfS5cbiAgICogQHBhcmFtIHNraXBVcGRhdGUgLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cbiAgICogIGJlaW5nIHVwZGF0ZWQuIFRoaXMgbWVhbnMgdGhlIGNhbGN1bGF0aW9uIHJldHVybmVkIE1BWSBiZSBvdXQgb2YgZGF0ZSBCVVQgd2lsbCBnaXZlIHlvdSBhXG4gICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gT3B0aW9uYWwgYm91bmRzIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICogQHJldHVybnMgLSBUaGUgbWluaW11bSBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGluIHdvcmxkIHNwYWNlIHRoYXQgZml0cyBhcm91bmQgdGhpcyBvYmplY3QuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRCb3VuZHMoc2tpcFVwZGF0ZSwgYm91bmRzKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbEJvdW5kcyh0aGlzLCBza2lwVXBkYXRlLCBib3VuZHMgfHwgbmV3IEJvdW5kcygpKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgbWVhc3VyZU1peGluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWFzdXJlTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBvblJlbmRlck1peGluID0ge1xuICBfb25SZW5kZXI6IG51bGwsXG4gIHNldCBvblJlbmRlcihmdW5jKSB7XG4gICAgY29uc3QgcmVuZGVyR3JvdXAgPSB0aGlzLnJlbmRlckdyb3VwO1xuICAgIGlmICghZnVuYykge1xuICAgICAgaWYgKHRoaXMuX29uUmVuZGVyKSB7XG4gICAgICAgIHJlbmRlckdyb3VwPy5yZW1vdmVPblJlbmRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uUmVuZGVyID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vblJlbmRlcikge1xuICAgICAgcmVuZGVyR3JvdXA/LmFkZE9uUmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlbmRlciA9IGZ1bmM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIGNhbGxiYWNrIGlzIHVzZWQgd2hlbiB0aGUgY29udGFpbmVyIGlzIHJlbmRlcmVkLiBUaGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgYWRkIHlvdXIgY3VzdG9tXG4gICAqIGxvZ2ljIHRoYXQgaXMgbmVlZGVkIHRvIGJlIHJ1biBldmVyeSBmcmFtZS5cbiAgICpcbiAgICogSW4gdjcgbWFueSB1c2VycyB1c2VkIGB1cGRhdGVUcmFuc2Zvcm1gIGZvciB0aGlzLCBob3dldmVyIHRoZSB3YXkgdjggcmVuZGVycyBvYmplY3RzIGlzIGRpZmZlcmVudFxuICAgKiBhbmQgXCJ1cGRhdGVUcmFuc2Zvcm1cIiBpcyBubyBsb25nZXIgY2FsbGVkIGV2ZXJ5IGZyYW1lXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcbiAgICogY29udGFpbmVyLm9uUmVuZGVyID0gKCkgPT4ge1xuICAgKiAgICBjb250YWluZXIucm90YXRpb24gKz0gMC4wMTtcbiAgICogfTtcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIGdldCBvblJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25SZW5kZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IG9uUmVuZGVyTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uUmVuZGVyTWl4aW4ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzb3J0TWl4aW4gPSB7XG4gIF96SW5kZXg6IDAsXG4gIC8qKlxuICAgKiBTaG91bGQgY2hpbGRyZW4gYmUgc29ydGVkIGJ5IHpJbmRleCBhdCB0aGUgbmV4dCByZW5kZXIgY2FsbC5cbiAgICpcbiAgICogV2lsbCBnZXQgYXV0b21hdGljYWxseSBzZXQgdG8gdHJ1ZSBpZiBhIG5ldyBjaGlsZCBpcyBhZGRlZCwgb3IgaWYgYSBjaGlsZCdzIHpJbmRleCBjaGFuZ2VzLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnREaXJ0eTogZmFsc2UsXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGNvbnRhaW5lciB3aWxsIHNvcnQgaXRzIGNoaWxkcmVuIGJ5IGB6SW5kZXhgIHZhbHVlXG4gICAqIHdoZW4gdGhlIG5leHQgcmVuZGVyIGlzIGNhbGxlZCwgb3IgbWFudWFsbHkgaWYgYHNvcnRDaGlsZHJlbigpYCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgYWN0dWFsbHkgY2hhbmdlcyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBzbyBzaG91bGQgYmUgdHJlYXRlZFxuICAgKiBhcyBhIGJhc2ljIHNvbHV0aW9uIHRoYXQgaXMgbm90IHBlcmZvcm1hbnQgY29tcGFyZWQgdG8gb3RoZXIgc29sdXRpb25zLFxuICAgKiBzdWNoIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL2xheWVycyBQaXhpSlMgTGF5ZXJzfVxuICAgKlxuICAgKiBBbHNvIGJlIGF3YXJlIG9mIHRoYXQgdGhpcyBtYXkgbm90IHdvcmsgbmljZWx5IHdpdGggdGhlIGBhZGRDaGlsZEF0KClgIGZ1bmN0aW9uLFxuICAgKiBhcyB0aGUgYHpJbmRleGAgc29ydGluZyBtYXkgY2F1c2UgdGhlIGNoaWxkIHRvIGF1dG9tYXRpY2FsbHkgc29ydGVkIHRvIGFub3RoZXIgcG9zaXRpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgc29ydGFibGVDaGlsZHJlbjogZmFsc2UsXG4gIC8qKlxuICAgKiBUaGUgekluZGV4IG9mIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSwgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgcGFyZW50IHRvIGJlIHNvcnRhYmxlLiBDaGlsZHJlbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICogYW5kIHRodXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGRpc3BsYXkgb2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgKiBAc2VlIHNjZW5lLkNvbnRhaW5lciNzb3J0YWJsZUNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXQgekluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl96SW5kZXg7XG4gIH0sXG4gIHNldCB6SW5kZXgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fekluZGV4ID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcbiAgICB0aGlzLmRlcHRoT2ZDaGlsZE1vZGlmaWVkKCk7XG4gIH0sXG4gIGRlcHRoT2ZDaGlsZE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc29ydGFibGVDaGlsZHJlbiA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCAmJiAhdGhpcy5pc1JlbmRlckdyb3VwUm9vdCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNvcnRDaGlsZHJlbigpIHtcbiAgICBpZiAoIXRoaXMuc29ydERpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRDaGlsZHJlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBzb3J0Q2hpbGRyZW4oYSwgYikge1xuICByZXR1cm4gYS5fekluZGV4IC0gYi5fekluZGV4O1xufVxuXG5leHBvcnQgeyBzb3J0TWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfSBmcm9tICcuLi9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG9Mb2NhbEdsb2JhbE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSBwb2ludCAtIFRoZSBvcHRpb25hbCBwb2ludCB0byB3cml0ZSB0aGUgZ2xvYmFsIHZhbHVlIHRvLlxuICAgKiBAcGFyYW0gc2tpcFVwZGF0ZSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyAtIFRoZSB1cGRhdGVkIHBvaW50LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQgPSBuZXcgUG9pbnQoKSwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC50b0dsb2JhbCh0aGlzLl9wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludC54ID0gdGhpcy5fcG9zaXRpb24ueDtcbiAgICAgIHBvaW50LnkgPSB0aGlzLl9wb3NpdGlvbi55O1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICogQHBhcmFtIHBvaW50IC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxuICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXG4gICAqIEBwYXJhbSBza2lwVXBkYXRlIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIC0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCBnbG9iYWxNYXRyaXggPSB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgICAgIGdsb2JhbE1hdHJpeC5hcHBlbmQodGhpcy5sb2NhbFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gZ2xvYmFsTWF0cml4LmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH0sXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXG4gICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIENvbnRhaW5lciB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcG9pbnQgLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAqICAob3RoZXJ3aXNlIHdpbGwgY3JlYXRlIGEgbmV3IFBvaW50KS5cbiAgICogQHBhcmFtIHNraXBVcGRhdGUgLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyAtIEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHRvTG9jYWwocG9zaXRpb24sIGZyb20sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgIH1cbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IGdsb2JhbE1hdHJpeCA9IHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyh0aGlzLCBuZXcgTWF0cml4KCkpO1xuICAgICAgZ2xvYmFsTWF0cml4LmFwcGVuZCh0aGlzLmxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiBnbG9iYWxNYXRyaXguYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG59O1xuXG5leHBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvTG9jYWxHbG9iYWxNaXhpbi5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBJbnN0cnVjdGlvblNldCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL2luc3RydWN0aW9ucy9JbnN0cnVjdGlvblNldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlbmRlckdyb3VwIHtcbiAgY29uc3RydWN0b3Iocm9vdCkge1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJyZW5kZXJHcm91cFwiO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckdyb3VwUGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy53b3JsZENvbG9yQWxwaGEgPSA0Mjk0OTY3Mjk1O1xuICAgIHRoaXMud29ybGRDb2xvciA9IDE2Nzc3MjE1O1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG4gICAgLy8gdGhlc2UgdXBkYXRlcyBhcmUgdHJhbnNmb3JtIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudXBkYXRlVGljayA9IDA7XG4gICAgLy8gdGhlc2UgdXBkYXRlIGFyZSByZW5kZXJhYmxlIGNoYW5nZXMuLlxuICAgIHRoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlID0geyBsaXN0OiBbXSwgaW5kZXg6IDAgfTtcbiAgICAvLyBvdGhlclxuICAgIHRoaXMuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RydWN0aW9uU2V0ID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzID0gW107XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLmFkZENoaWxkKHJvb3QpO1xuICB9XG4gIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LmxvY2FsVHJhbnNmb3JtO1xuICB9XG4gIGFkZFJlbmRlckdyb3VwQ2hpbGQocmVuZGVyR3JvdXBDaGlsZCkge1xuICAgIGlmIChyZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50KSB7XG4gICAgICByZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50Ll9yZW1vdmVSZW5kZXJHcm91cENoaWxkKHJlbmRlckdyb3VwQ2hpbGQpO1xuICAgIH1cbiAgICByZW5kZXJHcm91cENoaWxkLnJlbmRlckdyb3VwUGFyZW50ID0gdGhpcztcbiAgICB0aGlzLm9uQ2hpbGRVcGRhdGUocmVuZGVyR3JvdXBDaGlsZC5yb290KTtcbiAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4ucHVzaChyZW5kZXJHcm91cENoaWxkKTtcbiAgfVxuICBfcmVtb3ZlUmVuZGVyR3JvdXBDaGlsZChyZW5kZXJHcm91cENoaWxkKSB7XG4gICAgaWYgKHJlbmRlckdyb3VwQ2hpbGQucm9vdC5kaWRDaGFuZ2UpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNoaWxkRnJvbVVwZGF0ZShyZW5kZXJHcm91cENoaWxkLnJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVuZGVyR3JvdXBDaGlsZHJlbi5pbmRleE9mKHJlbmRlckdyb3VwQ2hpbGQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmVuZGVyR3JvdXBDaGlsZC5yZW5kZXJHcm91cFBhcmVudCA9IG51bGw7XG4gIH1cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKGNoaWxkICE9PSB0aGlzLnJvb3QpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgY2hpbGQudXBkYXRlVGljayA9IC0xO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgIGNoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGggPSBjaGlsZC5wYXJlbnQucmVsYXRpdmVSZW5kZXJHcm91cERlcHRoICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5fb25SZW5kZXIpIHtcbiAgICAgICAgdGhpcy5hZGRPblJlbmRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZC5yZW5kZXJHcm91cCkge1xuICAgICAgaWYgKGNoaWxkLnJlbmRlckdyb3VwLnJvb3QgPT09IGNoaWxkKSB7XG4gICAgICAgIHRoaXMuYWRkUmVuZGVyR3JvdXBDaGlsZChjaGlsZC5yZW5kZXJHcm91cCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQucmVuZGVyR3JvdXAgPSB0aGlzO1xuICAgICAgY2hpbGQuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcbiAgICBpZiAoIWNoaWxkLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICB0aGlzLm9uQ2hpbGRVcGRhdGUoY2hpbGQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgaWYgKGNoaWxkLl9vblJlbmRlcikge1xuICAgICAgdGhpcy5yZW1vdmVPblJlbmRlcihjaGlsZCk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5yZW5kZXJHcm91cC5yb290ICE9PSBjaGlsZCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5jaGlsZHJlbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuZGlkQ2hhbmdlKSB7XG4gICAgICAgIGNoaWxkLnJlbmRlckdyb3VwLl9yZW1vdmVDaGlsZEZyb21VcGRhdGUoY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQucmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVSZW5kZXJHcm91cENoaWxkKGNoaWxkLnJlbmRlckdyb3VwKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgb25DaGlsZFVwZGF0ZShjaGlsZCkge1xuICAgIGxldCBjaGlsZHJlblRvVXBkYXRlID0gdGhpcy5jaGlsZHJlblRvVXBkYXRlW2NoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aF07XG4gICAgaWYgKCFjaGlsZHJlblRvVXBkYXRlKSB7XG4gICAgICBjaGlsZHJlblRvVXBkYXRlID0gdGhpcy5jaGlsZHJlblRvVXBkYXRlW2NoaWxkLnJlbGF0aXZlUmVuZGVyR3JvdXBEZXB0aF0gPSB7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBsaXN0OiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ub1VwZGF0ZS5saXN0W2NoaWxkcmVuVG9VcGRhdGUuaW5kZXgrK10gPSBjaGlsZDtcbiAgfVxuICAvLyBTSE9VTEQgVEhJUyBCRSBIRVJFP1xuICB1cGRhdGVSZW5kZXJhYmxlKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuZ2xvYmFsRGlzcGxheVN0YXR1cyA8IDcpXG4gICAgICByZXR1cm47XG4gICAgY29udGFpbmVyLmRpZFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLmluc3RydWN0aW9uU2V0LnJlbmRlclBpcGVzW2NvbnRhaW5lci5yZW5kZXJQaXBlSWRdLnVwZGF0ZVJlbmRlcmFibGUoY29udGFpbmVyKTtcbiAgfVxuICBvbkNoaWxkVmlld1VwZGF0ZShjaGlsZCkge1xuICAgIHRoaXMuY2hpbGRyZW5SZW5kZXJhYmxlc1RvVXBkYXRlLmxpc3RbdGhpcy5jaGlsZHJlblJlbmRlcmFibGVzVG9VcGRhdGUuaW5kZXgrK10gPSBjaGlsZDtcbiAgfVxuICBfcmVtb3ZlQ2hpbGRGcm9tVXBkYXRlKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRyZW5Ub1VwZGF0ZSA9IHRoaXMuY2hpbGRyZW5Ub1VwZGF0ZVtjaGlsZC5yZWxhdGl2ZVJlbmRlckdyb3VwRGVwdGhdO1xuICAgIGlmICghY2hpbGRyZW5Ub1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGNoaWxkcmVuVG9VcGRhdGUubGlzdC5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgY2hpbGRyZW5Ub1VwZGF0ZS5saXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGNoaWxkcmVuVG9VcGRhdGUuaW5kZXgtLTtcbiAgfVxuICBnZXQgaXNSZW5kZXJhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QubG9jYWxEaXNwbGF5U3RhdHVzID09PSA3ICYmIHRoaXMud29ybGRBbHBoYSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIGFkZGluZyBhIGNvbnRhaW5lciB0byB0aGUgb25SZW5kZXIgbGlzdCB3aWxsIG1ha2Ugc3VyZSB0aGUgdXNlciBmdW5jdGlvblxuICAgKiBwYXNzZWQgaW4gdG8gdGhlIHVzZXIgZGVmaW5lZCAnb25SZW5kZXJgIGNhbGxCYWNrXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSB0aGUgY29udGFpbmVyIHRvIGFkZCB0byB0aGUgb25SZW5kZXIgbGlzdFxuICAgKi9cbiAgYWRkT25SZW5kZXIoY29udGFpbmVyKSB7XG4gICAgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLnB1c2goY29udGFpbmVyKTtcbiAgfVxuICByZW1vdmVPblJlbmRlcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9vblJlbmRlckNvbnRhaW5lcnMuc3BsaWNlKHRoaXMuX29uUmVuZGVyQ29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lciksIDEpO1xuICB9XG4gIHJ1bk9uUmVuZGVyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb25SZW5kZXJDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vblJlbmRlckNvbnRhaW5lcnNbaV0uX29uUmVuZGVyKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFJlbmRlckdyb3VwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJHcm91cC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFzc2lnbldpdGhJZ25vcmUodGFyZ2V0LCBvcHRpb25zLCBpZ25vcmUgPSB7fSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCFpZ25vcmVba2V5XSAmJiBvcHRpb25zW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGFzc2lnbldpdGhJZ25vcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2lnbldpdGhJZ25vcmUubWpzLm1hcFxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IGN1bGxpbmdNaXhpbiB9IGZyb20gJy4uLy4uL2N1bGxpbmcvY3VsbGluZ01peGluLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSQURfVE9fREVHLCBERUdfVE9fUkFEIH0gZnJvbSAnLi4vLi4vbWF0aHMvbWlzYy9jb25zdC5tanMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH0gZnJvbSAnLi4vLi4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IGNoaWxkcmVuSGVscGVyTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvY2hpbGRyZW5IZWxwZXJNaXhpbi5tanMnO1xuaW1wb3J0IHsgZWZmZWN0c01peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL2VmZmVjdHNNaXhpbi5tanMnO1xuaW1wb3J0IHsgZmluZE1peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL2ZpbmRNaXhpbi5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZU1peGluIH0gZnJvbSAnLi9jb250YWluZXItbWl4aW5zL21lYXN1cmVNaXhpbi5tanMnO1xuaW1wb3J0IHsgb25SZW5kZXJNaXhpbiB9IGZyb20gJy4vY29udGFpbmVyLW1peGlucy9vblJlbmRlck1peGluLm1qcyc7XG5pbXBvcnQgeyBzb3J0TWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvc29ydE1peGluLm1qcyc7XG5pbXBvcnQgeyB0b0xvY2FsR2xvYmFsTWl4aW4gfSBmcm9tICcuL2NvbnRhaW5lci1taXhpbnMvdG9Mb2NhbEdsb2JhbE1peGluLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJHcm91cCB9IGZyb20gJy4vUmVuZGVyR3JvdXAubWpzJztcbmltcG9ydCB7IGFzc2lnbldpdGhJZ25vcmUgfSBmcm9tICcuL3V0aWxzL2Fzc2lnbldpdGhJZ25vcmUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBkZWZhdWx0U2tldyA9IG5ldyBPYnNlcnZhYmxlUG9pbnQobnVsbCk7XG5jb25zdCBkZWZhdWx0UGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KG51bGwpO1xuY29uc3QgZGVmYXVsdFNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludChudWxsLCAxLCAxKTtcbmNvbnN0IFVQREFURV9DT0xPUiA9IDE7XG5jb25zdCBVUERBVEVfQkxFTkQgPSAyO1xuY29uc3QgVVBEQVRFX1ZJU0lCTEUgPSA0O1xuY29uc3QgVVBEQVRFX1RSQU5TRk9STSA9IDg7XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMudWlkID0gdWlkKFwicmVuZGVyYWJsZVwiKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl91cGRhdGVGbGFncyA9IDE1O1xuICAgIC8vIGlzIHRoaXMgY29udGFpbmVyIHRoZSByb290IG9mIGEgcmVuZGVyR3JvdXA/XG4gICAgLy8gVE9ETyBpbXBsZW1lbnQgdGhpcyBpbiBhIGZldyBtb3JlIHBsYWNlc1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuaXNSZW5kZXJHcm91cFJvb3QgPSBmYWxzZTtcbiAgICAvLyB0aGUgcmVuZGVyIGdyb3VwIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MgdG8gT1Igb3duc1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMucmVuZGVyR3JvdXAgPSBudWxsO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIHRoZSBjb250YWluZXIgaGFzIGNoYW5nZWQuIEl0IGlzIHJlc2V0IG9uY2UgdGhlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAvLyBieSB0aGUgdHJhbnNmb3JtIHN5c3RlbVxuICAgIC8vIGl0cyBoZXJlIHRvIHN0b3AgZW5zdXJlIHRoYXQgd2hlbiB0aGluZ3MgY2hhbmdlLCBvbmx5IG9uZSB1cGRhdGUgZ2V0cyByZWdpc3RlcnMgd2l0aCB0aGUgdHJhbnNmb3JtIHN5c3RlbVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuZGlkQ2hhbmdlID0gZmFsc2U7XG4gICAgLy8gc2FtZSBhcyBhYm92ZSwgYnV0IGZvciB0aGUgcmVuZGVyYWJsZVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuZGlkVmlld1VwZGF0ZSA9IGZhbHNlO1xuICAgIC8vIGhvdyBkZWVwIGlzIHRoZSBjb250YWluZXIgcmVsYXRpdmUgdG8gaXRzIHJlbmRlciBncm91cC4uXG4gICAgLy8gdW5sZXNzIHRoZSBlbGVtZW50IGlzIHRoZSByb290IHJlbmRlciBncm91cCAtIGl0IHdpbGwgYmUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudFxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMucmVsYXRpdmVSZW5kZXJHcm91cERlcHRoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIC8qKiBUaGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgLy8gdXNlZCBpbnRlcm5hbGx5IGZvciBjaGFuZ2luZyB1cCB0aGUgcmVuZGVyIG9yZGVyLi4gbWFpbmx5IGZvciBtYXNrcyBhbmQgZmlsdGVyc1xuICAgIC8vIFRPRE8gc2V0dGluZyB0aGlzIHNob3VsZCBjYXVzZSBhIHJlYnVpbGQ/P1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuaW5jbHVkZUluQnVpbGQgPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMubWVhc3VyYWJsZSA9IHRydWU7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5pc1NpbXBsZSA9IHRydWU7XG4gICAgLy8gLyAvLy8vLy8vLy8vLy8vVHJhbnNmb3JtIHJlbGF0ZWQgcHJvcHMvLy8vLy8vLy8vLy8vL1xuICAgIC8vIHVzZWQgYnkgdGhlIHRyYW5zZm9ybSBzeXN0ZW0gdG8gY2hlY2sgaWYgYSBjb250YWluZXIgbmVlZHMgdG8gYmUgdXBkYXRlZCB0aGF0IGZyYW1lXG4gICAgLy8gaWYgdGhlIHRpY2sgbWF0Y2hlcyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gc3lzdGVtIHRpY2ssIGl0IGlzIG5vdCB1cGRhdGVkIGFnYWluXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlVGljayA9IC0xO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZi5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBncm91cCB0cmFuc2Zvcm0gaXMgYSB0cmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIHJlbmRlciBncm91cCBpdCBiZWxvbmdzIHRvby4gSXQgd2lsbCBpbmNsdWRlIGFsbCBwYXJlbnRcbiAgICAgKiB0cmFuc2Zvcm1zIGFuZCB1cCB0byB0aGUgcmVuZGVyIGdyb3VwICh0aGluayBvZiBpdCBhcyBraW5kIG9mIGxpa2UgYSBzdGFnZSAtIGJ1dCB0aGUgc3RhZ2UgY2FuIGJlIG5lc3RlZCkuXG4gICAgICogSWYgdGhpcyBjb250YWluZXIgaXMgaXMgc2VsZiBhIHJlbmRlciBncm91cCBtYXRyaXggd2lsbCBiZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IHJlbmRlciBncm91cFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZ3JvdXAgdHJhbnNmb3JtIGlzIGEgdHJhbnNmb3JtIHJlbGF0aXZlIHRvIHRoZSByZW5kZXIgZ3JvdXAgaXQgYmVsb25ncyB0b28uXG4gICAgICogSWYgdGhpcyBjb250YWluZXIgaXMgcmVuZGVyIGdyb3VwIHRoZW4gdGhpcyB3aWxsIGJlIGFuIGlkZW50aXR5IG1hdHJpeC4gb3RoZXIgd2lzZSBpdFxuICAgICAqIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0uXG4gICAgICogVXNlIHRoaXMgdmFsdWUgd2hlbiBhY3R1YWxseSByZW5kZXJpbmcgdGhpbmdzIHRvIHRoZSBzY3JlZW5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwVHJhbnNmb3JtID0gdGhpcy5yZWxhdGl2ZUdyb3VwVHJhbnNmb3JtO1xuICAgIC8qKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCB2aWEgZGVzdHJveSgpLiBJZiB0cnVlLCBpdCBzaG91bGQgbm90IGJlIHVzZWQuICovXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAvLyB0cmFuc2Zvcm0gZGF0YS4uXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcG9zaXRpb24gPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fc2NhbGUgPSBkZWZhdWx0U2NhbGU7XG4gICAgLyoqXG4gICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBjb250YWluZXIgdGhhdCBpdCByb3RhdGVzIGFyb3VuZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcGl2b3QgPSBkZWZhdWx0UGl2b3Q7XG4gICAgLyoqXG4gICAgICogVGhlIHNrZXcgYW1vdW50LCBvbiB0aGUgeCBhbmQgeSBheGlzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9za2V3ID0gZGVmYXVsdFNrZXc7XG4gICAgLyoqXG4gICAgICogVGhlIFgtY29vcmRpbmF0ZSB2YWx1ZSBvZiB0aGUgbm9ybWFsaXplZCBsb2NhbCBYIGF4aXMsXG4gICAgICogdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGhvdXQgYSBzY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fY3ggPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBZLWNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIG5vcm1hbGl6ZWQgbG9jYWwgWCBheGlzLFxuICAgICAqIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIGxvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRob3V0IGEgc2NhbGUuXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX3N4ID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgWC1jb29yZGluYXRlIHZhbHVlIG9mIHRoZSBub3JtYWxpemVkIGxvY2FsIFkgYXhpcyxcbiAgICAgKiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGUgbG9jYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IHdpdGhvdXQgYSBzY2FsZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fY3kgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBZLWNvb3JkaW5hdGUgdmFsdWUgb2YgdGhlIG5vcm1hbGl6ZWQgbG9jYWwgWSBheGlzLFxuICAgICAqIHRoZSBzZWNvbmQgY29sdW1uIG9mIHRoZSBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggd2l0aG91dCBhIHNjYWxlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9zeSA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIGFtb3VudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fcm90YXRpb24gPSAwO1xuICAgIC8vIC8gQ09MT1IgcmVsYXRlZCBwcm9wcyAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIGNvbG9yIHN0b3JlZCBhcyBBQkdSXG4gICAgdGhpcy5sb2NhbENvbG9yID0gMTY3NzcyMTU7XG4gICAgdGhpcy5sb2NhbEFscGhhID0gMTtcbiAgICB0aGlzLmdyb3VwQWxwaGEgPSAxO1xuICAgIC8vIEFcbiAgICB0aGlzLmdyb3VwQ29sb3IgPSAxNjc3NzIxNTtcbiAgICAvLyBCR1JcbiAgICB0aGlzLmdyb3VwQ29sb3JBbHBoYSA9IDQyOTQ5NjcyOTU7XG4gICAgLy8gQUJHUlxuICAgIC8vIC8gQkxFTkQgcmVsYXRlZCBwcm9wcyAvLy8vLy8vLy8vLy8vL1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQmxlbmRNb2RlID0gXCJpbmhlcml0XCI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXBCbGVuZE1vZGUgPSBcIm5vcm1hbFwiO1xuICAgIC8vIC8gVklTSUJJTElUWSByZWxhdGVkIHByb3BzIC8vLy8vLy8vLy8vLy8vXG4gICAgLy8gdmlzaWJpbGl0eVxuICAgIC8vIDBiMTFcbiAgICAvLyBmaXJzdCBiaXQgaXMgdmlzaWJsZSwgc2Vjb25kIGJpdCBpcyByZW5kZXJhYmxlXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBob2xkcyB0aHJlZSBiaXRzOiBjdWxsZWQsIHZpc2libGUsIHJlbmRlcmFibGVcbiAgICAgKiB0aGUgdGhpcmQgYml0IHJlcHJlc2VudHMgY3VsbGluZyAoMCA9IGN1bGxlZCwgMSA9IG5vdCBjdWxsZWQpIDBiMTAwXG4gICAgICogdGhlIHNlY29uZCBiaXQgcmVwcmVzZW50cyB2aXNpYmlsaXR5ICgwID0gbm90IHZpc2libGUsIDEgPSB2aXNpYmxlKSAwYjAxMFxuICAgICAqIHRoZSBmaXJzdCBiaXQgcmVwcmVzZW50cyByZW5kZXJhYmxlICgwID0gcmVuZGVyYWJsZSwgMSA9IG5vdCByZW5kZXJhYmxlKSAwYjAwMVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsRGlzcGxheVN0YXR1cyA9IDc7XG4gICAgLy8gMGIxMSB8IDBiMTAgfCAwYjAxIHwgMGIwMFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbERpc3BsYXlTdGF0dXMgPSA3O1xuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdGhhdCBpbmNyZW1lbnRzIGVhY2ggdGltZSB0aGUgY29udGFpbmVyIGlzIG1vZGlmaWVkXG4gICAgICogdGhlIGZpcnN0IDEyIGJpdHMgcmVwcmVzZW50IHRoZSBjb250YWluZXIgY2hhbmdlcyAoZWcgdHJhbnNmb3JtLCBhbHBoYSwgdmlzaWJsZSBldGMpXG4gICAgICogdGhlIHNlY29uZCAxMiBiaXRzIHJlcHJlc2VudCB0aGUgdmlldyBjaGFuZ2VzIChlZyB0ZXh0dXJlIHN3YXAsIGdlb21ldHJ5IGNoYW5nZSBldGMpXG4gICAgICpcbiAgICAgKiAgdmlldyAgICAgICAgICBjb250YWluZXJcbiAgICAgKiBbMDAwMDAwMDAwMDAwXVswMDAwMDAwMDAwMF1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQgPSAwO1xuICAgIC8qKlxuICAgICAqIHByb3BlcnR5IHRoYXQgdHJhY2tzIGlmIHRoZSBjb250YWluZXIgdHJhbnNmb3JtIGhhcyBjaGFuZ2VkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPSAtMTtcbiAgICBhc3NpZ25XaXRoSWdub3JlKHRoaXMsIG9wdGlvbnMsIHtcbiAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgcGFyZW50OiB0cnVlLFxuICAgICAgZWZmZWN0czogdHJ1ZVxuICAgIH0pO1xuICAgIG9wdGlvbnMuY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLmFkZENoaWxkKGNoaWxkKSk7XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgb3B0aW9ucy5wYXJlbnQ/LmFkZENoaWxkKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNaXhlcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIENvbnRhaW5lci5cbiAgICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2YgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0byBtaXggaW4uXG4gICAqL1xuICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29udGFpbmVyLnByb3RvdHlwZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgY2hpbGRyZW4gdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxuICAgKiBAcGFyYW0gey4uLkNvbnRhaW5lcn0gY2hpbGRyZW4gLSBUaGUgQ29udGFpbmVyKHMpIHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gICAqIEByZXR1cm5zIHtDb250YWluZXJ9IC0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgKi9cbiAgYWRkQ2hpbGQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dDaGlsZHJlbikge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcImFkZENoaWxkOiBPbmx5IENvbnRhaW5lcnMgd2lsbCBiZSBhbGxvd2VkIHRvIGFkZCBjaGlsZHJlbiBpbiB2OC4wLjBcIik7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIDEpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICh0aGlzLnJlbmRlckdyb3VwICYmICF0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBpZiAodGhpcy5zb3J0YWJsZUNoaWxkcmVuKVxuICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgY2hpbGQuZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICBjaGlsZC5kaWRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgY2hpbGQuX3VwZGF0ZUZsYWdzID0gMTU7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuYWRkQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICBpZiAoY2hpbGQuX3pJbmRleCAhPT0gMCkge1xuICAgICAgY2hpbGQuZGVwdGhPZkNoaWxkTW9kaWZpZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHsuLi5Db250YWluZXJ9IGNoaWxkcmVuIC0gVGhlIENvbnRhaW5lcihzKSB0byByZW1vdmVcbiAgICogQHJldHVybnMge0NvbnRhaW5lcn0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVDaGlsZCguLi5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgICAgdGhpcy5yZW5kZXJHcm91cC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRSZW1vdmVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgICBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIC8qKiBAaWdub3JlICovXG4gIF9vblVwZGF0ZShwb2ludCkge1xuICAgIGlmIChwb2ludCkge1xuICAgICAgaWYgKHBvaW50ID09PSB0aGlzLl9za2V3KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNrZXcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQrKztcbiAgICBpZiAodGhpcy5kaWRDaGFuZ2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICBjb25zdCByZW5kZXJHcm91cFBhcmVudCA9IHRoaXMucmVuZGVyR3JvdXAucmVuZGVyR3JvdXBQYXJlbnQ7XG4gICAgICBpZiAocmVuZGVyR3JvdXBQYXJlbnQpIHtcbiAgICAgICAgcmVuZGVyR3JvdXBQYXJlbnQub25DaGlsZFVwZGF0ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyR3JvdXApIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAub25DaGlsZFVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0IGlzUmVuZGVyR3JvdXAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc1JlbmRlckdyb3VwUm9vdCAmJiB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltQaXhpXSBjYW5ub3QgdW5kbyBhIHJlbmRlciBncm91cCBqdXN0IHlldFwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmVuYWJsZVJlbmRlckdyb3VwKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb250YWluZXIgaXMgYSByZW5kZXIgZ3JvdXAuXG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgc2VwYXJhdGUgcGFzcywgd2l0aCBpdHMgb3duIHNldCBvZiBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGdldCBpc1JlbmRlckdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVuZGVyR3JvdXBSb290O1xuICB9XG4gIC8qKiBUaGlzIGVuYWJsZXMgdGhlIGNvbnRhaW5lciB0byBiZSByZW5kZXJlZCBhcyBhIHJlbmRlciBncm91cC4gKi9cbiAgZW5hYmxlUmVuZGVyR3JvdXAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgdGhpcy5yZW5kZXJHcm91cC5yb290ID09PSB0aGlzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNSZW5kZXJHcm91cFJvb3QgPSB0cnVlO1xuICAgIGNvbnN0IHBhcmVudFJlbmRlckdyb3VwID0gdGhpcy5yZW5kZXJHcm91cDtcbiAgICBpZiAocGFyZW50UmVuZGVyR3JvdXApIHtcbiAgICAgIHBhcmVudFJlbmRlckdyb3VwLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckdyb3VwID0gbmV3IFJlbmRlckdyb3VwKHRoaXMpO1xuICAgIGlmIChwYXJlbnRSZW5kZXJHcm91cCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRSZW5kZXJHcm91cC5yZW5kZXJHcm91cENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUmVuZGVyR3JvdXAgPSBwYXJlbnRSZW5kZXJHcm91cC5yZW5kZXJHcm91cENoaWxkcmVuW2ldO1xuICAgICAgICBsZXQgcGFyZW50ID0gY2hpbGRSZW5kZXJHcm91cC5yb290O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcm91cC5hZGRSZW5kZXJHcm91cENoaWxkKGNoaWxkUmVuZGVyR3JvdXApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcmVudFJlbmRlckdyb3VwLmFkZFJlbmRlckdyb3VwQ2hpbGQodGhpcy5yZW5kZXJHcm91cCk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUlzU2ltcGxlKCk7XG4gICAgdGhpcy5ncm91cFRyYW5zZm9ybSA9IE1hdHJpeC5JREVOVElUWTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBfdXBkYXRlSXNTaW1wbGUoKSB7XG4gICAgdGhpcy5pc1NpbXBsZSA9ICF0aGlzLmlzUmVuZGVyR3JvdXBSb290ICYmIHRoaXMuZWZmZWN0cy5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9ycy5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0gfHwgKHRoaXMuX3dvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpKTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgICAgdGhpcy5fd29ybGRUcmFuc2Zvcm0uY29weUZyb20odGhpcy5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93b3JsZFRyYW5zZm9ybS5hcHBlbmRGcm9tKHRoaXMucmVsYXRpdmVHcm91cFRyYW5zZm9ybSwgdGhpcy5yZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93b3JsZFRyYW5zZm9ybTtcbiAgfVxuICAvLyAvIC8vLy8vLyB0cmFuc2Zvcm0gcmVsYXRlZCBzdHVmZlxuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICogQW4gYWxpYXMgdG8gcG9zaXRpb24ueFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLng7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl9wb3NpdGlvbi54ID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyIG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnlcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cbiAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICB9XG4gIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XG4gICAgICB0aGlzLl9vblVwZGF0ZSh0aGlzLl9za2V3KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXG4gICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICovXG4gIGdldCBhbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbiAqIFJBRF9UT19ERUc7XG4gIH1cbiAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNlbnRlciBvZiByb3RhdGlvbiwgc2NhbGluZywgYW5kIHNrZXdpbmcgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QgaW4gaXRzIGxvY2FsIHNwYWNlLiBUaGUgYHBvc2l0aW9uYFxuICAgKiBpcyB0aGUgcHJvamVjdGlvbiBvZiBgcGl2b3RgIGluIHRoZSBwYXJlbnQncyBsb2NhbCBzcGFjZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHBpdm90IGlzIHRoZSBvcmlnaW4gKDAsIDApLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBwaXZvdCgpIHtcbiAgICBpZiAodGhpcy5fcGl2b3QgPT09IGRlZmF1bHRQaXZvdCkge1xuICAgICAgdGhpcy5fcGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGl2b3Q7XG4gIH1cbiAgc2V0IHBpdm90KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3Bpdm90ID09PSBkZWZhdWx0UGl2b3QpIHtcbiAgICAgIHRoaXMuX3Bpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fcGl2b3Quc2V0KHZhbHVlKSA6IHRoaXMuX3Bpdm90LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cbiAgZ2V0IHNrZXcoKSB7XG4gICAgaWYgKHRoaXMuX3NrZXcgPT09IGRlZmF1bHRTa2V3KSB7XG4gICAgICB0aGlzLl9za2V3ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NrZXc7XG4gIH1cbiAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2tldyA9PT0gZGVmYXVsdFNrZXcpIHtcbiAgICAgIHRoaXMuX3NrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDAsIDApO1xuICAgIH1cbiAgICB0aGlzLl9za2V3LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNjYWxlIGZhY3RvcnMgb2YgdGhpcyBvYmplY3QgYWxvbmcgdGhlIGxvY2FsIGNvb3JkaW5hdGUgYXhlcy5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgc2NhbGUgaXMgKDEsIDEpLlxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICBpZiAodGhpcy5fc2NhbGUgPT09IGRlZmF1bHRTY2FsZSkge1xuICAgICAgdGhpcy5fc2NhbGUgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMsIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NjYWxlID09PSBkZWZhdWx0U2NhbGUpIHtcbiAgICAgIHRoaXMuX3NjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLCAwLCAwKTtcbiAgICB9XG4gICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdGhpcy5fc2NhbGUuc2V0KHZhbHVlKSA6IHRoaXMuX3NjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGgpO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsV2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgdGhpcy5fc2V0V2lkdGgodmFsdWUsIGxvY2FsV2lkdGgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0LlxuICAgKiBAbWVtYmVyb2Ygc2NlbmUuQ29udGFpbmVyI1xuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodCk7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGxvY2FsSGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICB0aGlzLl9zZXRIZWlnaHQodmFsdWUsIGxvY2FsSGVpZ2h0KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgYXMgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBUaGlzIGlzIGZhc3RlciB0aGFuIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gb3V0IC0gT3B0aW9uYWwgb2JqZWN0IHRvIHN0b3JlIHRoZSBzaXplIGluLlxuICAgKiBAcmV0dXJucyAtIFRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBtZW1iZXJvZiBzY2VuZS5Db250YWluZXIjXG4gICAqL1xuICBnZXRTaXplKG91dCkge1xuICAgIGlmICghb3V0KSB7XG4gICAgICBvdXQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgIG91dC53aWR0aCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueCAqIGJvdW5kcy53aWR0aCk7XG4gICAgb3V0LmhlaWdodCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueSAqIGJvdW5kcy5oZWlnaHQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGlzIGNhbiBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgd2lkdGhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIHNjZW5lLkNvbnRhaW5lciNcbiAgICovXG4gIHNldFNpemUodmFsdWUsIGhlaWdodCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG4gICAgbGV0IGNvbnZlcnRlZFdpZHRoO1xuICAgIGxldCBjb252ZXJ0ZWRIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29udmVydGVkV2lkdGggPSB2YWx1ZTtcbiAgICAgIGNvbnZlcnRlZEhlaWdodCA9IGhlaWdodCA/PyB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udmVydGVkV2lkdGggPSB2YWx1ZS53aWR0aDtcbiAgICAgIGNvbnZlcnRlZEhlaWdodCA9IHZhbHVlLmhlaWdodCA/PyB2YWx1ZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZFdpZHRoICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX3NldFdpZHRoKGNvbnZlcnRlZFdpZHRoLCBzaXplLndpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZEhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRIZWlnaHQoY29udmVydGVkSGVpZ2h0LCBzaXplLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgc2tldyBvciB0aGUgcm90YXRpb24gY2hhbmdlcy4gKi9cbiAgX3VwZGF0ZVNrZXcoKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLl9yb3RhdGlvbjtcbiAgICBjb25zdCBza2V3ID0gdGhpcy5fc2tldztcbiAgICB0aGlzLl9jeCA9IE1hdGguY29zKHJvdGF0aW9uICsgc2tldy5feSk7XG4gICAgdGhpcy5fc3ggPSBNYXRoLnNpbihyb3RhdGlvbiArIHNrZXcuX3kpO1xuICAgIHRoaXMuX2N5ID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tldy5feCk7XG4gICAgdGhpcy5fc3kgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXcuX3gpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIChhY2NlcHRzIHBhcnRpYWwgdmFsdWVzKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyBmb3IgdXBkYXRpbmcgdGhlIHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMueCAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnkgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY2FsZVggLSBUaGUgc2NhbGUgZmFjdG9yIG9uIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjYWxlWSAtIFRoZSBzY2FsZSBmYWN0b3Igb24gdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucm90YXRpb24gLSBUaGUgcm90YXRpb24gb2YgdGhlIGNvbnRhaW5lciwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2tld1ggLSBUaGUgc2tldyBmYWN0b3Igb24gdGhlIHgtYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2tld1kgLSBUaGUgc2tldyBmYWN0b3Igb24gdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucGl2b3RYIC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcGl2b3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBpdm90WSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBpdm90IHBvaW50LlxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtKG9wdHMpIHtcbiAgICB0aGlzLnBvc2l0aW9uLnNldChcbiAgICAgIHR5cGVvZiBvcHRzLnggPT09IFwibnVtYmVyXCIgPyBvcHRzLnggOiB0aGlzLnBvc2l0aW9uLngsXG4gICAgICB0eXBlb2Ygb3B0cy55ID09PSBcIm51bWJlclwiID8gb3B0cy55IDogdGhpcy5wb3NpdGlvbi55XG4gICAgKTtcbiAgICB0aGlzLnNjYWxlLnNldChcbiAgICAgIHR5cGVvZiBvcHRzLnNjYWxlWCA9PT0gXCJudW1iZXJcIiA/IG9wdHMuc2NhbGVYIHx8IDEgOiB0aGlzLnNjYWxlLngsXG4gICAgICB0eXBlb2Ygb3B0cy5zY2FsZVkgPT09IFwibnVtYmVyXCIgPyBvcHRzLnNjYWxlWSB8fCAxIDogdGhpcy5zY2FsZS55XG4gICAgKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gdHlwZW9mIG9wdHMucm90YXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHRzLnJvdGF0aW9uIDogdGhpcy5yb3RhdGlvbjtcbiAgICB0aGlzLnNrZXcuc2V0KFxuICAgICAgdHlwZW9mIG9wdHMuc2tld1ggPT09IFwibnVtYmVyXCIgPyBvcHRzLnNrZXdYIDogdGhpcy5za2V3LngsXG4gICAgICB0eXBlb2Ygb3B0cy5za2V3WSA9PT0gXCJudW1iZXJcIiA/IG9wdHMuc2tld1kgOiB0aGlzLnNrZXcueVxuICAgICk7XG4gICAgdGhpcy5waXZvdC5zZXQoXG4gICAgICB0eXBlb2Ygb3B0cy5waXZvdFggPT09IFwibnVtYmVyXCIgPyBvcHRzLnBpdm90WCA6IHRoaXMucGl2b3QueCxcbiAgICAgIHR5cGVvZiBvcHRzLnBpdm90WSA9PT0gXCJudW1iZXJcIiA/IG9wdHMucGl2b3RZIDogdGhpcy5waXZvdC55XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHVzaW5nIHRoZSBnaXZlbiBtYXRyaXguXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHVzZSBmb3IgdXBkYXRpbmcgdGhlIHRyYW5zZm9ybS5cbiAgICovXG4gIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgfVxuICAvKiogVXBkYXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtLiAqL1xuICB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICBpZiAoKHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgJiAxNSkgPT09IHRoaXMuX2RpZENoYW5nZUlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RpZExvY2FsVHJhbnNmb3JtQ2hhbmdlSWQgPSB0aGlzLl9kaWRDaGFuZ2VJZDtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICBjb25zdCBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgY29uc3Qgc3ggPSBzY2FsZS5feDtcbiAgICBjb25zdCBzeSA9IHNjYWxlLl95O1xuICAgIGNvbnN0IHB4ID0gcGl2b3QuX3g7XG4gICAgY29uc3QgcHkgPSBwaXZvdC5feTtcbiAgICBsdC5hID0gdGhpcy5fY3ggKiBzeDtcbiAgICBsdC5iID0gdGhpcy5fc3ggKiBzeDtcbiAgICBsdC5jID0gdGhpcy5fY3kgKiBzeTtcbiAgICBsdC5kID0gdGhpcy5fc3kgKiBzeTtcbiAgICBsdC50eCA9IHBvc2l0aW9uLl94IC0gKHB4ICogbHQuYSArIHB5ICogbHQuYyk7XG4gICAgbHQudHkgPSBwb3NpdGlvbi5feSAtIChweCAqIGx0LmIgKyBweSAqIGx0LmQpO1xuICB9XG4gIC8vIC8gLy8vLy8gY29sb3IgcmVsYXRlZCBzdHVmZlxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubG9jYWxBbHBoYSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxvY2FsQWxwaGEgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVGbGFncyB8PSBVUERBVEVfQ09MT1I7XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC4gKi9cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQWxwaGE7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBjb25zdCB0ZW1wQ29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUgPz8gMTY3NzcyMTUpO1xuICAgIGNvbnN0IGJnciA9IHRlbXBDb2xvci50b0Jnck51bWJlcigpO1xuICAgIGlmIChiZ3IgPT09IHRoaXMubG9jYWxDb2xvcilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxvY2FsQ29sb3IgPSBiZ3I7XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX0NPTE9SO1xuICAgIHRoaXMuX29uVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cbiAgICpcbiAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAqL1xuICBnZXQgdGludCgpIHtcbiAgICBjb25zdCBiZ3IgPSB0aGlzLmxvY2FsQ29sb3I7XG4gICAgcmV0dXJuICgoYmdyICYgMjU1KSA8PCAxNikgKyAoYmdyICYgNjUyODApICsgKGJnciA+PiAxNiAmIDI1NSk7XG4gIH1cbiAgLy8gLyAvLy8vLy8vLy8vLy8vLy8vIGJsZW5kIHJlbGF0ZWQgc3R1ZmZcbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmxvY2FsQmxlbmRNb2RlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCAmJiAhdGhpcy5pc1JlbmRlckdyb3VwUm9vdCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5zdHJ1Y3R1cmVEaWRDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVGbGFncyB8PSBVUERBVEVfQkxFTkQ7XG4gICAgdGhpcy5sb2NhbEJsZW5kTW9kZSA9IHZhbHVlO1xuICAgIHRoaXMuX29uVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgJ25vcm1hbCdgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgKiBAZGVmYXVsdCAnbm9ybWFsJ1xuICAgKi9cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbEJsZW5kTW9kZTtcbiAgfVxuICAvLyAvIC8vLy8vLy8vLyBWSVNJQklMSVRZIC8gUkVOREVSQUJMRSAvLy8vLy8vLy8vLy8vLy8vL1xuICAvKiogVGhlIHZpc2liaWxpdHkgb2YgdGhlIG9iamVjdC4gSWYgZmFsc2UgdGhlIG9iamVjdCB3aWxsIG5vdCBiZSBkcmF3biwgYW5kIHRoZSB0cmFuc2Zvcm0gd2lsbCBub3QgYmUgdXBkYXRlZC4gKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgMik7XG4gIH1cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZU51bWJlciA9IHZhbHVlID8gMSA6IDA7XG4gICAgaWYgKCh0aGlzLmxvY2FsRGlzcGxheVN0YXR1cyAmIDIpID4+IDEgPT09IHZhbHVlTnVtYmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlbmRlckdyb3VwICYmICF0aGlzLmlzUmVuZGVyR3JvdXBSb290KSB7XG4gICAgICB0aGlzLnJlbmRlckdyb3VwLnN0cnVjdHVyZURpZENoYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9WSVNJQkxFO1xuICAgIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzIF49IDI7XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogQGlnbm9yZSAqL1xuICBnZXQgY3VsbGVkKCkge1xuICAgIHJldHVybiAhKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgNCk7XG4gIH1cbiAgLyoqIEBpZ25vcmUgKi9cbiAgc2V0IGN1bGxlZCh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gdmFsdWUgPyAxIDogMDtcbiAgICBpZiAoKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgNCkgPj4gMiA9PT0gdmFsdWVOdW1iZXIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRmxhZ3MgfD0gVVBEQVRFX1ZJU0lCTEU7XG4gICAgdGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgXj0gNDtcbiAgICB0aGlzLl9vblVwZGF0ZSgpO1xuICB9XG4gIC8qKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB0cmFuc2Zvcm0gd2lsbCBzdGlsbCBiZSB1cGRhdGVkLiAqL1xuICBnZXQgcmVuZGVyYWJsZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5sb2NhbERpc3BsYXlTdGF0dXMgJiAxKTtcbiAgfVxuICBzZXQgcmVuZGVyYWJsZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gdmFsdWUgPyAxIDogMDtcbiAgICBpZiAoKHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzICYgMSkgPT09IHZhbHVlTnVtYmVyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3VwZGF0ZUZsYWdzIHw9IFVQREFURV9WSVNJQkxFO1xuICAgIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzIF49IDE7XG4gICAgaWYgKHRoaXMucmVuZGVyR3JvdXAgJiYgIXRoaXMuaXNSZW5kZXJHcm91cFJvb3QpIHtcbiAgICAgIHRoaXMucmVuZGVyR3JvdXAuc3RydWN0dXJlRGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fb25VcGRhdGUoKTtcbiAgfVxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBzaG91bGQgYmUgcmVuZGVyZWQuICovXG4gIGdldCBpc1JlbmRlcmFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxEaXNwbGF5U3RhdHVzID09PSA3ICYmIHRoaXMuZ3JvdXBBbHBoYSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxuICAgKiBEbyBub3QgdXNlIGEgQ29udGFpbmVyIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3lgLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGRyZW4gd2l0aCB0ZXh0dXJlcyBlLmcuIFNwcml0ZXMuIElmIG9wdGlvbnMuY2hpbGRyZW5cbiAgICogaXMgc2V0IHRvIHRydWUgaXQgc2hvdWxkIGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIHRleHR1cmVzIGUuZy4gU3ByaXRlcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRleHQ9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZHJlbiB3aXRoIGdyYXBoaWNzQ29udGV4dHMgZS5nLiBHcmFwaGljcy5cbiAgICogSWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZSBpdCBzaG91bGQgZGVzdHJveSB0aGUgY29udGV4dCBvZiB0aGUgY2hpbGQgZ3JhcGhpY3NcbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5lZmZlY3RzID0gbnVsbDtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuICAgIHRoaXMuX3Bpdm90ID0gbnVsbDtcbiAgICB0aGlzLl9za2V3ID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95ZWRcIiwgdGhpcyk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8uY2hpbGRyZW47XG4gICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBpZiAoZGVzdHJveUNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG9sZENoaWxkcmVuW2ldLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5Db250YWluZXIubWl4aW4oY2hpbGRyZW5IZWxwZXJNaXhpbik7XG5Db250YWluZXIubWl4aW4odG9Mb2NhbEdsb2JhbE1peGluKTtcbkNvbnRhaW5lci5taXhpbihvblJlbmRlck1peGluKTtcbkNvbnRhaW5lci5taXhpbihtZWFzdXJlTWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGVmZmVjdHNNaXhpbik7XG5Db250YWluZXIubWl4aW4oZmluZE1peGluKTtcbkNvbnRhaW5lci5taXhpbihzb3J0TWl4aW4pO1xuQ29udGFpbmVyLm1peGluKGN1bGxpbmdNaXhpbik7XG5cbmV4cG9ydCB7IENvbnRhaW5lciwgVVBEQVRFX0JMRU5ELCBVUERBVEVfQ09MT1IsIFVQREFURV9UUkFOU0ZPUk0sIFVQREFURV9WSVNJQkxFIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8400\n')},535:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Y: () => (/* binding */ Bounds)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3904);\n\n\n\n"use strict";\nconst defaultMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Rectangle */ .A();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBEO0FBQ007O0FBRWhFO0FBQ0EsMEJBQTBCLHFFQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkVBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXLE9BQU8sV0FBVyxPQUFPLFdBQVcsT0FBTyxXQUFXLFFBQVEsWUFBWSxTQUFTLFlBQVk7QUFDN0k7QUFDQTs7QUFFa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanM/OTQ5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZGVmYXVsdE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5KSB7XG4gICAgLyoqIEBkZWZhdWx0IEluZmluaXR5ICovXG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgLyoqIEBkZWZhdWx0IEluZmluaXR5ICovXG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgLyoqIEBkZWZhdWx0IC1JbmZpbml0eSAqL1xuICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICAvKiogQGRlZmF1bHQgLUluZmluaXR5ICovXG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICAgIHRoaXMubWF0cml4ID0gZGVmYXVsdE1hdHJpeDtcbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYm91bmRzIGFyZSBlbXB0eS5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WTtcbiAgfVxuICAvKiogVGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgIGlmICghdGhpcy5fcmVjdGFuZ2xlKSB7XG4gICAgICB0aGlzLl9yZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3RhbmdsZSA9IHRoaXMuX3JlY3RhbmdsZTtcbiAgICBpZiAodGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WSkge1xuICAgICAgcmVjdGFuZ2xlLnggPSAwO1xuICAgICAgcmVjdGFuZ2xlLnkgPSAwO1xuICAgICAgcmVjdGFuZ2xlLndpZHRoID0gMDtcbiAgICAgIHJlY3RhbmdsZS5oZWlnaHQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0YW5nbGUuY29weUZyb21Cb3VuZHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqIENsZWFycyB0aGUgYm91bmRzIGFuZCByZXNldHMuICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXRyaXggPSBkZWZhdWx0TWF0cml4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBib3VuZHMuXG4gICAqIEBwYXJhbSB4MCAtIGxlZnQgWCBvZiBmcmFtZVxuICAgKiBAcGFyYW0geTAgLSB0b3AgWSBvZiBmcmFtZVxuICAgKiBAcGFyYW0geDEgLSByaWdodCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MSAtIGJvdHRvbSBZIG9mIGZyYW1lXG4gICAqL1xuICBzZXQoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLm1pblggPSB4MDtcbiAgICB0aGlzLm1pblkgPSB5MDtcbiAgICB0aGlzLm1heFggPSB4MTtcbiAgICB0aGlzLm1heFkgPSB5MTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzcHJpdGUgZnJhbWVcbiAgICogQHBhcmFtIHgwIC0gbGVmdCBYIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB5MCAtIHRvcCBZIG9mIGZyYW1lXG4gICAqIEBwYXJhbSB4MSAtIHJpZ2h0IFggb2YgZnJhbWVcbiAgICogQHBhcmFtIHkxIC0gYm90dG9tIFkgb2YgZnJhbWVcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKi9cbiAgYWRkRnJhbWUoeDAsIHkwLCB4MSwgeTEsIG1hdHJpeCkge1xuICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgbWluWCA9IHRoaXMubWluWDtcbiAgICBsZXQgbWluWSA9IHRoaXMubWluWTtcbiAgICBsZXQgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBsZXQgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBsZXQgeCA9IGEgKiB4MCArIGMgKiB5MCArIHR4O1xuICAgIGxldCB5ID0gYiAqIHgwICsgZCAqIHkwICsgdHk7XG4gICAgaWYgKHggPCBtaW5YKVxuICAgICAgbWluWCA9IHg7XG4gICAgaWYgKHkgPCBtaW5ZKVxuICAgICAgbWluWSA9IHk7XG4gICAgaWYgKHggPiBtYXhYKVxuICAgICAgbWF4WCA9IHg7XG4gICAgaWYgKHkgPiBtYXhZKVxuICAgICAgbWF4WSA9IHk7XG4gICAgeCA9IGEgKiB4MSArIGMgKiB5MCArIHR4O1xuICAgIHkgPSBiICogeDEgKyBkICogeTAgKyB0eTtcbiAgICBpZiAoeCA8IG1pblgpXG4gICAgICBtaW5YID0geDtcbiAgICBpZiAoeSA8IG1pblkpXG4gICAgICBtaW5ZID0geTtcbiAgICBpZiAoeCA+IG1heFgpXG4gICAgICBtYXhYID0geDtcbiAgICBpZiAoeSA+IG1heFkpXG4gICAgICBtYXhZID0geTtcbiAgICB4ID0gYSAqIHgwICsgYyAqIHkxICsgdHg7XG4gICAgeSA9IGIgKiB4MCArIGQgKiB5MSArIHR5O1xuICAgIGlmICh4IDwgbWluWClcbiAgICAgIG1pblggPSB4O1xuICAgIGlmICh5IDwgbWluWSlcbiAgICAgIG1pblkgPSB5O1xuICAgIGlmICh4ID4gbWF4WClcbiAgICAgIG1heFggPSB4O1xuICAgIGlmICh5ID4gbWF4WSlcbiAgICAgIG1heFkgPSB5O1xuICAgIHggPSBhICogeDEgKyBjICogeTEgKyB0eDtcbiAgICB5ID0gYiAqIHgxICsgZCAqIHkxICsgdHk7XG4gICAgaWYgKHggPCBtaW5YKVxuICAgICAgbWluWCA9IHg7XG4gICAgaWYgKHkgPCBtaW5ZKVxuICAgICAgbWluWSA9IHk7XG4gICAgaWYgKHggPiBtYXhYKVxuICAgICAgbWF4WCA9IHg7XG4gICAgaWYgKHkgPiBtYXhZKVxuICAgICAgbWF4WSA9IHk7XG4gICAgdGhpcy5taW5YID0gbWluWDtcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlY3RhbmdsZSB0byB0aGUgYm91bmRzLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gYmUgYWRkZWQuXG4gICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBib3VuZHMuXG4gICAqL1xuICBhZGRSZWN0KHJlY3QsIG1hdHJpeCkge1xuICAgIHRoaXMuYWRkRnJhbWUocmVjdC54LCByZWN0LnksIHJlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueSArIHJlY3QuaGVpZ2h0LCBtYXRyaXgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIHtAbGluayBCb3VuZHN9LlxuICAgKiBAcGFyYW0gYm91bmRzIC0gVGhlIEJvdW5kcyB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzLCBtYXRyaXgpIHtcbiAgICB0aGlzLmFkZEZyYW1lKGJvdW5kcy5taW5YLCBib3VuZHMubWluWSwgYm91bmRzLm1heFgsIGJvdW5kcy5tYXhZLCBtYXRyaXgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzLlxuICAgKiBAcGFyYW0gbWFzayAtIFRoZSBCb3VuZHMgdG8gYmUgYWRkZWQuXG4gICAqL1xuICBhZGRCb3VuZHNNYXNrKG1hc2spIHtcbiAgICB0aGlzLm1pblggPSB0aGlzLm1pblggPiBtYXNrLm1pblggPyB0aGlzLm1pblggOiBtYXNrLm1pblg7XG4gICAgdGhpcy5taW5ZID0gdGhpcy5taW5ZID4gbWFzay5taW5ZID8gdGhpcy5taW5ZIDogbWFzay5taW5ZO1xuICAgIHRoaXMubWF4WCA9IHRoaXMubWF4WCA8IG1hc2subWF4WCA/IHRoaXMubWF4WCA6IG1hc2subWF4WDtcbiAgICB0aGlzLm1heFkgPSB0aGlzLm1heFkgPCBtYXNrLm1heFkgPyB0aGlzLm1heFkgOiBtYXNrLm1heFk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtdWx0aXBsaWVkIHdpdGggbWF0cml4LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBseSB0byB0aGUgYm91bmRzLlxuICAgKi9cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc3QgbWluWCA9IHRoaXMubWluWDtcbiAgICBjb25zdCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGNvbnN0IG1heFggPSB0aGlzLm1heFg7XG4gICAgY29uc3QgbWF4WSA9IHRoaXMubWF4WTtcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIHR4LCB0eSB9ID0gbWF0cml4O1xuICAgIGxldCB4ID0gYSAqIG1pblggKyBjICogbWluWSArIHR4O1xuICAgIGxldCB5ID0gYiAqIG1pblggKyBkICogbWluWSArIHR5O1xuICAgIHRoaXMubWluWCA9IHg7XG4gICAgdGhpcy5taW5ZID0geTtcbiAgICB0aGlzLm1heFggPSB4O1xuICAgIHRoaXMubWF4WSA9IHk7XG4gICAgeCA9IGEgKiBtYXhYICsgYyAqIG1pblkgKyB0eDtcbiAgICB5ID0gYiAqIG1heFggKyBkICogbWluWSArIHR5O1xuICAgIHRoaXMubWluWCA9IHggPCB0aGlzLm1pblggPyB4IDogdGhpcy5taW5YO1xuICAgIHRoaXMubWluWSA9IHkgPCB0aGlzLm1pblkgPyB5IDogdGhpcy5taW5ZO1xuICAgIHRoaXMubWF4WCA9IHggPiB0aGlzLm1heFggPyB4IDogdGhpcy5tYXhYO1xuICAgIHRoaXMubWF4WSA9IHkgPiB0aGlzLm1heFkgPyB5IDogdGhpcy5tYXhZO1xuICAgIHggPSBhICogbWluWCArIGMgKiBtYXhZICsgdHg7XG4gICAgeSA9IGIgKiBtaW5YICsgZCAqIG1heFkgKyB0eTtcbiAgICB0aGlzLm1pblggPSB4IDwgdGhpcy5taW5YID8geCA6IHRoaXMubWluWDtcbiAgICB0aGlzLm1pblkgPSB5IDwgdGhpcy5taW5ZID8geSA6IHRoaXMubWluWTtcbiAgICB0aGlzLm1heFggPSB4ID4gdGhpcy5tYXhYID8geCA6IHRoaXMubWF4WDtcbiAgICB0aGlzLm1heFkgPSB5ID4gdGhpcy5tYXhZID8geSA6IHRoaXMubWF4WTtcbiAgICB4ID0gYSAqIG1heFggKyBjICogbWF4WSArIHR4O1xuICAgIHkgPSBiICogbWF4WCArIGQgKiBtYXhZICsgdHk7XG4gICAgdGhpcy5taW5YID0geCA8IHRoaXMubWluWCA/IHggOiB0aGlzLm1pblg7XG4gICAgdGhpcy5taW5ZID0geSA8IHRoaXMubWluWSA/IHkgOiB0aGlzLm1pblk7XG4gICAgdGhpcy5tYXhYID0geCA+IHRoaXMubWF4WCA/IHggOiB0aGlzLm1heFg7XG4gICAgdGhpcy5tYXhZID0geSA+IHRoaXMubWF4WSA/IHkgOiB0aGlzLm1heFk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGJvdW5kcyBvYmplY3QgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gYmUgaW5jbHVkZWQuXG4gICAqL1xuICBmaXQocmVjdCkge1xuICAgIGlmICh0aGlzLm1pblggPCByZWN0LmxlZnQpXG4gICAgICB0aGlzLm1pblggPSByZWN0LmxlZnQ7XG4gICAgaWYgKHRoaXMubWF4WCA+IHJlY3QucmlnaHQpXG4gICAgICB0aGlzLm1heFggPSByZWN0LnJpZ2h0O1xuICAgIGlmICh0aGlzLm1pblkgPCByZWN0LnRvcClcbiAgICAgIHRoaXMubWluWSA9IHJlY3QudG9wO1xuICAgIGlmICh0aGlzLm1heFkgPiByZWN0LmJvdHRvbSlcbiAgICAgIHRoaXMubWF4WSA9IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYWRzIGJvdW5kcyBvYmplY3QsIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgKiBJZiBwYWRkaW5nWSBpcyBvbWl0dGVkLCBib3RoIHBhZGRpbmdYIGFuZCBwYWRkaW5nWSB3aWxsIGJlIHNldCB0byBwYWRkaW5nWC5cbiAgICogQHBhcmFtIHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAqIEBwYXJhbSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cbiAgICovXG4gIHBhZChwYWRkaW5nWCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIHRoaXMubWluWCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLm1heFggKz0gcGFkZGluZ1g7XG4gICAgdGhpcy5taW5ZIC09IHBhZGRpbmdZO1xuICAgIHRoaXMubWF4WSArPSBwYWRkaW5nWTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogQ2VpbHMgdGhlIGJvdW5kcy4gKi9cbiAgY2VpbCgpIHtcbiAgICB0aGlzLm1pblggPSBNYXRoLmZsb29yKHRoaXMubWluWCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5mbG9vcih0aGlzLm1pblkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGguY2VpbCh0aGlzLm1heFgpO1xuICAgIHRoaXMubWF4WSA9IE1hdGguY2VpbCh0aGlzLm1heFkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBDbG9uZXMgdGhlIGJvdW5kcy4gKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZHModGhpcy5taW5YLCB0aGlzLm1pblksIHRoaXMubWF4WCwgdGhpcy5tYXhZKTtcbiAgfVxuICAvKipcbiAgICogU2NhbGVzIHRoZSBib3VuZHMgYnkgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcGFyYW0geCAtIFRoZSBYIHZhbHVlIHRvIHNjYWxlIGJ5LlxuICAgKiBAcGFyYW0geSAtIFRoZSBZIHZhbHVlIHRvIHNjYWxlIGJ5LlxuICAgKi9cbiAgc2NhbGUoeCwgeSA9IHgpIHtcbiAgICB0aGlzLm1pblggKj0geDtcbiAgICB0aGlzLm1pblkgKj0geTtcbiAgICB0aGlzLm1heFggKj0geDtcbiAgICB0aGlzLm1heFkgKj0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogdGhlIHggdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWDtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuICAgIHRoaXMubWluWCA9IHZhbHVlO1xuICAgIHRoaXMubWF4WCA9IHZhbHVlICsgd2lkdGg7XG4gIH1cbiAgLyoqIHRoZSB5IHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLm1pblk7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gICAgdGhpcy5taW5ZID0gdmFsdWU7XG4gICAgdGhpcy5tYXhZID0gdmFsdWUgKyBoZWlnaHQ7XG4gIH1cbiAgLyoqIHRoZSB3aWR0aCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLm1heFggPSB0aGlzLm1pblggKyB2YWx1ZTtcbiAgfVxuICAvKiogdGhlIGhlaWdodCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblk7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMubWF4WSA9IHRoaXMubWluWSArIHZhbHVlO1xuICB9XG4gIC8qKiB0aGUgbGVmdCB2YWx1ZSBvZiB0aGUgYm91bmRzLiAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YO1xuICB9XG4gIC8qKiB0aGUgcmlnaHQgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFg7XG4gIH1cbiAgLyoqIHRoZSB0b3AgdmFsdWUgb2YgdGhlIGJvdW5kcy4gKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5ZO1xuICB9XG4gIC8qKiB0aGUgYm90dG9tIHZhbHVlIG9mIHRoZSBib3VuZHMuICovXG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WTtcbiAgfVxuICAvKiogSXMgdGhlIGJvdW5kcyBwb3NpdGl2ZS4gKi9cbiAgZ2V0IGlzUG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWCA+IDAgJiYgdGhpcy5tYXhZIC0gdGhpcy5taW5ZID4gMDtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YICsgdGhpcy5taW5ZICE9PSBJbmZpbml0eTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxuICAgKiBAcGFyYW0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcbiAgICogQHBhcmFtIGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBlbmQgb2Zmc2V0LCBleGNsdWRlZFxuICAgKiBAcGFyYW0gbWF0cml4XG4gICAqL1xuICBhZGRWZXJ0ZXhEYXRhKHZlcnRleERhdGEsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQsIG1hdHJpeCkge1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBmb3IgKGxldCBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgbG9jYWxYID0gdmVydGV4RGF0YVtpXTtcbiAgICAgIGNvbnN0IGxvY2FsWSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgY29uc3QgeCA9IGEgKiBsb2NhbFggKyBjICogbG9jYWxZICsgdHg7XG4gICAgICBjb25zdCB5ID0gYiAqIGxvY2FsWCArIGQgKiBsb2NhbFkgKyB0eTtcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIH1cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGJvdW5kcy5cbiAgICogQHBhcmFtIHggLSB4IGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHkgLSB5IGNvb3JkaW5hdGVcbiAgICovXG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIGlmICh0aGlzLm1pblggPD0geCAmJiB0aGlzLm1pblkgPD0geSAmJiB0aGlzLm1heFggPj0geCAmJiB0aGlzLm1heFkgPj0geSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzOkJvdW5kcyBtaW5YPSR7dGhpcy5taW5YfSBtaW5ZPSR7dGhpcy5taW5ZfSBtYXhYPSR7dGhpcy5tYXhYfSBtYXhZPSR7dGhpcy5tYXhZfSB3aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IEJvdW5kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///535\n')},5128:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I_: () => (/* binding */ updateTransformBackwards),\n/* harmony export */   qW: () => (/* binding */ getGlobalBounds)\n/* harmony export */ });\n/* unused harmony export _getGlobalBounds */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2692);\n\n\n\n"use strict";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .boundsPool */ .W.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .matrixPool */ .N.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\n\n//# sourceMappingURL=getGlobalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQ2U7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtFQUFVO0FBQy9CO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCLHFFQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0VBQVU7QUFDL0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLG1DQUFtQyxxRUFBTTtBQUN6QyxJQUFJLCtFQUFVO0FBQ2Q7QUFDQTtBQUNBLElBQUksK0VBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RTtBQUN2RSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0R2xvYmFsQm91bmRzLm1qcz9lMWY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IG1hdHJpeFBvb2wsIGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBnZXRHbG9iYWxCb3VuZHModGFyZ2V0LCBza2lwVXBkYXRlVHJhbnNmb3JtLCBib3VuZHMpIHtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIGxldCBwYXJlbnRUcmFuc2Zvcm07XG4gIGxldCBwb29sZWRNYXRyaXg7XG4gIGlmICh0YXJnZXQucGFyZW50KSB7XG4gICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICBwb29sZWRNYXRyaXggPSBtYXRyaXhQb29sLmdldCgpLmlkZW50aXR5KCk7XG4gICAgICBwYXJlbnRUcmFuc2Zvcm0gPSB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHModGFyZ2V0LCBwb29sZWRNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRUcmFuc2Zvcm0gPSB0YXJnZXQucGFyZW50LndvcmxkVHJhbnNmb3JtO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmFuc2Zvcm0gPSBNYXRyaXguSURFTlRJVFk7XG4gIH1cbiAgX2dldEdsb2JhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcGFyZW50VHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgaWYgKHBvb2xlZE1hdHJpeCkge1xuICAgIG1hdHJpeFBvb2wucmV0dXJuKHBvb2xlZE1hdHJpeCk7XG4gIH1cbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRHbG9iYWxCb3VuZHModGFyZ2V0LCBib3VuZHMsIHBhcmVudFRyYW5zZm9ybSwgc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xuICBpZiAoIXRhcmdldC52aXNpYmxlIHx8ICF0YXJnZXQubWVhc3VyYWJsZSlcbiAgICByZXR1cm47XG4gIGxldCB3b3JsZFRyYW5zZm9ybTtcbiAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgdGFyZ2V0LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhQb29sLmdldCgpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmFwcGVuZEZyb20odGFyZ2V0LmxvY2FsVHJhbnNmb3JtLCBwYXJlbnRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIHdvcmxkVHJhbnNmb3JtID0gdGFyZ2V0LndvcmxkVHJhbnNmb3JtO1xuICB9XG4gIGNvbnN0IHBhcmVudEJvdW5kcyA9IGJvdW5kcztcbiAgY29uc3QgcHJlc2VydmVCb3VuZHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgYm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCB3b3JsZFRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhcmdldC5hZGRCb3VuZHMpIHtcbiAgICAgIGJvdW5kcy5tYXRyaXggPSB3b3JsZFRyYW5zZm9ybTtcbiAgICAgIHRhcmdldC5hZGRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRHbG9iYWxCb3VuZHModGFyZ2V0LmNoaWxkcmVuW2ldLCBib3VuZHMsIHdvcmxkVHJhbnNmb3JtLCBza2lwVXBkYXRlVHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0LmVmZmVjdHNbaV0uYWRkQm91bmRzPy4oYm91bmRzKTtcbiAgICB9XG4gICAgcGFyZW50Qm91bmRzLmFkZEJvdW5kcyhib3VuZHMsIE1hdHJpeC5JREVOVElUWSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4oYm91bmRzKTtcbiAgfVxuICBpZiAoIXNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICBtYXRyaXhQb29sLnJldHVybih3b3JsZFRyYW5zZm9ybSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybUJhY2t3YXJkcyh0YXJnZXQsIHBhcmVudFRyYW5zZm9ybSkge1xuICBjb25zdCBwYXJlbnQgPSB0YXJnZXQucGFyZW50O1xuICBpZiAocGFyZW50KSB7XG4gICAgdXBkYXRlVHJhbnNmb3JtQmFja3dhcmRzKHBhcmVudCwgcGFyZW50VHJhbnNmb3JtKTtcbiAgICBwYXJlbnQudXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICBwYXJlbnRUcmFuc2Zvcm0uYXBwZW5kKHBhcmVudC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHBhcmVudFRyYW5zZm9ybTtcbn1cblxuZXhwb3J0IHsgX2dldEdsb2JhbEJvdW5kcywgZ2V0R2xvYmFsQm91bmRzLCB1cGRhdGVUcmFuc2Zvcm1CYWNrd2FyZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEdsb2JhbEJvdW5kcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5128\n')},3197:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getLocalBounds)\n/* harmony export */ });\n/* unused harmony export getParent */\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5321);\n/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2692);\n\n\n\n\n"use strict";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Matrix */ .y.IDENTITY);\n    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .boundsPool */ .W.return(bounds);\n  }\n  _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .matrixPool */ .N.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn("Item is not inside the root container");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\n\n//# sourceMappingURL=getLocalBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEQ7QUFDSDtBQUNrQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFFQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtFQUFVO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKLHdCQUF3QiwrRUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQU07QUFDekMsSUFBSSwrRUFBVTtBQUNkO0FBQ0EsRUFBRSwrRUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0TG9jYWxCb3VuZHMubWpzP2M2MDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuaW1wb3J0IHsgbWF0cml4UG9vbCwgYm91bmRzUG9vbCB9IGZyb20gJy4vdXRpbHMvbWF0cml4QW5kQm91bmRzUG9vbC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldExvY2FsQm91bmRzKHRhcmdldCwgYm91bmRzLCByZWxhdGl2ZU1hdHJpeCkge1xuICBib3VuZHMuY2xlYXIoKTtcbiAgcmVsYXRpdmVNYXRyaXggfHwgKHJlbGF0aXZlTWF0cml4ID0gTWF0cml4LklERU5USVRZKTtcbiAgX2dldExvY2FsQm91bmRzKHRhcmdldCwgYm91bmRzLCByZWxhdGl2ZU1hdHJpeCwgdGFyZ2V0LCB0cnVlKTtcbiAgaWYgKCFib3VuZHMuaXNWYWxpZCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRMb2NhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcywgcGFyZW50VHJhbnNmb3JtLCByb290Q29udGFpbmVyLCBpc1Jvb3QpIHtcbiAgbGV0IHJlbGF0aXZlVHJhbnNmb3JtO1xuICBpZiAoIWlzUm9vdCkge1xuICAgIGlmICghdGFyZ2V0LnZpc2libGUgfHwgIXRhcmdldC5tZWFzdXJhYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgIGNvbnN0IGxvY2FsVHJhbnNmb3JtID0gdGFyZ2V0LmxvY2FsVHJhbnNmb3JtO1xuICAgIHJlbGF0aXZlVHJhbnNmb3JtID0gbWF0cml4UG9vbC5nZXQoKTtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybS5hcHBlbmRGcm9tKGxvY2FsVHJhbnNmb3JtLCBwYXJlbnRUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIHJlbGF0aXZlVHJhbnNmb3JtID0gbWF0cml4UG9vbC5nZXQoKTtcbiAgICByZWxhdGl2ZVRyYW5zZm9ybSA9IHBhcmVudFRyYW5zZm9ybS5jb3B5VG8ocmVsYXRpdmVUcmFuc2Zvcm0pO1xuICB9XG4gIGNvbnN0IHBhcmVudEJvdW5kcyA9IGJvdW5kcztcbiAgY29uc3QgcHJlc2VydmVCb3VuZHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgaWYgKHByZXNlcnZlQm91bmRzKSB7XG4gICAgYm91bmRzID0gYm91bmRzUG9vbC5nZXQoKS5jbGVhcigpO1xuICB9XG4gIGlmICh0YXJnZXQuYm91bmRzQXJlYSkge1xuICAgIGJvdW5kcy5hZGRSZWN0KHRhcmdldC5ib3VuZHNBcmVhLCByZWxhdGl2ZVRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhcmdldC5yZW5kZXJQaXBlSWQpIHtcbiAgICAgIGJvdW5kcy5tYXRyaXggPSByZWxhdGl2ZVRyYW5zZm9ybTtcbiAgICAgIHRhcmdldC5hZGRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgX2dldExvY2FsQm91bmRzKGNoaWxkcmVuW2ldLCBib3VuZHMsIHJlbGF0aXZlVHJhbnNmb3JtLCByb290Q29udGFpbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZXJ2ZUJvdW5kcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldC5lZmZlY3RzW2ldLmFkZExvY2FsQm91bmRzPy4oYm91bmRzLCByb290Q29udGFpbmVyKTtcbiAgICB9XG4gICAgcGFyZW50Qm91bmRzLmFkZEJvdW5kcyhib3VuZHMsIE1hdHJpeC5JREVOVElUWSk7XG4gICAgYm91bmRzUG9vbC5yZXR1cm4oYm91bmRzKTtcbiAgfVxuICBtYXRyaXhQb29sLnJldHVybihyZWxhdGl2ZVRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnQodGFyZ2V0LCByb290LCBtYXRyaXgpIHtcbiAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICB3YXJuKFwiSXRlbSBpcyBub3QgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lclwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmVudCAhPT0gcm9vdCkge1xuICAgIGdldFBhcmVudChwYXJlbnQsIHJvb3QsIG1hdHJpeCk7XG4gICAgcGFyZW50LnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgbWF0cml4LmFwcGVuZChwYXJlbnQubG9jYWxUcmFuc2Zvcm0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldExvY2FsQm91bmRzLCBnZXRQYXJlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldExvY2FsQm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3197\n')},2692:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: () => (/* binding */ matrixPool),\n/* harmony export */   W: () => (/* binding */ boundsPool)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(535);\n\n\n\n\n"use strict";\nconst matrixPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y);\nconst boundsPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(_Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Bounds */ .Y);\n\n\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ047QUFDaEI7O0FBRXZDO0FBQ0EsdUJBQXVCLCtEQUFJLENBQUMscUVBQU07QUFDbEMsdUJBQXVCLCtEQUFJLENBQUMsd0RBQU07O0FBRUE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9jb250YWluZXIvYm91bmRzL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzP2UzNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9vbCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL3Bvb2wvUG9vbC5tanMnO1xuaW1wb3J0IHsgQm91bmRzIH0gZnJvbSAnLi4vQm91bmRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgbWF0cml4UG9vbCA9IG5ldyBQb29sKE1hdHJpeCk7XG5jb25zdCBib3VuZHNQb29sID0gbmV3IFBvb2woQm91bmRzKTtcblxuZXhwb3J0IHsgYm91bmRzUG9vbCwgbWF0cml4UG9vbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0cml4QW5kQm91bmRzUG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2692\n')},9676:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  D: () => (/* binding */ mixColors)\n});\n\n// UNUSED EXPORTS: mixStandardAnd32BitColors\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs\n\nfunction mixHexColors_mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\n\n//# sourceMappingURL=mixHexColors.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs\n\n\n"use strict";\nconst WHITE_WHITE = 16777215 + (16777215 << 32);\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {\n    if (localBGRColor === 16777215) {\n      return parentBGRColor;\n    } else if (parentBGRColor === 16777215) {\n      return localBGRColor;\n    }\n    return mixHexColors_mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return 16777215;\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor = 16777215;\n  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {\n    if (localBGRColor === 16777215) {\n      sharedBGRColor = parentBGRColor;\n    } else if (parentBGRColor === 16777215) {\n      sharedBGRColor = localBGRColor;\n    } else {\n      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n    }\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\n\n//# sourceMappingURL=mixColors.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLFNBQVMseUJBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQ2ZrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxXQUFXLHlCQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci91dGlscy9taXhIZXhDb2xvcnMubWpzP2Y0YmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL3V0aWxzL21peENvbG9ycy5tanM/M2VlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1peEhleENvbG9ycyhjb2xvcjEsIGNvbG9yMiwgcmF0aW8pIHtcbiAgY29uc3QgcjEgPSBjb2xvcjEgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcxID0gY29sb3IxID4+IDggJiAyNTU7XG4gIGNvbnN0IGIxID0gY29sb3IxICYgMjU1O1xuICBjb25zdCByMiA9IGNvbG9yMiA+PiAxNiAmIDI1NTtcbiAgY29uc3QgZzIgPSBjb2xvcjIgPj4gOCAmIDI1NTtcbiAgY29uc3QgYjIgPSBjb2xvcjIgJiAyNTU7XG4gIGNvbnN0IHIgPSByMSArIChyMiAtIHIxKSAqIHJhdGlvO1xuICBjb25zdCBnID0gZzEgKyAoZzIgLSBnMSkgKiByYXRpbztcbiAgY29uc3QgYiA9IGIxICsgKGIyIC0gYjEpICogcmF0aW87XG4gIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG59XG5cbmV4cG9ydCB7IG1peEhleENvbG9ycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4SGV4Q29sb3JzLm1qcy5tYXBcbiIsImltcG9ydCB7IG1peEhleENvbG9ycyB9IGZyb20gJy4vbWl4SGV4Q29sb3JzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgV0hJVEVfV0hJVEUgPSAxNjc3NzIxNSArICgxNjc3NzIxNSA8PCAzMik7XG5mdW5jdGlvbiBtaXhDb2xvcnMobG9jYWxCR1JDb2xvciwgcGFyZW50QkdSQ29sb3IpIHtcbiAgaWYgKGxvY2FsQkdSQ29sb3IgKyAocGFyZW50QkdSQ29sb3IgPDwgMzIpICE9PSBXSElURV9XSElURSkge1xuICAgIGlmIChsb2NhbEJHUkNvbG9yID09PSAxNjc3NzIxNSkge1xuICAgICAgcmV0dXJuIHBhcmVudEJHUkNvbG9yO1xuICAgIH0gZWxzZSBpZiAocGFyZW50QkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICByZXR1cm4gbG9jYWxCR1JDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIG1peEhleENvbG9ycyhsb2NhbEJHUkNvbG9yLCBwYXJlbnRCR1JDb2xvciwgMC41KTtcbiAgfVxuICByZXR1cm4gMTY3NzcyMTU7XG59XG5mdW5jdGlvbiBtaXhTdGFuZGFyZEFuZDMyQml0Q29sb3JzKGxvY2FsQ29sb3JSR0IsIGxvY2FsQWxwaGEsIHBhcmVudENvbG9yKSB7XG4gIGNvbnN0IHBhcmVudEFscGhhID0gKHBhcmVudENvbG9yID4+IDI0ICYgMjU1KSAvIDI1NTtcbiAgY29uc3QgZ2xvYmFsQWxwaGEgPSBsb2NhbEFscGhhICogcGFyZW50QWxwaGEgKiAyNTU7XG4gIGNvbnN0IGxvY2FsQkdSQ29sb3IgPSAoKGxvY2FsQ29sb3JSR0IgJiAyNTUpIDw8IDE2KSArIChsb2NhbENvbG9yUkdCICYgNjUyODApICsgKGxvY2FsQ29sb3JSR0IgPj4gMTYgJiAyNTUpO1xuICBjb25zdCBwYXJlbnRCR1JDb2xvciA9IHBhcmVudENvbG9yICYgMTY3NzcyMTU7XG4gIGxldCBzaGFyZWRCR1JDb2xvciA9IDE2Nzc3MjE1O1xuICBpZiAobG9jYWxCR1JDb2xvciArIChwYXJlbnRCR1JDb2xvciA8PCAzMikgIT09IFdISVRFX1dISVRFKSB7XG4gICAgaWYgKGxvY2FsQkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICBzaGFyZWRCR1JDb2xvciA9IHBhcmVudEJHUkNvbG9yO1xuICAgIH0gZWxzZSBpZiAocGFyZW50QkdSQ29sb3IgPT09IDE2Nzc3MjE1KSB7XG4gICAgICBzaGFyZWRCR1JDb2xvciA9IGxvY2FsQkdSQ29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZEJHUkNvbG9yID0gbWl4SGV4Q29sb3JzKGxvY2FsQkdSQ29sb3IsIHBhcmVudEJHUkNvbG9yLCAwLjUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hhcmVkQkdSQ29sb3IgKyAoZ2xvYmFsQWxwaGEgPDwgMjQpO1xufVxuXG5leHBvcnQgeyBtaXhDb2xvcnMsIG1peFN0YW5kYXJkQW5kMzJCaXRDb2xvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peENvbG9ycy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9676\n')},26:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ BatchableGraphics)\n/* harmony export */ });\n/* harmony import */ var _container_utils_mixColors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9676);\n\n\n"use strict";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return "normal";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = (0,_container_utils_mixColors_mjs__WEBPACK_IMPORTED_MODULE_0__/* .mixColors */ .D)(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\n\n//# sourceMappingURL=BatchableGraphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtGQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9CYXRjaGFibGVHcmFwaGljcy5tanM/NTJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtaXhDb2xvcnMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvdXRpbHMvbWl4Q29sb3JzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hhYmxlR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhdGNoZXIgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2ggPSBudWxsO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSAwO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmFibGUuZ3JvdXBCbGVuZE1vZGU7XG4gICAgfVxuICAgIHJldHVybiBcIm5vcm1hbFwiO1xuICB9XG4gIHBhY2tJbmRleChpbmRleEJ1ZmZlciwgaW5kZXgsIGluZGljZXNPZmZzZXQpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeURhdGEuaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXhTaXplOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2luZGV4KytdID0gaW5kaWNlc1tpICsgdGhpcy5pbmRleE9mZnNldF0gKyBpbmRpY2VzT2Zmc2V0IC0gdGhpcy52ZXJ0ZXhPZmZzZXQ7XG4gICAgfVxuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleCwgdGV4dHVyZUlkKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5RGF0YTtcbiAgICBjb25zdCBncmFwaGljcyA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBjb25zdCB1dnMgPSBnZW9tZXRyeS51dnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy52ZXJ0ZXhPZmZzZXQgKiAyO1xuICAgIGNvbnN0IHZlcnRTaXplID0gKHRoaXMudmVydGV4T2Zmc2V0ICsgdGhpcy52ZXJ0ZXhTaXplKSAqIDI7XG4gICAgY29uc3QgcmdiID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBiZ3IgPSByZ2IgPj4gMTYgfCByZ2IgJiA2NTI4MCB8IChyZ2IgJiAyNTUpIDw8IDE2O1xuICAgIGlmICh0aGlzLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCBhcmdiID0gbWl4Q29sb3JzKGJnciwgZ3JhcGhpY3MuZ3JvdXBDb2xvcikgKyAodGhpcy5hbHBoYSAqIGdyYXBoaWNzLmdyb3VwQWxwaGEgKiAyNTUgPDwgMjQpO1xuICAgICAgY29uc3Qgd3QgPSBncmFwaGljcy5ncm91cFRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgICAgY29uc3QgYSA9IHd0LmE7XG4gICAgICBjb25zdCBiID0gd3QuYjtcbiAgICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgICBjb25zdCB0eCA9IHd0LnR4O1xuICAgICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgICAgaW5kZXggKz0gNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYXJnYiA9IGJnciArICh0aGlzLmFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB2ZXJ0U2l6ZTsgaSArPSAyKSB7XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4XSA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAxXSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgMl0gPSB1dnNbaV07XG4gICAgICAgIGZsb2F0MzJWaWV3W2luZGV4ICsgM10gPSB1dnNbaSArIDFdO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNF0gPSBhcmdiO1xuICAgICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWQgPDwgMTY7XG4gICAgICAgIGluZGV4ICs9IDY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRPRE8gcmVuYW1lIHRvIHZlcnRleFNpemVcbiAgZ2V0IHZlcnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnZlcnRleFNpemU7XG4gIH1cbiAgY29weVRvKGdwdUJ1ZmZlcikge1xuICAgIGdwdUJ1ZmZlci5pbmRleE9mZnNldCA9IHRoaXMuaW5kZXhPZmZzZXQ7XG4gICAgZ3B1QnVmZmVyLmluZGV4U2l6ZSA9IHRoaXMuaW5kZXhTaXplO1xuICAgIGdwdUJ1ZmZlci52ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRleE9mZnNldDtcbiAgICBncHVCdWZmZXIudmVydGV4U2l6ZSA9IHRoaXMudmVydGV4U2l6ZTtcbiAgICBncHVCdWZmZXIuY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGdwdUJ1ZmZlci5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgZ3B1QnVmZmVyLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgZ3B1QnVmZmVyLmdlb21ldHJ5RGF0YSA9IHRoaXMuZ2VvbWV0cnlEYXRhO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoYWJsZUdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaGFibGVHcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},6475:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6653);\n\n\n\n\n"use strict";\nclass Graphics extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: "Graphics",\n      ...rest\n    });\n    this.canBundle = true;\n    this.renderPipeId = "graphics";\n    this._roundPixels = 0;\n    if (!context) {\n      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g();\n    } else {\n      this._context = context;\n    }\n    this._context.on("update", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off("update", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on("update", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   *  Whether or not to round the x/y position of the graphic.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillStyleInputs} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod("setFillStyle", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {FillStyleInputs} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod("setStrokeStyle", args);\n  }\n  fill(...args) {\n    return this._callContextMethod("fill", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param {FillStyleInputs} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod("stroke", args);\n  }\n  texture(...args) {\n    return this._callContextMethod("texture", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod("beginPath", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod("cut", []);\n  }\n  arc(...args) {\n    return this._callContextMethod("arc", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod("arcTo", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod("arcToSvg", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod("bezierCurveTo", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod("closePath", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod("ellipse", args);\n  }\n  circle(...args) {\n    return this._callContextMethod("circle", args);\n  }\n  path(...args) {\n    return this._callContextMethod("path", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod("lineTo", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod("moveTo", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod("quadraticCurveTo", args);\n  }\n  rect(...args) {\n    return this._callContextMethod("rect", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod("roundRect", args);\n  }\n  poly(...args) {\n    return this._callContextMethod("poly", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod("regularPoly", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod("roundPoly", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod("roundShape", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod("filletRect", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod("chamferRect", args);\n  }\n  star(...args) {\n    return this._callContextMethod("star", args);\n  }\n  svg(...args) {\n    return this._callContextMethod("svg", args);\n  }\n  restore(...args) {\n    return this._callContextMethod("restore", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod("save", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod("resetTransform", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod("rotate", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod("scale", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod("setTransform", args);\n  }\n  transform(...args) {\n    return this._callContextMethod("transform", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod("translate", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod("clear", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__/* .GraphicsContext */ .g.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawCircle has been renamed to Graphics#circle");\n    return this._callContextMethod("circle", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawEllipse has been renamed to Graphics#ellipse");\n    return this._callContextMethod("ellipse", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawPolygon has been renamed to Graphics#poly");\n    return this._callContextMethod("poly", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRect has been renamed to Graphics#rect");\n    return this._callContextMethod("rect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");\n    return this._callContextMethod("roundRect", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .deprecation */ .a)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__/* .v8_0_0 */ .P, "Graphics#drawStar has been renamed to Graphics#star");\n    return this._callContextMethod("star", args);\n  }\n}\n\n\n//# sourceMappingURL=Graphics.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkU7QUFDbkI7QUFDRjs7QUFFeEQ7QUFDQSx1QkFBdUIseUVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQWU7QUFDMUMsa0JBQWtCO0FBQ2xCO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBFQUFlO0FBQzlELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQWUsbURBQW1ELDBFQUFlLG1EQUFtRCwwRUFBZTtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLElBQUksb0ZBQVcsQ0FBQywyRUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0EsSUFBSSxvRkFBVyxDQUFDLDJFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJLG9GQUFXLENBQUMsMkVBQU07QUFDdEI7QUFDQTtBQUNBOztBQUVvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanM/ZTAxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vY29udGFpbmVyL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0IH0gZnJvbSAnLi9HcmFwaGljc0NvbnRleHQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBHcmFwaGljcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEdyYXBoaWNzQ29udGV4dCkge1xuICAgICAgb3B0aW9ucyA9IHsgY29udGV4dDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQsIHJvdW5kUGl4ZWxzLCAuLi5yZXN0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHtcbiAgICAgIGxhYmVsOiBcIkdyYXBoaWNzXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5jYW5CdW5kbGUgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyUGlwZUlkID0gXCJncmFwaGljc1wiO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gMDtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9vd25lZENvbnRleHQgPSBuZXcgR3JhcGhpY3NDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLmFsbG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHMgPz8gZmFsc2U7XG4gIH1cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2NvbnRleHQub2ZmKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25WaWV3VXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLm9uVmlld1VwZGF0ZSgpO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9jYWwgYm91bmRzIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgdG8gdGhlIGJvdW5kcyBvYmplY3QuXG4gICAqIEBwYXJhbSBib3VuZHMgLSBUaGUgb3V0cHV0IGJvdW5kcyBvYmplY3QuXG4gICAqL1xuICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyh0aGlzLl9jb250ZXh0LmJvdW5kcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAqL1xuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY29udGFpbnNQb2ludChwb2ludCk7XG4gIH1cbiAgLyoqXG4gICAqICBXaGV0aGVyIG9yIG5vdCB0byByb3VuZCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBncmFwaGljLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yb3VuZFBpeGVscztcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgb25WaWV3VXBkYXRlKCkge1xuICAgIHRoaXMuX2RpZENoYW5nZUlkICs9IDEgPDwgMTI7XG4gICAgdGhpcy5fZGlkR3JhcGhpY3NVcGRhdGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5vbkNoaWxkVmlld1VwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgZ3JhcGhpY3MgcmVuZGVyYWJsZSBhbmQgb3B0aW9uYWxseSBpdHMgY29udGV4dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqXG4gICAqIElmIHRoZSBjb250ZXh0IHdhcyBjcmVhdGVkIGJ5IHRoaXMgZ3JhcGhpY3MgYW5kIGBkZXN0cm95KGZhbHNlKWAgb3IgYGRlc3Ryb3koKWAgaXMgY2FsbGVkXG4gICAqIHRoZW4gdGhlIGNvbnRleHQgd2lsbCBzdGlsbCBiZSBkZXN0cm95ZWQuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIGV4cGxpY2l0bHkgbm90IGRlc3Ryb3kgdGhpcyBjb250ZXh0IHRoYXQgdGhpcyBncmFwaGljcyBjcmVhdGVkLFxuICAgKiB0aGVuIHlvdSBzaG91bGQgcGFzcyBkZXN0cm95KHsgY29udGV4dDogZmFsc2UgfSlcbiAgICpcbiAgICogSWYgdGhlIGNvbnRleHQgd2FzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IgdGhlbiBpdCB3aWxsIG5vdCBiZSBkZXN0cm95ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgZGVzdHJveSB0aGUgdGV4dHVyZSBzb3VyY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb250ZXh0PWZhbHNlXSAtIFNob3VsZCBkZXN0cm95IHRoZSBjb250ZXh0XG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fb3duZWRDb250ZXh0ICYmICFvcHRpb25zKSB7XG4gICAgICB0aGlzLl9vd25lZENvbnRleHQuZGVzdHJveShvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucz8uY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fY29udGV4dC5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9vd25lZENvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbiAgX2NhbGxDb250ZXh0TWV0aG9kKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuY29udGV4dFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHcmFwaGljc0NvbnRleHQgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgZmlsbCBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gVGhlIGZpbGwgc3R5bGUgY2FuIGJlIGEgY29sb3IsIGdyYWRpZW50LFxuICAgKiBwYXR0ZXJuLCBvciBhIG1vcmUgY29tcGxleCBzdHlsZSBkZWZpbmVkIGJ5IGEgRmlsbFN0eWxlIG9iamVjdC5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSBUaGUgZmlsbCBzdHlsZSB0byBhcHBseS4gVGhpcyBjYW4gYmUgYSBzaW1wbGUgY29sb3IsIGEgZ3JhZGllbnQgb3JcbiAgICogcGF0dGVybiBvYmplY3QsIG9yIGEgRmlsbFN0eWxlIG9yIENvbnZlcnRlZEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldEZpbGxTdHlsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2V0RmlsbFN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC4gU2ltaWxhciB0byBmaWxsIHN0eWxlcywgc3Ryb2tlIHN0eWxlcyBjYW5cbiAgICogZW5jb21wYXNzIGNvbG9ycywgZ3JhZGllbnRzLCBwYXR0ZXJucywgb3IgbW9yZSBkZXRhaWxlZCBjb25maWd1cmF0aW9ucyB2aWEgYSBTdHJva2VTdHlsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7RmlsbFN0eWxlSW5wdXRzfSBhcmdzIC0gVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBjb2xvciwgYSBncmFkaWVudCBvciBwYXR0ZXJuLFxuICAgKiBvciBhIFN0cm9rZVN0eWxlIG9yIENvbnZlcnRlZFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc2V0U3Ryb2tlU3R5bGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNldFN0cm9rZVN0eWxlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGwoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cm9rZXMgdGhlIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS4gVGhpcyBtZXRob2QgY2FuIHRha2UgYW4gb3B0aW9uYWxcbiAgICogRmlsbFN0eWxlSW5wdXRzIHBhcmFtZXRlciB0byBkZWZpbmUgdGhlIHN0cm9rZSdzIGFwcGVhcmFuY2UsIGluY2x1ZGluZyBpdHMgY29sb3IsIHdpZHRoLCBhbmQgb3RoZXIgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtGaWxsU3R5bGVJbnB1dHN9IGFyZ3MgLSAoT3B0aW9uYWwpIFRoZSBzdHJva2Ugc3R5bGUgdG8gYXBwbHkuIENhbiBiZSBkZWZpbmVkIGFzIGEgc2ltcGxlIGNvbG9yIG9yIGEgbW9yZVxuICAgKiBjb21wbGV4IHN0eWxlIG9iamVjdC4gSWYgb21pdHRlZCwgdXNlcyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHN0cm9rZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic3Ryb2tlXCIsIGFyZ3MpO1xuICB9XG4gIHRleHR1cmUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInRleHR1cmVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCBwYXRoLiBBbnkgcHJldmlvdXMgcGF0aCBhbmQgaXRzIGNvbW1hbmRzIGFyZSBkaXNjYXJkZWQgYW5kIGEgbmV3IHBhdGggaXNcbiAgICogc3RhcnRlZC4gVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIGJlZm9yZSBiZWdpbm5pbmcgYSBuZXcgc2hhcGUgb3Igc2VyaWVzIG9mIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGJlZ2luUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJiZWdpblBhdGhcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgY3V0b3V0IHRvIHRoZSBsYXN0IGRyYXduIHNoYXBlLiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGhvbGVzIG9yIGNvbXBsZXggc2hhcGVzIGJ5XG4gICAqIHN1YnRyYWN0aW5nIGEgcGF0aCBmcm9tIHRoZSBwcmV2aW91c2x5IGRyYXduIHBhdGguIElmIGEgaG9sZSBpcyBub3QgY29tcGxldGVseSBpbiBhIHNoYXBlLCBpdCB3aWxsXG4gICAqIGZhaWwgdG8gY3V0IGNvcnJlY3RseSFcbiAgICovXG4gIGN1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJjdXRcIiwgW10pO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjXCIsIGFyZ3MpO1xuICB9XG4gIGFyY1RvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJhcmNUb1wiLCBhcmdzKTtcbiAgfVxuICBhcmNUb1N2ZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYXJjVG9TdmdcIiwgYXJncyk7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiYmV6aWVyQ3VydmVUb1wiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNsb3NlUGF0aFwiLCBbXSk7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiZWxsaXBzZVwiLCBhcmdzKTtcbiAgfVxuICBjaXJjbGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNpcmNsZVwiLCBhcmdzKTtcbiAgfVxuICBwYXRoKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwYXRoXCIsIGFyZ3MpO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibGluZVRvXCIsIGFyZ3MpO1xuICB9XG4gIG1vdmVUbyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwibW92ZVRvXCIsIGFyZ3MpO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInF1YWRyYXRpY0N1cnZlVG9cIiwgYXJncyk7XG4gIH1cbiAgcmVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVjdFwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICBwb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJwb2x5XCIsIGFyZ3MpO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWd1bGFyUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFBvbHkoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUG9seVwiLCBhcmdzKTtcbiAgfVxuICByb3VuZFNoYXBlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyb3VuZFNoYXBlXCIsIGFyZ3MpO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImZpbGxldFJlY3RcIiwgYXJncyk7XG4gIH1cbiAgY2hhbWZlclJlY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImNoYW1mZXJSZWN0XCIsIGFyZ3MpO1xuICB9XG4gIHN0YXIoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInN0YXJcIiwgYXJncyk7XG4gIH1cbiAgc3ZnKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdmdcIiwgYXJncyk7XG4gIH1cbiAgcmVzdG9yZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicmVzdG9yZVwiLCBhcmdzKTtcbiAgfVxuICAvKiogU2F2ZXMgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgc3RhdGUsIGluY2x1ZGluZyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcywgb250byBhIHN0YWNrLiAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInNhdmVcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dC5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmdcbiAgICogYW55IHRyYW5zZm9ybWF0aW9ucyAocm90YXRpb24sIHNjYWxpbmcsIHRyYW5zbGF0aW9uKSBwcmV2aW91c2x5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJlc2V0VHJhbnNmb3JtXCIsIFtdKTtcbiAgfVxuICByb3RhdGVUcmFuc2Zvcm0oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdGF0ZVwiLCBhcmdzKTtcbiAgfVxuICBzY2FsZVRyYW5zZm9ybSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwic2NhbGVcIiwgYXJncyk7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzZXRUcmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2Zvcm1cIiwgYXJncyk7XG4gIH1cbiAgdHJhbnNsYXRlVHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJ0cmFuc2xhdGVcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZHJhd2luZyBjb21tYW5kcyBmcm9tIHRoZSBncmFwaGljcyBjb250ZXh0LCBlZmZlY3RpdmVseSByZXNldHRpbmcgaXQuIFRoaXMgaW5jbHVkZXMgY2xlYXJpbmcgdGhlIHBhdGgsXG4gICAqIGFuZCBvcHRpb25hbGx5IHJlc2V0dGluZyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2xlYXJcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZmlsbCBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRGaWxsU3R5bGV9XG4gICAqL1xuICBnZXQgZmlsbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZTtcbiAgfVxuICBzZXQgZmlsbFN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHN0cm9rZSBzdHlsZSB0byB1c2UuXG4gICAqIEB0eXBlIHtDb252ZXJ0ZWRTdHJva2VTdHlsZX1cbiAgICovXG4gIGdldCBzdHJva2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5zdHJva2VTdHlsZTtcbiAgfVxuICBzZXQgc3Ryb2tlU3R5bGUodmFsdWUpIHtcbiAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3Mgb2JqZWN0LlxuICAgKiBOb3RlIHRoYXQgb25seSB0aGUgY29udGV4dCBvZiB0aGUgb2JqZWN0IGlzIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICogQHBhcmFtIGRlZXAgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIGRlZXAgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdC4gSWYgZmFsc2UsIHRoZSBjb250ZXh0XG4gICAqIHdpbGwgYmUgc2hhcmVkIGJldHdlZW4gdGhlIHR3byBvYmplY3RzIChkZWZhdWx0IGZhbHNlKS4gSWYgdHJ1ZSwgdGhlIGNvbnRleHQgd2lsbCBiZVxuICAgKiBjbG9uZWQgKHJlY29tbWVuZGVkIGlmIHlvdSBuZWVkIHRvIG1vZGlmeSB0aGUgY29udGV4dCBpbiBhbnkgd2F5KS5cbiAgICogQHJldHVybnMgLSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICovXG4gIGNsb25lKGRlZXAgPSBmYWxzZSkge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICByZXR1cm4gbmV3IEdyYXBoaWNzKHRoaXMuX2NvbnRleHQuY2xvbmUoKSk7XG4gICAgfVxuICAgIHRoaXMuX293bmVkQ29udGV4dCA9IG51bGw7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgR3JhcGhpY3ModGhpcy5fY29udGV4dCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8vIC0tLS0tLS0tIHY3IGRlcHJlY2F0aW9ucyAtLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gY29sb3JcbiAgICogQHBhcmFtIGFscGhhXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGV9IGluc3RlYWRcbiAgICovXG4gIGxpbmVTdHlsZSh3aWR0aCwgY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2xpbmVTdHlsZSBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3Mjc2V0U3Ryb2tlU3R5bGUgdG8gc2V0IHRoZSBzdHJva2Ugc3R5bGUuXCIpO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0ge307XG4gICAgd2lkdGggJiYgKHN0cm9rZVN0eWxlLndpZHRoID0gd2lkdGgpO1xuICAgIGNvbG9yICYmIChzdHJva2VTdHlsZS5jb2xvciA9IGNvbG9yKTtcbiAgICBhbHBoYSAmJiAoc3Ryb2tlU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBjb2xvclxuICAgKiBAcGFyYW0gYWxwaGFcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBiZWdpbkZpbGwoY29sb3IsIGFscGhhKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2JlZ2luRmlsbCBpcyBubyBsb25nZXIgbmVlZGVkLiBVc2UgR3JhcGhpY3MjZmlsbCB0byBmaWxsIHRoZSBzaGFwZSB3aXRoIHRoZSBkZXNpcmVkIHN0eWxlLlwiKTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSB7fTtcbiAgICBjb2xvciAmJiAoZmlsbFN0eWxlLmNvbG9yID0gY29sb3IpO1xuICAgIGFscGhhICYmIChmaWxsU3R5bGUuYWxwaGEgPSBhbHBoYSk7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNmaWxsfSBpbnN0ZWFkXG4gICAqL1xuICBlbmRGaWxsKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNlbmRGaWxsIGlzIG5vIGxvbmdlciBuZWVkZWQuIFVzZSBHcmFwaGljcyNmaWxsIHRvIGZpbGwgdGhlIHNoYXBlIHdpdGggdGhlIGRlc2lyZWQgc3R5bGUuXCIpO1xuICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKHN0cm9rZVN0eWxlLndpZHRoICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLndpZHRoIHx8IHN0cm9rZVN0eWxlLmNvbG9yICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmNvbG9yIHx8IHN0cm9rZVN0eWxlLmFscGhhICE9PSBHcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlLmFscGhhKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2NpcmNsZX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd0NpcmNsZSguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdDaXJjbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNjaXJjbGVcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwiY2lyY2xlXCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI2VsbGlwc2V9IGluc3RlYWRcbiAgICovXG4gIGRyYXdFbGxpcHNlKC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd0VsbGlwc2UgaGFzIGJlZW4gcmVuYW1lZCB0byBHcmFwaGljcyNlbGxpcHNlXCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcImVsbGlwc2VcIiwgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSB7QGxpbmsgR3JhcGhpY3MjcG9seX0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1BvbHlnb24oLi4uYXJncykge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJHcmFwaGljcyNkcmF3UG9seWdvbiBoYXMgYmVlbiByZW5hbWVkIHRvIEdyYXBoaWNzI3BvbHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxDb250ZXh0TWV0aG9kKFwicG9seVwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNyZWN0fSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3UmVjdCguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3MjcmVjdFwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJyZWN0XCIsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2Uge0BsaW5rIEdyYXBoaWNzI3JvdW5kUmVjdH0gaW5zdGVhZFxuICAgKi9cbiAgZHJhd1JvdW5kZWRSZWN0KC4uLmFyZ3MpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiR3JhcGhpY3MjZHJhd1JvdW5kZWRSZWN0IGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjcm91bmRSZWN0XCIpO1xuICAgIHJldHVybiB0aGlzLl9jYWxsQ29udGV4dE1ldGhvZChcInJvdW5kUmVjdFwiLCBhcmdzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIHtAbGluayBHcmFwaGljcyNzdGFyfSBpbnN0ZWFkXG4gICAqL1xuICBkcmF3U3RhciguLi5hcmdzKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzI2RyYXdTdGFyIGhhcyBiZWVuIHJlbmFtZWQgdG8gR3JhcGhpY3Mjc3RhclwiKTtcbiAgICByZXR1cm4gdGhpcy5fY2FsbENvbnRleHRNZXRob2QoXCJzdGFyXCIsIGFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCB7IEdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6475\n')},6653:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  g: () => (/* binding */ GraphicsContext)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(1580);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(8409);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(5321);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/uid.mjs\nvar uid = __webpack_require__(6258);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(156);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(535);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/parse-svg-path/index.js\nvar parse_svg_path = __webpack_require__(1379);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs\n\n\n\n"use strict";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse_svg_path(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case "M":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "m":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case "H":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "h":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "V":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "v":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case "L":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "l":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case "C":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case "c":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case "S":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "s":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "Q":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case "q":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case "T":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "t":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case "A":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "a":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case "Z":\n      case "z":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        (0,warn/* warn */.Z)(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== "Z" && type !== "z") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\n\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Circle.mjs\n\n\n"use strict";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'circle\'\n     */\n    this.type = "circle";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs\n\n\n"use strict";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'ellipse\'\n     */\n    this.type = "ellipse";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @returns The framing rectangle\n   */\n  getBounds() {\n    return new Rectangle/* Rectangle */.A(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs\n\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\n\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs\n\n\n\n"use strict";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'polygon\'\n     */\n    this.type = "polygon";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    for (let i = 0; i < points.length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs\n\n\n"use strict";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default \'roundedRectangle\'\n     */\n    this.type = "roundedRectangle";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle/* Rectangle */.A();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(4108);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs\n\n\n"use strict";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs\n\n\n"use strict";\nconst buildAdaptiveQuadratic_RECURSION_LIMIT = 8;\nconst buildAdaptiveQuadratic_FLT_EPSILON = 11920929e-14;\nconst buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON = 1;\nconst buildAdaptiveQuadratic_curveAngleToleranceEpsilon = 0.01;\nconst buildAdaptiveQuadratic_mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem/* GraphicsContextSystem */.hJ.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (buildAdaptiveQuadratic_PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction buildAdaptiveQuadratic_begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  buildAdaptiveQuadratic_recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction buildAdaptiveQuadratic_recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > buildAdaptiveQuadratic_RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > buildAdaptiveQuadratic_FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (buildAdaptiveQuadratic_mAngleTolerance < buildAdaptiveQuadratic_curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < buildAdaptiveQuadratic_mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  buildAdaptiveQuadratic_recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  buildAdaptiveQuadratic_recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs\n\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\n\n//# sourceMappingURL=buildArc.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs\n\n\n"use strict";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\n\n//# sourceMappingURL=buildArcTo.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs\n\n\n"use strict";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\n\n//# sourceMappingURL=buildArcToSvg.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\n\n//# sourceMappingURL=roundShape.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tempRectangle = new Rectangle/* Rectangle */.A();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle/* Rectangle */.A(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (!lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\n\n//# sourceMappingURL=ShapePath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = (0,uid/* uid */.h)("graphicsPath");\n    this._dirty = true;\n    if (typeof instructions === "string") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: "addPath", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: "arc", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: "arcTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: "arcToSvg", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: "bezierCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== "bezierCurveTo") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: "closePath", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: "ellipse", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: "lineTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: "moveTo", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: "quadraticCurveTo", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point/* Point */.E.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== "quadraticCurveTo") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: "roundRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: "poly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: "regularPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: "roundPoly", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: "roundShape", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: "filletRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: "chamferRect", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path\'s geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation\'s effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path\'s appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case "moveTo":\n        case "lineTo":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case "bezierCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case "quadraticCurveTo":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case "arcToSvg":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case "circle":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case "rect":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case "ellipse":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case "roundRect":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case "addPath":\n          data[0].transform(matrix);\n          break;\n        case "poly":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          (0,warn/* warn */.Z)("unknown transform action", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path\'s current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point\'s position is accurately determined regardless of the path\'s complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point\'s coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point\'s coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === "closePath") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case "moveTo":\n      case "lineTo":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case "quadraticCurveTo":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case "bezierCurveTo":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case "arc":\n      case "arcToSvg":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case "addPath":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\n\n//# sourceMappingURL=GraphicsPath.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs\n\n\n\n"use strict";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === "string") {\n    const div = document.createElement("div");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector("svg");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case "path":\n      d = svg.getAttribute("d");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "circle":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      r = parseFloatAttribute(svg, "r", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "rect":\n      x = parseFloatAttribute(svg, "x", 0);\n      y = parseFloatAttribute(svg, "y", 0);\n      width = parseFloatAttribute(svg, "width", 0);\n      height = parseFloatAttribute(svg, "height", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "ellipse":\n      cx = parseFloatAttribute(svg, "cx", 0);\n      cy = parseFloatAttribute(svg, "cy", 0);\n      rx = parseFloatAttribute(svg, "rx", 0);\n      ry = parseFloatAttribute(svg, "ry", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "line":\n      x1 = parseFloatAttribute(svg, "x1", 0);\n      y1 = parseFloatAttribute(svg, "y1", 0);\n      x2 = parseFloatAttribute(svg, "x2", 0);\n      y2 = parseFloatAttribute(svg, "y2", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polygon":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "polyline":\n      pointsString = svg.getAttribute("points");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case "g":\n    case "svg":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute("style");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(";");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(":");\n      switch (key) {\n        case "stroke":\n          if (value !== "none") {\n            strokeStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case "stroke-width":\n          strokeStyle.width = Number(value);\n          break;\n        case "fill":\n          if (value !== "none") {\n            useFill = true;\n            fillStyle.color = Color/* Color */.I.shared.setValue(value).toNumber();\n          }\n          break;\n        case "fill-opacity":\n          fillStyle.alpha = Number(value);\n          break;\n        case "stroke-opacity":\n          strokeStyle.alpha = Number(value);\n          break;\n        case "opacity":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute("stroke");\n    if (stroke && stroke !== "none") {\n      useStroke = true;\n      strokeStyle.color = Color/* Color */.I.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);\n    }\n    const fill = svg.getAttribute("fill");\n    if (fill && fill !== "none") {\n      useFill = true;\n      fillStyle.color = Color/* Color */.I.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\n\n//# sourceMappingURL=SVGParser.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs\nvar convertFillInputToFillStyle = __webpack_require__(4915);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst tmpPoint = new Point/* Point */.E();\nconst tempMatrix = new Matrix/* Matrix */.y();\nconst _GraphicsContext = class _GraphicsContext extends eventemitter3/* default */.Z {\n  constructor() {\n    super(...arguments);\n    this.uid = (0,uid/* uid */.h)("graphicsContext");\n    this.dirty = true;\n    this.batchMode = "auto";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix/* Matrix */.y();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds/* Bounds */.Y();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: "texture",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color/* Color */.I.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style) {\n      if (alpha !== void 0 && typeof style === "number") {\n        (0,deprecation/* deprecation */.a)(deprecation/* v8_0_0 */.P, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: "fill",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point/* Point */.E.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyleInputs parameter to define the stroke\'s appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style) {\n      this._strokeStyle = (0,convertFillInputToFillStyle/* convertFillInputToFillStyle */.w)(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: "stroke",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc\'s center.\n   * @param y - The y-coordinate of the arc\'s center.\n   * @param radius - The arc\'s radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc\'s radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse\'s x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc\'s end point.\n   * @param y - The y-coordinate of the arc\'s end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === "moveTo") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle\'s corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon\'s vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star\'s points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix/* Matrix */.y) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit("update", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === "fill") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === "texture") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === "stroke") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it\'s contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === "fill") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: "butt",\n  /** The line join style to use. */\n  join: "miter",\n  /** The texture to use for the fill. */\n  texture: Texture/* Texture */.x.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\n\n//# sourceMappingURL=GraphicsContext.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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STtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEI7OztBQ3hCMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsUUFBUTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEI7OztBQzVDZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanM/ZGU0NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvQ2lyY2xlLm1qcz9lYmZkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL3NoYXBlcy9FbGxpcHNlLm1qcz81OWEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL21hdGhzL21pc2Mvc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanM/NTc2MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUG9seWdvbi5tanM/MWIyZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9tYXRocy9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanM/ZDU0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcz8zMzIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9idWlsZENvbW1hbmRzL2J1aWxkQWRhcHRpdmVRdWFkcmF0aWMubWpzPzM5MTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzP2E5OTkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmNUby5tanM/MDc4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZEFyY1RvU3ZnLm1qcz9mZDY2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL3JvdW5kU2hhcGUubWpzPzFiM2EiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3BhdGgvU2hhcGVQYXRoLm1qcz80ZTBlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9wYXRoL0dyYXBoaWNzUGF0aC5tanM/YTRlNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvc3ZnL1NWR1BhcnNlci5tanM/YmY2OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0Lm1qcz9hZmY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXJzZSBmcm9tICdwYXJzZS1zdmctcGF0aCc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gU1ZHVG9HcmFwaGljc1BhdGgoc3ZnUGF0aCwgcGF0aCkge1xuICBjb25zdCBjb21tYW5kcyA9IHBhcnNlKHN2Z1BhdGgpO1xuICBjb25zdCBzdWJwYXRocyA9IFtdO1xuICBsZXQgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICBsZXQgbGFzdFggPSAwO1xuICBsZXQgbGFzdFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSBjb21tYW5kWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBjb21tYW5kO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgbGFzdFggPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSA9IGRhdGFbMl07XG4gICAgICAgIHBhdGgubW92ZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5tb3ZlVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgbGFzdFggKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVlwiOlxuICAgICAgICBsYXN0WSA9IGRhdGFbMV07XG4gICAgICAgIHBhdGgubGluZVRvKGxhc3RYLCBsYXN0WSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgbGFzdFkgKz0gZGF0YVsxXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIGxhc3RZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgbGFzdFkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs1XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzZdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF0sXG4gICAgICAgICAgbGFzdFggKyBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RZICsgZGF0YVs2XVxuICAgICAgICApO1xuICAgICAgICBsYXN0WCArPSBkYXRhWzVdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzZdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzRdO1xuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBkYXRhWzFdLFxuICAgICAgICAgIGRhdGFbMl0sXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICBwYXRoLmJlemllckN1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUVwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbM107XG4gICAgICAgIGxhc3RZID0gZGF0YVs0XTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHBhdGgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBsYXN0WCArIGRhdGFbMV0sXG4gICAgICAgICAgbGFzdFkgKyBkYXRhWzJdLFxuICAgICAgICAgIGxhc3RYICsgZGF0YVszXSxcbiAgICAgICAgICBsYXN0WSArIGRhdGFbNF1cbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFggKz0gZGF0YVszXTtcbiAgICAgICAgbGFzdFkgKz0gZGF0YVs0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVFwiOlxuICAgICAgICBsYXN0WCA9IGRhdGFbMV07XG4gICAgICAgIGxhc3RZID0gZGF0YVsyXTtcbiAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoXG4gICAgICAgICAgbGFzdFgsXG4gICAgICAgICAgbGFzdFlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidFwiOlxuICAgICAgICBsYXN0WCArPSBkYXRhWzFdO1xuICAgICAgICBsYXN0WSArPSBkYXRhWzJdO1xuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG9TaG9ydChcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgIGxhc3RYID0gZGF0YVs2XTtcbiAgICAgICAgbGFzdFkgPSBkYXRhWzddO1xuICAgICAgICBwYXRoLmFyY1RvU3ZnKFxuICAgICAgICAgIGRhdGFbMV0sXG4gICAgICAgICAgZGF0YVsyXSxcbiAgICAgICAgICBkYXRhWzNdLFxuICAgICAgICAgIGRhdGFbNF0sXG4gICAgICAgICAgZGF0YVs1XSxcbiAgICAgICAgICBsYXN0WCxcbiAgICAgICAgICBsYXN0WVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIGxhc3RYICs9IGRhdGFbNl07XG4gICAgICAgIGxhc3RZICs9IGRhdGFbN107XG4gICAgICAgIHBhdGguYXJjVG9TdmcoXG4gICAgICAgICAgZGF0YVsxXSxcbiAgICAgICAgICBkYXRhWzJdLFxuICAgICAgICAgIGRhdGFbM10sXG4gICAgICAgICAgZGF0YVs0XSxcbiAgICAgICAgICBkYXRhWzVdLFxuICAgICAgICAgIGxhc3RYLFxuICAgICAgICAgIGxhc3RZXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlpcIjpcbiAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChzdWJwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudFN1YlBhdGggPSBzdWJwYXRocy5wb3AoKTtcbiAgICAgICAgICBpZiAoY3VycmVudFN1YlBhdGgpIHtcbiAgICAgICAgICAgIGxhc3RYID0gY3VycmVudFN1YlBhdGguc3RhcnRYO1xuICAgICAgICAgICAgbGFzdFkgPSBjdXJyZW50U3ViUGF0aC5zdGFydFk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RYID0gMDtcbiAgICAgICAgICAgIGxhc3RZID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFN1YlBhdGggPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYFVua25vd24gU1ZHIHBhdGggY29tbWFuZDogJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPT0gXCJaXCIgJiYgdHlwZSAhPT0gXCJ6XCIpIHtcbiAgICAgIGlmIChjdXJyZW50U3ViUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50U3ViUGF0aCA9IHsgc3RhcnRYOiBsYXN0WCwgc3RhcnRZOiBsYXN0WSB9O1xuICAgICAgICBzdWJwYXRocy5wdXNoKGN1cnJlbnRTdWJQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCB7IFNWR1RvR3JhcGhpY3NQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TVkdUb0dyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENpcmNsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHJhZGl1cyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICogQGRlZmF1bHQgJ2NpcmNsZSdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcImNpcmNsZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMucmFkaXVzIDw9IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIGxldCBkeCA9IHRoaXMueCAtIHg7XG4gICAgbGV0IGR5ID0gdGhpcy55IC0geTtcbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcbiAgICByZXR1cm4gZHggKyBkeSA8PSByMjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGUgaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAqL1xuICBzdHJva2VDb250YWlucyh4LCB5LCB3aWR0aCkge1xuICAgIGlmICh0aGlzLnJhZGl1cyA9PT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkeCA9IHRoaXMueCAtIHg7XG4gICAgY29uc3QgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCB3MiA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIGRpc3RhbmNlIDwgciArIHcyICYmIGRpc3RhbmNlID4gciAtIHcyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcGFyYW0gb3V0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LnggPSB0aGlzLnggLSB0aGlzLnJhZGl1cztcbiAgICBvdXQueSA9IHRoaXMueSAtIHRoaXMucmFkaXVzO1xuICAgIG91dC53aWR0aCA9IHRoaXMucmFkaXVzICogMjtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5yYWRpdXMgKiAyO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIGNpcmNsZSB0byB0aGlzIG9uZS5cbiAgICogQHBhcmFtIGNpcmNsZSAtIFRoZSBjaXJjbGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKGNpcmNsZSkge1xuICAgIHRoaXMueCA9IGNpcmNsZS54O1xuICAgIHRoaXMueSA9IGNpcmNsZS55O1xuICAgIHRoaXMucmFkaXVzID0gY2lyY2xlLnJhZGl1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgY2lyY2xlIHRvIGFub3RoZXIgb25lLlxuICAgKiBAcGFyYW0gY2lyY2xlIC0gVGhlIGNpcmNsZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhjaXJjbGUpIHtcbiAgICBjaXJjbGUuY29weUZyb20odGhpcyk7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6Q2lyY2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHJhZGl1cz0ke3RoaXMucmFkaXVzfV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IENpcmNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgRWxsaXBzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGxpcHNlXG4gICAqIEBwYXJhbSBoYWxmV2lkdGggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAgICogQHBhcmFtIGhhbGZIZWlnaHQgLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIGhhbGZXaWR0aCA9IDAsIGhhbGZIZWlnaHQgPSAwKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqIEBkZWZhdWx0ICdlbGxpcHNlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwiZWxsaXBzZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGhhbGZXaWR0aDtcbiAgICB0aGlzLmhhbGZIZWlnaHQgPSBoYWxmSGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtFbGxpcHNlfSBBIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy5oYWxmV2lkdGgsIHRoaXMuaGFsZkhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKiBAcGFyYW0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5oYWxmV2lkdGggPD0gMCB8fCB0aGlzLmhhbGZIZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLmhhbGZXaWR0aDtcbiAgICBsZXQgbm9ybXkgPSAoeSAtIHRoaXMueSkgLyB0aGlzLmhhbGZIZWlnaHQ7XG4gICAgbm9ybXggKj0gbm9ybXg7XG4gICAgbm9ybXkgKj0gbm9ybXk7XG4gICAgcmV0dXJuIG5vcm14ICsgbm9ybXkgPD0gMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlIGluY2x1ZGluZyBzdHJva2VcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gd2lkdGhcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgd2lkdGgpIHtcbiAgICBjb25zdCB7IGhhbGZXaWR0aCwgaGFsZkhlaWdodCB9ID0gdGhpcztcbiAgICBpZiAoaGFsZldpZHRoIDw9IDAgfHwgaGFsZkhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lckEgPSBoYWxmV2lkdGggLSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgaW5uZXJCID0gaGFsZkhlaWdodCAtIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBvdXRlckEgPSBoYWxmV2lkdGggKyBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgY29uc3Qgb3V0ZXJCID0gaGFsZkhlaWdodCArIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCBub3JtYWxpemVkWCA9IHggLSB0aGlzLng7XG4gICAgY29uc3Qgbm9ybWFsaXplZFkgPSB5IC0gdGhpcy55O1xuICAgIGNvbnN0IGlubmVyRWxsaXBzZSA9IG5vcm1hbGl6ZWRYICogbm9ybWFsaXplZFggLyAoaW5uZXJBICogaW5uZXJBKSArIG5vcm1hbGl6ZWRZICogbm9ybWFsaXplZFkgLyAoaW5uZXJCICogaW5uZXJCKTtcbiAgICBjb25zdCBvdXRlckVsbGlwc2UgPSBub3JtYWxpemVkWCAqIG5vcm1hbGl6ZWRYIC8gKG91dGVyQSAqIG91dGVyQSkgKyBub3JtYWxpemVkWSAqIG5vcm1hbGl6ZWRZIC8gKG91dGVyQiAqIG91dGVyQik7XG4gICAgcmV0dXJuIGlubmVyRWxsaXBzZSA+IDEgJiYgb3V0ZXJFbGxpcHNlIDw9IDE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgKiBAcmV0dXJucyBUaGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICovXG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLmhhbGZXaWR0aCwgdGhpcy55IC0gdGhpcy5oYWxmSGVpZ2h0LCB0aGlzLmhhbGZXaWR0aCAqIDIsIHRoaXMuaGFsZkhlaWdodCAqIDIpO1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYW5vdGhlciBlbGxpcHNlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gZWxsaXBzZSAtIFRoZSBlbGxpcHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybnMgUmV0dXJucyBpdHNlbGYuXG4gICAqL1xuICBjb3B5RnJvbShlbGxpcHNlKSB7XG4gICAgdGhpcy54ID0gZWxsaXBzZS54O1xuICAgIHRoaXMueSA9IGVsbGlwc2UueTtcbiAgICB0aGlzLmhhbGZXaWR0aCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgIHRoaXMuaGFsZkhlaWdodCA9IGVsbGlwc2UuaGFsZkhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgZWxsaXBzZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIGVsbGlwc2UgLSBUaGUgZWxsaXBzZSB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhlbGxpcHNlKSB7XG4gICAgZWxsaXBzZS5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gZWxsaXBzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6RWxsaXBzZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSBoYWxmV2lkdGg9JHt0aGlzLmhhbGZXaWR0aH0gaGFsZkhlaWdodD0ke3RoaXMuaGFsZkhlaWdodH1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBFbGxpcHNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbGxpcHNlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBhID0geCAtIHgxO1xuICBjb25zdCBiID0geSAtIHkxO1xuICBjb25zdCBjID0geDIgLSB4MTtcbiAgY29uc3QgZCA9IHkyIC0geTE7XG4gIGNvbnN0IGRvdCA9IGEgKiBjICsgYiAqIGQ7XG4gIGNvbnN0IGxlblNxID0gYyAqIGMgKyBkICogZDtcbiAgbGV0IHBhcmFtID0gLTE7XG4gIGlmIChsZW5TcSAhPT0gMCkge1xuICAgIHBhcmFtID0gZG90IC8gbGVuU3E7XG4gIH1cbiAgbGV0IHh4O1xuICBsZXQgeXk7XG4gIGlmIChwYXJhbSA8IDApIHtcbiAgICB4eCA9IHgxO1xuICAgIHl5ID0geTE7XG4gIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyBwYXJhbSAqIGM7XG4gICAgeXkgPSB5MSArIHBhcmFtICogZDtcbiAgfVxuICBjb25zdCBkeCA9IHggLSB4eDtcbiAgY29uc3QgZHkgPSB5IC0geXk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZXhwb3J0IHsgc3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3F1YXJlZERpc3RhbmNlVG9MaW5lU2VnbWVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50IH0gZnJvbSAnLi4vbWlzYy9zcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFBvbHlnb24ge1xuICAvKipcbiAgICogQHBhcmFtIHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgKiAgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLCBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvclxuICAgKiAgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy5cbiAgICogIGBuZXcgUG9seWdvbihuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgKiAgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmUgTnVtYmVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLnBvaW50cykge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKiBAZGVmYXVsdCAncG9seWdvbidcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBcInBvbHlnb25cIjtcbiAgICBsZXQgZmxhdCA9IEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSA/IHBvaW50c1swXSA6IHBvaW50cztcbiAgICBpZiAodHlwZW9mIGZsYXRbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGZsYXQubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwLnB1c2goZmxhdFtpXS54LCBmbGF0W2ldLnkpO1xuICAgICAgfVxuICAgICAgZmxhdCA9IHA7XG4gICAgfVxuICAgIHRoaXMucG9pbnRzID0gZmxhdDtcbiAgICB0aGlzLmNsb3NlUGF0aCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlUGF0aCA9IHRoaXMuY2xvc2VQYXRoO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdC5cbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvbi5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIGNvbnN0IHhpID0gdGhpcy5wb2ludHNbaSAqIDJdO1xuICAgICAgY29uc3QgeWkgPSB0aGlzLnBvaW50c1tpICogMiArIDFdO1xuICAgICAgY29uc3QgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICBjb25zdCB5aiA9IHRoaXMucG9pbnRzW2ogKiAyICsgMV07XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSArIHhpO1xuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb24gaW5jbHVkaW5nIHRoZSBzdHJva2UuXG4gICAqIEBwYXJhbSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICogQHBhcmFtIHN0cm9rZVdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMoeCwgeSwgc3Ryb2tlV2lkdGgpIHtcbiAgICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoU3FyZCA9IGhhbGZTdHJva2VXaWR0aCAqIGhhbGZTdHJva2VXaWR0aDtcbiAgICBjb25zdCB7IHBvaW50cyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeDEgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCB5MSA9IHBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCB4MiA9IHBvaW50c1soaSArIDIpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgICBjb25zdCB5MiA9IHBvaW50c1soaSArIDMpICUgcG9pbnRzLmxlbmd0aF07XG4gICAgICBjb25zdCBkaXN0YW5jZVNxcmQgPSBzcXVhcmVkRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIGlmIChkaXN0YW5jZVNxcmQgPD0gaGFsZlN0cm9rZVdpZHRoU3FyZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgcG9seWdvbiBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHBhcmFtIG91dCAtIG9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuICAgIG91dC54ID0gbWluWDtcbiAgICBvdXQud2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICBvdXQueSA9IG1pblk7XG4gICAgb3V0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBhbm90aGVyIHBvbHlnb24gdG8gdGhpcyBvbmUuXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHBvbHlnb24gdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGl0c2VsZi5cbiAgICovXG4gIGNvcHlGcm9tKHBvbHlnb24pIHtcbiAgICB0aGlzLnBvaW50cyA9IHBvbHlnb24ucG9pbnRzLnNsaWNlKCk7XG4gICAgdGhpcy5jbG9zZVBhdGggPSBwb2x5Z29uLmNsb3NlUGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29waWVzIHRoaXMgcG9seWdvbiB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUgcG9seWdvbiB0byBjb3B5IHRvLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGdpdmVuIHBhcmFtZXRlci5cbiAgICovXG4gIGNvcHlUbyhwb2x5Z29uKSB7XG4gICAgcG9seWdvbi5jb3B5RnJvbSh0aGlzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtwaXhpLmpzL21hdGg6UG9seWdvbmNsb3NlU3Ryb2tlPSR7dGhpcy5jbG9zZVBhdGh9cG9pbnRzPSR7dGhpcy5wb2ludHMucmVkdWNlKChwb2ludHNEZXNjLCBjdXJyZW50UG9pbnQpID0+IGAke3BvaW50c0Rlc2N9LCAke2N1cnJlbnRQb2ludH1gLCBcIlwiKX1dYDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvblxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGFzdFkoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvblxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAyXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9seWdvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9seWdvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzQ29ybmVyV2l0aGluU3Ryb2tlID0gKHBYLCBwWSwgY29ybmVyWCwgY29ybmVyWSwgcmFkaXVzLCBoYWxmU3Ryb2tlV2lkdGgpID0+IHtcbiAgY29uc3QgZHggPSBwWCAtIGNvcm5lclg7XG4gIGNvbnN0IGR5ID0gcFkgLSBjb3JuZXJZO1xuICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBkaXN0YW5jZSA+PSByYWRpdXMgLSBoYWxmU3Ryb2tlV2lkdGggJiYgZGlzdGFuY2UgPD0gcmFkaXVzICsgaGFsZlN0cm9rZVdpZHRoO1xufTtcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICAvKipcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAgICogQHBhcmFtIHJhZGl1cyAtIENvbnRyb2xzIHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kZWQgY29ybmVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHJhZGl1cyA9IDIwKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqIEBkZWZhdWx0ICdyb3VuZGVkUmVjdGFuZ2xlJ1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFwicm91bmRlZFJlY3RhbmdsZVwiO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICogQHBhcmFtIG91dCAtIG9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAqIEByZXR1cm5zIFRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgKi9cbiAgZ2V0Qm91bmRzKG91dCkge1xuICAgIG91dCA9IG91dCB8fCBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgb3V0LnggPSB0aGlzLng7XG4gICAgb3V0LnkgPSB0aGlzLnk7XG4gICAgb3V0LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBvdXQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGUuXG4gICAqIEByZXR1cm5zIC0gQSBjb3B5IG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICAvKipcbiAgICogQ29waWVzIGFub3RoZXIgcmVjdGFuZ2xlIHRvIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IGZyb20uXG4gICAqIEByZXR1cm5zIFJldHVybnMgaXRzZWxmLlxuICAgKi9cbiAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cbiAgICogQHBhcmFtIHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSB0by5cbiAgICogQHJldHVybnMgUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLmNvcHlGcm9tKHRoaXMpO1xuICAgIHJldHVybiByZWN0YW5nbGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcbiAgICogQHBhcmFtIHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0LlxuICAgKiBAcGFyYW0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIC0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZS5cbiAgICovXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5yYWRpdXMsIE1hdGgubWluKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSAvIDIpKTtcbiAgICAgICAgaWYgKHkgPj0gdGhpcy55ICsgcmFkaXVzICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMgfHwgeCA+PSB0aGlzLnggKyByYWRpdXMgJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBsZXQgZHkgPSB5IC0gKHRoaXMueSArIHJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHJhZGl1czIgPSByYWRpdXMgKiByYWRpdXM7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMud2lkdGggLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHJhZGl1cyk7XG4gICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZSBpbmNsdWRpbmcgdGhlIHN0cm9rZS5cbiAgICogQHBhcmFtIHBYIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gcFkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAqIEBwYXJhbSBzdHJva2VXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgbGluZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHJlY3RhbmdsZVxuICAgKi9cbiAgc3Ryb2tlQ29udGFpbnMocFgsIHBZLCBzdHJva2VXaWR0aCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICBjb25zdCBpbm5lclggPSB4ICsgcmFkaXVzO1xuICAgIGNvbnN0IGlubmVyWSA9IHkgKyByYWRpdXM7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IHdpZHRoIC0gcmFkaXVzICogMjtcbiAgICBjb25zdCBpbm5lckhlaWdodCA9IGhlaWdodCAtIHJhZGl1cyAqIDI7XG4gICAgY29uc3QgcmlnaHRCb3VuZCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b21Cb3VuZCA9IHkgKyBoZWlnaHQ7XG4gICAgaWYgKChwWCA+PSB4IC0gaGFsZlN0cm9rZVdpZHRoICYmIHBYIDw9IHggKyBoYWxmU3Ryb2tlV2lkdGggfHwgcFggPj0gcmlnaHRCb3VuZCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWCA8PSByaWdodEJvdW5kICsgaGFsZlN0cm9rZVdpZHRoKSAmJiBwWSA+PSBpbm5lclkgJiYgcFkgPD0gaW5uZXJZICsgaW5uZXJIZWlnaHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHBZID49IHkgLSBoYWxmU3Ryb2tlV2lkdGggJiYgcFkgPD0geSArIGhhbGZTdHJva2VXaWR0aCB8fCBwWSA+PSBib3R0b21Cb3VuZCAtIGhhbGZTdHJva2VXaWR0aCAmJiBwWSA8PSBib3R0b21Cb3VuZCArIGhhbGZTdHJva2VXaWR0aCkgJiYgcFggPj0gaW5uZXJYICYmIHBYIDw9IGlubmVyWCArIGlubmVyV2lkdGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gVG9wLWxlZnRcbiAgICAgIHBYIDwgaW5uZXJYICYmIHBZIDwgaW5uZXJZICYmIGlzQ29ybmVyV2l0aGluU3Ryb2tlKHBYLCBwWSwgaW5uZXJYLCBpbm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSB8fCBwWCA+IHJpZ2h0Qm91bmQgLSByYWRpdXMgJiYgcFkgPCBpbm5lclkgJiYgaXNDb3JuZXJXaXRoaW5TdHJva2UocFgsIHBZLCByaWdodEJvdW5kIC0gcmFkaXVzLCBpbm5lclksIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKSB8fCBwWCA+IHJpZ2h0Qm91bmQgLSByYWRpdXMgJiYgcFkgPiBib3R0b21Cb3VuZCAtIHJhZGl1cyAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIHJpZ2h0Qm91bmQgLSByYWRpdXMsIGJvdHRvbUJvdW5kIC0gcmFkaXVzLCByYWRpdXMsIGhhbGZTdHJva2VXaWR0aCkgfHwgcFggPCBpbm5lclggJiYgcFkgPiBib3R0b21Cb3VuZCAtIHJhZGl1cyAmJiBpc0Nvcm5lcldpdGhpblN0cm9rZShwWCwgcFksIGlubmVyWCwgYm90dG9tQm91bmQgLSByYWRpdXMsIHJhZGl1cywgaGFsZlN0cm9rZVdpZHRoKVxuICAgICk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbcGl4aS5qcy9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3VuZGVkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IEdyYXBoaWNzQ29udGV4dFN5c3RlbSB9IGZyb20gJy4uL0dyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDg7XG5jb25zdCBGTFRfRVBTSUxPTiA9IDExOTIwOTI5ZS0xNDtcbmNvbnN0IFBBVEhfRElTVEFOQ0VfRVBTSUxPTiA9IDE7XG5jb25zdCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbiA9IDAuMDE7XG5jb25zdCBtQW5nbGVUb2xlcmFuY2UgPSAwO1xuY29uc3QgbUN1c3BMaW1pdCA9IDA7XG5mdW5jdGlvbiBidWlsZEFkYXB0aXZlQmV6aWVyKHBvaW50cywgc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHNtb290aG5lc3MpIHtcbiAgY29uc3Qgc2NhbGUgPSAxO1xuICBjb25zdCBzbW9vdGhpbmcgPSBNYXRoLm1pbihcbiAgICAwLjk5LFxuICAgIC8vIGEgdmFsdWUgb2YgMS4wIGFjdHVhbGx5IGludmVydHMgc21vb3RoaW5nLCBzbyB3ZSBjYXAgaXQgYXQgMC45OVxuICAgIE1hdGgubWF4KDAsIHNtb290aG5lc3MgPz8gR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MpXG4gICk7XG4gIGxldCBkaXN0YW5jZVRvbGVyYW5jZSA9IChQQVRIX0RJU1RBTkNFX0VQU0lMT04gLSBzbW9vdGhpbmcpIC8gc2NhbGU7XG4gIGRpc3RhbmNlVG9sZXJhbmNlICo9IGRpc3RhbmNlVG9sZXJhbmNlO1xuICBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBiZWdpbihzWCwgc1ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGVYLCBlWSwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICByZWN1cnNpdmUoc1gsIHNZLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBlWCwgZVksIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIDApO1xuICBwb2ludHMucHVzaChlWCwgZVkpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3QgeDEyID0gKHgxICsgeDIpIC8gMjtcbiAgY29uc3QgeTEyID0gKHkxICsgeTIpIC8gMjtcbiAgY29uc3QgeDIzID0gKHgyICsgeDMpIC8gMjtcbiAgY29uc3QgeTIzID0gKHkyICsgeTMpIC8gMjtcbiAgY29uc3QgeDM0ID0gKHgzICsgeDQpIC8gMjtcbiAgY29uc3QgeTM0ID0gKHkzICsgeTQpIC8gMjtcbiAgY29uc3QgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMjtcbiAgY29uc3QgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMjtcbiAgY29uc3QgeDIzNCA9ICh4MjMgKyB4MzQpIC8gMjtcbiAgY29uc3QgeTIzNCA9ICh5MjMgKyB5MzQpIC8gMjtcbiAgY29uc3QgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMjtcbiAgY29uc3QgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMjtcbiAgaWYgKGxldmVsID4gMCkge1xuICAgIGxldCBkeCA9IHg0IC0geDE7XG4gICAgbGV0IGR5ID0geTQgLSB5MTtcbiAgICBjb25zdCBkMiA9IE1hdGguYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpO1xuICAgIGNvbnN0IGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCk7XG4gICAgbGV0IGRhMTtcbiAgICBsZXQgZGEyO1xuICAgIGlmIChkMiA+IEZMVF9FUFNJTE9OICYmIGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgIGlmICgoZDIgKyBkMykgKiAoZDIgKyBkMykgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHggKiBkeCArIGR5ICogZHkpKSB7XG4gICAgICAgIGlmIChtQW5nbGVUb2xlcmFuY2UgPCBjdXJ2ZUFuZ2xlVG9sZXJhbmNlRXBzaWxvbikge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEyMyA9IE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4Mik7XG4gICAgICAgIGRhMSA9IE1hdGguYWJzKGEyMyAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgICBkYTIgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gYTIzKTtcbiAgICAgICAgaWYgKGRhMSA+PSBwaSlcbiAgICAgICAgICBkYTEgPSAyICogcGkgLSBkYTE7XG4gICAgICAgIGlmIChkYTIgPj0gcGkpXG4gICAgICAgICAgZGEyID0gMiAqIHBpIC0gZGEyO1xuICAgICAgICBpZiAoZGExICsgZGEyIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhMiA+IG1DdXNwTGltaXQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgzLCB5Myk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkMiA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICBpZiAoZDIgKiBkMiA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDEyMzQsIHkxMjM0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpO1xuICAgICAgICBpZiAoZGExID49IHBpKVxuICAgICAgICAgIGRhMSA9IDIgKiBwaSAtIGRhMTtcbiAgICAgICAgaWYgKGRhMSA8IG1BbmdsZVRvbGVyYW5jZSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHgyLCB5Mik7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDMsIHkzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1DdXNwTGltaXQgIT09IDApIHtcbiAgICAgICAgICBpZiAoZGExID4gbUN1c3BMaW1pdCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgIGlmIChkMyAqIGQzIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgICBpZiAobUFuZ2xlVG9sZXJhbmNlIDwgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24pIHtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MTIzNCwgeTEyMzQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYTEgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSk7XG4gICAgICAgIGlmIChkYTEgPj0gcGkpXG4gICAgICAgICAgZGExID0gMiAqIHBpIC0gZGExO1xuICAgICAgICBpZiAoZGExIDwgbUFuZ2xlVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeDIsIHkyKTtcbiAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobUN1c3BMaW1pdCAhPT0gMCkge1xuICAgICAgICAgIGlmIChkYTEgPiBtQ3VzcExpbWl0KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4MywgeTMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkeCA9IHgxMjM0IC0gKHgxICsgeDQpIC8gMjtcbiAgICAgIGR5ID0geTEyMzQgLSAoeTEgKyB5NCkgLyAyO1xuICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IGRpc3RhbmNlVG9sZXJhbmNlKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjM0LCB5MTIzNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVjdXJzaXZlKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbiAgcmVjdXJzaXZlKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBZGFwdGl2ZUJlemllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBZGFwdGl2ZUJlemllci5tanMubWFwXG4iLCJpbXBvcnQgeyBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfSBmcm9tICcuLi9HcmFwaGljc0NvbnRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSA4O1xuY29uc3QgRkxUX0VQU0lMT04gPSAxMTkyMDkyOWUtMTQ7XG5jb25zdCBQQVRIX0RJU1RBTkNFX0VQU0lMT04gPSAxO1xuY29uc3QgY3VydmVBbmdsZVRvbGVyYW5jZUVwc2lsb24gPSAwLjAxO1xuY29uc3QgbUFuZ2xlVG9sZXJhbmNlID0gMDtcbmZ1bmN0aW9uIGJ1aWxkQWRhcHRpdmVRdWFkcmF0aWMocG9pbnRzLCBzWCwgc1ksIGNwMXgsIGNwMXksIGVYLCBlWSwgc21vb3RobmVzcykge1xuICBjb25zdCBzY2FsZSA9IDE7XG4gIGNvbnN0IHNtb290aGluZyA9IE1hdGgubWluKFxuICAgIDAuOTksXG4gICAgLy8gYSB2YWx1ZSBvZiAxLjAgYWN0dWFsbHkgaW52ZXJ0cyBzbW9vdGhpbmcsIHNvIHdlIGNhcCBpdCBhdCAwLjk5XG4gICAgTWF0aC5tYXgoMCwgc21vb3RobmVzcyA/PyBHcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcylcbiAgKTtcbiAgbGV0IGRpc3RhbmNlVG9sZXJhbmNlID0gKFBBVEhfRElTVEFOQ0VfRVBTSUxPTiAtIHNtb290aGluZykgLyBzY2FsZTtcbiAgZGlzdGFuY2VUb2xlcmFuY2UgKj0gZGlzdGFuY2VUb2xlcmFuY2U7XG4gIGJlZ2luKHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIGJlZ2luKHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlKSB7XG4gIHJlY3Vyc2l2ZShwb2ludHMsIHNYLCBzWSwgY3AxeCwgY3AxeSwgZVgsIGVZLCBkaXN0YW5jZVRvbGVyYW5jZSwgMCk7XG4gIHBvaW50cy5wdXNoKGVYLCBlWSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmUocG9pbnRzLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgaWYgKGxldmVsID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBpID0gTWF0aC5QSTtcbiAgY29uc3QgeDEyID0gKHgxICsgeDIpIC8gMjtcbiAgY29uc3QgeTEyID0gKHkxICsgeTIpIC8gMjtcbiAgY29uc3QgeDIzID0gKHgyICsgeDMpIC8gMjtcbiAgY29uc3QgeTIzID0gKHkyICsgeTMpIC8gMjtcbiAgY29uc3QgeDEyMyA9ICh4MTIgKyB4MjMpIC8gMjtcbiAgY29uc3QgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMjtcbiAgbGV0IGR4ID0geDMgLSB4MTtcbiAgbGV0IGR5ID0geTMgLSB5MTtcbiAgY29uc3QgZCA9IE1hdGguYWJzKCh4MiAtIHgzKSAqIGR5IC0gKHkyIC0geTMpICogZHgpO1xuICBpZiAoZCA+IEZMVF9FUFNJTE9OKSB7XG4gICAgaWYgKGQgKiBkIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgICAgaWYgKG1BbmdsZVRvbGVyYW5jZSA8IGN1cnZlQW5nbGVUb2xlcmFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHgxMjMsIHkxMjMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGEgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHkzIC0geTIsIHgzIC0geDIpIC0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSk7XG4gICAgICBpZiAoZGEgPj0gcGkpXG4gICAgICAgIGRhID0gMiAqIHBpIC0gZGE7XG4gICAgICBpZiAoZGEgPCBtQW5nbGVUb2xlcmFuY2UpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeDEyMywgeTEyMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZHggPSB4MTIzIC0gKHgxICsgeDMpIC8gMjtcbiAgICBkeSA9IHkxMjMgLSAoeTEgKyB5MykgLyAyO1xuICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA8PSBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgcG9pbnRzLnB1c2goeDEyMywgeTEyMyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlY3Vyc2l2ZShwb2ludHMsIHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIGRpc3RhbmNlVG9sZXJhbmNlLCBsZXZlbCArIDEpO1xuICByZWN1cnNpdmUocG9pbnRzLCB4MTIzLCB5MTIzLCB4MjMsIHkyMywgeDMsIHkzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwgKyAxKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRBZGFwdGl2ZVF1YWRyYXRpYyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRBZGFwdGl2ZVF1YWRyYXRpYy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkQXJjKHBvaW50cywgeCwgeSwgcmFkaXVzLCBzdGFydCwgZW5kLCBjbG9ja3dpc2UsIHN0ZXBzKSB7XG4gIGxldCBkaXN0ID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICBpZiAoIWNsb2Nrd2lzZSAmJiBzdGFydCA+IGVuZCkge1xuICAgIGRpc3QgPSAyICogTWF0aC5QSSAtIGRpc3Q7XG4gIH0gZWxzZSBpZiAoY2xvY2t3aXNlICYmIGVuZCA+IHN0YXJ0KSB7XG4gICAgZGlzdCA9IDIgKiBNYXRoLlBJIC0gZGlzdDtcbiAgfVxuICBzdGVwcyA9IHN0ZXBzIHx8IE1hdGgubWF4KDYsIE1hdGguZmxvb3IoNiAqIE1hdGgucG93KHJhZGl1cywgMSAvIDMpICogKGRpc3QgLyBNYXRoLlBJKSkpO1xuICBzdGVwcyA9IE1hdGgubWF4KHN0ZXBzLCAzKTtcbiAgbGV0IGYgPSBkaXN0IC8gc3RlcHM7XG4gIGxldCB0ID0gc3RhcnQ7XG4gIGYgKj0gY2xvY2t3aXNlID8gLTEgOiAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzICsgMTsgaSsrKSB7XG4gICAgY29uc3QgY3MgPSBNYXRoLmNvcyh0KTtcbiAgICBjb25zdCBzbiA9IE1hdGguc2luKHQpO1xuICAgIGNvbnN0IG54ID0geCArIGNzICogcmFkaXVzO1xuICAgIGNvbnN0IG55ID0geSArIHNuICogcmFkaXVzO1xuICAgIHBvaW50cy5wdXNoKG54LCBueSk7XG4gICAgdCArPSBmO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkQXJjIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyYy5tanMubWFwXG4iLCJpbXBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4vYnVpbGRBcmMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBidWlsZEFyY1RvKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgY29uc3QgYTEgPSBmcm9tWSAtIHkxO1xuICBjb25zdCBiMSA9IGZyb21YIC0geDE7XG4gIGNvbnN0IGEyID0geTIgLSB5MTtcbiAgY29uc3QgYjIgPSB4MiAtIHgxO1xuICBjb25zdCBtbSA9IE1hdGguYWJzKGExICogYjIgLSBiMSAqIGEyKTtcbiAgaWYgKG1tIDwgMWUtOCB8fCByYWRpdXMgPT09IDApIHtcbiAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpIHtcbiAgICAgIHBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICBjb25zdCBjYyA9IGEyICogYTIgKyBiMiAqIGIyO1xuICBjb25zdCB0dCA9IGExICogYTIgKyBiMSAqIGIyO1xuICBjb25zdCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgY29uc3QgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW07XG4gIGNvbnN0IGoxID0gazEgKiB0dCAvIGRkO1xuICBjb25zdCBqMiA9IGsyICogdHQgLyBjYztcbiAgY29uc3QgY3ggPSBrMSAqIGIyICsgazIgKiBiMTtcbiAgY29uc3QgY3kgPSBrMSAqIGEyICsgazIgKiBhMTtcbiAgY29uc3QgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgY29uc3QgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgY29uc3QgcXggPSBiMiAqIChrMSArIGoyKTtcbiAgY29uc3QgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gIGNvbnN0IGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgYnVpbGRBcmMoXG4gICAgcG9pbnRzLFxuICAgIGN4ICsgeDEsXG4gICAgY3kgKyB5MSxcbiAgICByYWRpdXMsXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSxcbiAgICBiMSAqIGEyID4gYjIgKiBhMVxuICApO1xufVxuXG5leHBvcnQgeyBidWlsZEFyY1RvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZEFyY1RvLm1qcy5tYXBcbiIsImltcG9ydCB7IGJ1aWxkQWRhcHRpdmVCZXppZXIgfSBmcm9tICcuL2J1aWxkQWRhcHRpdmVCZXppZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBUQVUgPSBNYXRoLlBJICogMjtcbmNvbnN0IG91dCA9IHtcbiAgY2VudGVyWDogMCxcbiAgY2VudGVyWTogMCxcbiAgYW5nMTogMCxcbiAgYW5nMjogMFxufTtcbmNvbnN0IG1hcFRvRWxsaXBzZSA9ICh7IHgsIHkgfSwgcngsIHJ5LCBjb3NQaGksIHNpblBoaSwgY2VudGVyWCwgY2VudGVyWSwgb3V0MikgPT4ge1xuICB4ICo9IHJ4O1xuICB5ICo9IHJ5O1xuICBjb25zdCB4cCA9IGNvc1BoaSAqIHggLSBzaW5QaGkgKiB5O1xuICBjb25zdCB5cCA9IHNpblBoaSAqIHggKyBjb3NQaGkgKiB5O1xuICBvdXQyLnggPSB4cCArIGNlbnRlclg7XG4gIG91dDIueSA9IHlwICsgY2VudGVyWTtcbiAgcmV0dXJuIG91dDI7XG59O1xuZnVuY3Rpb24gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKSB7XG4gIGNvbnN0IGExID0gYW5nMiA9PT0gLTEuNTcwNzk2MzI2Nzk0ODk2NiA/IC0wLjU1MTkxNTAyNDQ5NCA6IDQgLyAzICogTWF0aC50YW4oYW5nMiAvIDQpO1xuICBjb25zdCBhID0gYW5nMiA9PT0gMS41NzA3OTYzMjY3OTQ4OTY2ID8gMC41NTE5MTUwMjQ0OTQgOiBhMTtcbiAgY29uc3QgeDEgPSBNYXRoLmNvcyhhbmcxKTtcbiAgY29uc3QgeTEgPSBNYXRoLnNpbihhbmcxKTtcbiAgY29uc3QgeDIgPSBNYXRoLmNvcyhhbmcxICsgYW5nMik7XG4gIGNvbnN0IHkyID0gTWF0aC5zaW4oYW5nMSArIGFuZzIpO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHg6IHgxIC0geTEgKiBhLFxuICAgICAgeTogeTEgKyB4MSAqIGFcbiAgICB9LFxuICAgIHtcbiAgICAgIHg6IHgyICsgeTIgKiBhLFxuICAgICAgeTogeTIgLSB4MiAqIGFcbiAgICB9LFxuICAgIHtcbiAgICAgIHg6IHgyLFxuICAgICAgeTogeTJcbiAgICB9XG4gIF07XG59XG5jb25zdCB2ZWN0b3JBbmdsZSA9ICh1eCwgdXksIHZ4LCB2eSkgPT4ge1xuICBjb25zdCBzaWduID0gdXggKiB2eSAtIHV5ICogdnggPCAwID8gLTEgOiAxO1xuICBsZXQgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG4gIGlmIChkb3QgPiAxKSB7XG4gICAgZG90ID0gMTtcbiAgfVxuICBpZiAoZG90IDwgLTEpIHtcbiAgICBkb3QgPSAtMTtcbiAgfVxuICByZXR1cm4gc2lnbiAqIE1hdGguYWNvcyhkb3QpO1xufTtcbmNvbnN0IGdldEFyY0NlbnRlciA9IChweCwgcHksIGN4LCBjeSwgcngsIHJ5LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgc2luUGhpLCBjb3NQaGksIHB4cCwgcHlwLCBvdXQyKSA9PiB7XG4gIGNvbnN0IHJ4U3EgPSBNYXRoLnBvdyhyeCwgMik7XG4gIGNvbnN0IHJ5U3EgPSBNYXRoLnBvdyhyeSwgMik7XG4gIGNvbnN0IHB4cFNxID0gTWF0aC5wb3cocHhwLCAyKTtcbiAgY29uc3QgcHlwU3EgPSBNYXRoLnBvdyhweXAsIDIpO1xuICBsZXQgcmFkaWNhbnQgPSByeFNxICogcnlTcSAtIHJ4U3EgKiBweXBTcSAtIHJ5U3EgKiBweHBTcTtcbiAgaWYgKHJhZGljYW50IDwgMCkge1xuICAgIHJhZGljYW50ID0gMDtcbiAgfVxuICByYWRpY2FudCAvPSByeFNxICogcHlwU3EgKyByeVNxICogcHhwU3E7XG4gIHJhZGljYW50ID0gTWF0aC5zcXJ0KHJhZGljYW50KSAqIChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSk7XG4gIGNvbnN0IGNlbnRlclhwID0gcmFkaWNhbnQgKiByeCAvIHJ5ICogcHlwO1xuICBjb25zdCBjZW50ZXJZcCA9IHJhZGljYW50ICogLXJ5IC8gcnggKiBweHA7XG4gIGNvbnN0IGNlbnRlclggPSBjb3NQaGkgKiBjZW50ZXJYcCAtIHNpblBoaSAqIGNlbnRlcllwICsgKHB4ICsgY3gpIC8gMjtcbiAgY29uc3QgY2VudGVyWSA9IHNpblBoaSAqIGNlbnRlclhwICsgY29zUGhpICogY2VudGVyWXAgKyAocHkgKyBjeSkgLyAyO1xuICBjb25zdCB2eDEgPSAocHhwIC0gY2VudGVyWHApIC8gcng7XG4gIGNvbnN0IHZ5MSA9IChweXAgLSBjZW50ZXJZcCkgLyByeTtcbiAgY29uc3QgdngyID0gKC1weHAgLSBjZW50ZXJYcCkgLyByeDtcbiAgY29uc3QgdnkyID0gKC1weXAgLSBjZW50ZXJZcCkgLyByeTtcbiAgY29uc3QgYW5nMSA9IHZlY3RvckFuZ2xlKDEsIDAsIHZ4MSwgdnkxKTtcbiAgbGV0IGFuZzIgPSB2ZWN0b3JBbmdsZSh2eDEsIHZ5MSwgdngyLCB2eTIpO1xuICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFuZzIgPiAwKSB7XG4gICAgYW5nMiAtPSBUQVU7XG4gIH1cbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhbmcyIDwgMCkge1xuICAgIGFuZzIgKz0gVEFVO1xuICB9XG4gIG91dDIuY2VudGVyWCA9IGNlbnRlclg7XG4gIG91dDIuY2VudGVyWSA9IGNlbnRlclk7XG4gIG91dDIuYW5nMSA9IGFuZzE7XG4gIG91dDIuYW5nMiA9IGFuZzI7XG59O1xuZnVuY3Rpb24gYnVpbGRBcmNUb1N2Zyhwb2ludHMsIHB4LCBweSwgY3gsIGN5LCByeCwgcnksIHhBeGlzUm90YXRpb24gPSAwLCBsYXJnZUFyY0ZsYWcgPSAwLCBzd2VlcEZsYWcgPSAwKSB7XG4gIGlmIChyeCA9PT0gMCB8fCByeSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uICogVEFVIC8gMzYwKTtcbiAgY29uc3QgY29zUGhpID0gTWF0aC5jb3MoeEF4aXNSb3RhdGlvbiAqIFRBVSAvIDM2MCk7XG4gIGNvbnN0IHB4cCA9IGNvc1BoaSAqIChweCAtIGN4KSAvIDIgKyBzaW5QaGkgKiAocHkgLSBjeSkgLyAyO1xuICBjb25zdCBweXAgPSAtc2luUGhpICogKHB4IC0gY3gpIC8gMiArIGNvc1BoaSAqIChweSAtIGN5KSAvIDI7XG4gIGlmIChweHAgPT09IDAgJiYgcHlwID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgY29uc3QgbGFtYmRhID0gTWF0aC5wb3cocHhwLCAyKSAvIE1hdGgucG93KHJ4LCAyKSArIE1hdGgucG93KHB5cCwgMikgLyBNYXRoLnBvdyhyeSwgMik7XG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gIH1cbiAgZ2V0QXJjQ2VudGVyKFxuICAgIHB4LFxuICAgIHB5LFxuICAgIGN4LFxuICAgIGN5LFxuICAgIHJ4LFxuICAgIHJ5LFxuICAgIGxhcmdlQXJjRmxhZyxcbiAgICBzd2VlcEZsYWcsXG4gICAgc2luUGhpLFxuICAgIGNvc1BoaSxcbiAgICBweHAsXG4gICAgcHlwLFxuICAgIG91dFxuICApO1xuICBsZXQgeyBhbmcxLCBhbmcyIH0gPSBvdXQ7XG4gIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSB9ID0gb3V0O1xuICBsZXQgcmF0aW8gPSBNYXRoLmFicyhhbmcyKSAvIChUQVUgLyA0KTtcbiAgaWYgKE1hdGguYWJzKDEgLSByYXRpbykgPCAxZS03KSB7XG4gICAgcmF0aW8gPSAxO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gTWF0aC5tYXgoTWF0aC5jZWlsKHJhdGlvKSwgMSk7XG4gIGFuZzIgLz0gc2VnbWVudHM7XG4gIGxldCBsYXN0WCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gIGxldCBsYXN0WSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG91dEN1cnZlUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgY29uc3QgY3VydmUgPSBhcHByb3hVbml0QXJjKGFuZzEsIGFuZzIpO1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBtYXBUb0VsbGlwc2UoY3VydmVbMF0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dEN1cnZlUG9pbnQpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBtYXBUb0VsbGlwc2UoY3VydmVbMV0sIHJ4LCByeSwgY29zUGhpLCBzaW5QaGksIGNlbnRlclgsIGNlbnRlclksIG91dEN1cnZlUG9pbnQpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwVG9FbGxpcHNlKGN1cnZlWzJdLCByeCwgcnksIGNvc1BoaSwgc2luUGhpLCBjZW50ZXJYLCBjZW50ZXJZLCBvdXRDdXJ2ZVBvaW50KTtcbiAgICBidWlsZEFkYXB0aXZlQmV6aWVyKFxuICAgICAgcG9pbnRzLFxuICAgICAgbGFzdFgsXG4gICAgICBsYXN0WSxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICApO1xuICAgIGxhc3RYID0geDtcbiAgICBsYXN0WSA9IHk7XG4gICAgYW5nMSArPSBhbmcyO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkQXJjVG9TdmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQXJjVG9TdmcubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiByb3VuZGVkU2hhcGVBcmMoZywgcG9pbnRzLCByYWRpdXMpIHtcbiAgY29uc3QgdmVjRnJvbSA9IChwLCBwcCkgPT4ge1xuICAgIGNvbnN0IHggPSBwcC54IC0gcC54O1xuICAgIGNvbnN0IHkgPSBwcC55IC0gcC55O1xuICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjb25zdCBueCA9IHggLyBsZW47XG4gICAgY29uc3QgbnkgPSB5IC8gbGVuO1xuICAgIHJldHVybiB7IGxlbiwgbngsIG55IH07XG4gIH07XG4gIGNvbnN0IHNoYXJwQ29ybmVyID0gKGksIHApID0+IHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZy5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmxpbmVUbyhwLngsIHAueSk7XG4gICAgfVxuICB9O1xuICBsZXQgcDEgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAyID0gcG9pbnRzW2kgJSBwb2ludHMubGVuZ3RoXTtcbiAgICBjb25zdCBwUmFkaXVzID0gcDIucmFkaXVzID8/IHJhZGl1cztcbiAgICBpZiAocFJhZGl1cyA8PSAwKSB7XG4gICAgICBzaGFycENvcm5lcihpLCBwMik7XG4gICAgICBwMSA9IHAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHAzID0gcG9pbnRzWyhpICsgMSkgJSBwb2ludHMubGVuZ3RoXTtcbiAgICBjb25zdCB2MSA9IHZlY0Zyb20ocDIsIHAxKTtcbiAgICBjb25zdCB2MiA9IHZlY0Zyb20ocDIsIHAzKTtcbiAgICBpZiAodjEubGVuIDwgMWUtNCB8fCB2Mi5sZW4gPCAxZS00KSB7XG4gICAgICBzaGFycENvcm5lcihpLCBwMik7XG4gICAgICBwMSA9IHAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBhbmdsZSA9IE1hdGguYXNpbih2MS5ueCAqIHYyLm55IC0gdjEubnkgKiB2Mi5ueCk7XG4gICAgbGV0IHJhZERpcmVjdGlvbiA9IDE7XG4gICAgbGV0IGRyYXdEaXJlY3Rpb24gPSBmYWxzZTtcbiAgICBpZiAodjEubnggKiB2Mi5ueCAtIHYxLm55ICogLXYyLm55IDwgMCkge1xuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5QSSAtIGFuZ2xlO1xuICAgICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJhZERpcmVjdGlvbiA9IC0xO1xuICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMjtcbiAgICBsZXQgY1JhZGl1cztcbiAgICBsZXQgbGVuT3V0ID0gTWF0aC5hYnMoXG4gICAgICBNYXRoLmNvcyhoYWxmQW5nbGUpICogcFJhZGl1cyAvIE1hdGguc2luKGhhbGZBbmdsZSlcbiAgICApO1xuICAgIGlmIChsZW5PdXQgPiBNYXRoLm1pbih2MS5sZW4gLyAyLCB2Mi5sZW4gLyAyKSkge1xuICAgICAgbGVuT3V0ID0gTWF0aC5taW4odjEubGVuIC8gMiwgdjIubGVuIC8gMik7XG4gICAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjUmFkaXVzID0gcFJhZGl1cztcbiAgICB9XG4gICAgY29uc3QgY1ggPSBwMi54ICsgdjIubnggKiBsZW5PdXQgKyAtdjIubnkgKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAgIGNvbnN0IGNZID0gcDIueSArIHYyLm55ICogbGVuT3V0ICsgdjIubnggKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHYxLm55LCB2MS5ueCkgKyBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIodjIubnksIHYyLm54KSAtIE1hdGguUEkgLyAyICogcmFkRGlyZWN0aW9uO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLm1vdmVUbyhcbiAgICAgICAgY1ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIGNSYWRpdXMsXG4gICAgICAgIGNZICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiBjUmFkaXVzXG4gICAgICApO1xuICAgIH1cbiAgICBnLmFyYyhjWCwgY1ksIGNSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkcmF3RGlyZWN0aW9uKTtcbiAgICBwMSA9IHAyO1xuICB9XG59XG5mdW5jdGlvbiByb3VuZGVkU2hhcGVRdWFkcmF0aWNDdXJ2ZShnLCBwb2ludHMsIHJhZGl1cywgc21vb3RobmVzcykge1xuICBjb25zdCBkaXN0YW5jZSA9IChwMSwgcDIpID0+IE1hdGguc3FydCgocDEueCAtIHAyLngpICoqIDIgKyAocDEueSAtIHAyLnkpICoqIDIpO1xuICBjb25zdCBwb2ludExlcnAgPSAocDEsIHAyLCB0KSA9PiAoe1xuICAgIHg6IHAxLnggKyAocDIueCAtIHAxLngpICogdCxcbiAgICB5OiBwMS55ICsgKHAyLnkgLSBwMS55KSAqIHRcbiAgfSk7XG4gIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzUG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIG51bVBvaW50c107XG4gICAgY29uc3QgcFJhZGl1cyA9IHRoaXNQb2ludC5yYWRpdXMgPz8gcmFkaXVzO1xuICAgIGlmIChwUmFkaXVzIDw9IDApIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGcubW92ZVRvKHRoaXNQb2ludC54LCB0aGlzUG9pbnQueSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnLmxpbmVUbyh0aGlzUG9pbnQueCwgdGhpc1BvaW50LnkpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tpXTtcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAyKSAlIG51bVBvaW50c107XG4gICAgY29uc3QgbGFzdEVkZ2VMZW5ndGggPSBkaXN0YW5jZShsYXN0UG9pbnQsIHRoaXNQb2ludCk7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGlmIChsYXN0RWRnZUxlbmd0aCA8IDFlLTQpIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1BvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0RGlzdGFuY2UgPSBNYXRoLm1pbihsYXN0RWRnZUxlbmd0aCAvIDIsIHBSYWRpdXMpO1xuICAgICAgc3RhcnQgPSBwb2ludExlcnAoXG4gICAgICAgIHRoaXNQb2ludCxcbiAgICAgICAgbGFzdFBvaW50LFxuICAgICAgICBsYXN0T2Zmc2V0RGlzdGFuY2UgLyBsYXN0RWRnZUxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEVkZ2VMZW5ndGggPSBkaXN0YW5jZShuZXh0UG9pbnQsIHRoaXNQb2ludCk7XG4gICAgbGV0IGVuZDtcbiAgICBpZiAobmV4dEVkZ2VMZW5ndGggPCAxZS00KSB7XG4gICAgICBlbmQgPSB0aGlzUG9pbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5leHRPZmZzZXREaXN0YW5jZSA9IE1hdGgubWluKG5leHRFZGdlTGVuZ3RoIC8gMiwgcFJhZGl1cyk7XG4gICAgICBlbmQgPSBwb2ludExlcnAoXG4gICAgICAgIHRoaXNQb2ludCxcbiAgICAgICAgbmV4dFBvaW50LFxuICAgICAgICBuZXh0T2Zmc2V0RGlzdGFuY2UgLyBuZXh0RWRnZUxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnLmxpbmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICB9XG4gICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKHRoaXNQb2ludC54LCB0aGlzUG9pbnQueSwgZW5kLngsIGVuZC55LCBzbW9vdGhuZXNzKTtcbiAgfVxufVxuXG5leHBvcnQgeyByb3VuZGVkU2hhcGVBcmMsIHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3VuZFNoYXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IENpcmNsZSB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9DaXJjbGUubWpzJztcbmltcG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvRWxsaXBzZS5tanMnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL3NoYXBlcy9Qb2x5Z29uLm1qcyc7XG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JvdW5kZWRSZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFkYXB0aXZlQmV6aWVyIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlQmV6aWVyLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFkYXB0aXZlUXVhZHJhdGljIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZEFkYXB0aXZlUXVhZHJhdGljLm1qcyc7XG5pbXBvcnQgeyBidWlsZEFyYyB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRBcmMubWpzJztcbmltcG9ydCB7IGJ1aWxkQXJjVG8gfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG8ubWpzJztcbmltcG9ydCB7IGJ1aWxkQXJjVG9TdmcgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQXJjVG9TdmcubWpzJztcbmltcG9ydCB7IHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlLCByb3VuZGVkU2hhcGVBcmMgfSBmcm9tICcuL3JvdW5kU2hhcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgpO1xuY2xhc3MgU2hhcGVQYXRoIHtcbiAgY29uc3RydWN0b3IoZ3JhcGhpY3NQYXRoMkQpIHtcbiAgICAvKiogVGhlIGxpc3Qgb2Ygc2hhcGUgcHJpbWl0aXZlcyB0aGF0IG1ha2UgdXAgdGhlIHBhdGguICovXG4gICAgdGhpcy5zaGFwZVByaW1pdGl2ZXMgPSBbXTtcbiAgICB0aGlzLl9jdXJyZW50UG9seSA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICAgIHRoaXMuX2dyYXBoaWNzUGF0aDJEID0gZ3JhcGhpY3NQYXRoMkQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBhIG5ldyBzdWItcGF0aC4gQW55IHN1YnNlcXVlbnQgZHJhd2luZyBjb21tYW5kcyBhcmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoaXMgcGF0aC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIGZvciB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBmb3IgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5zdGFydFBvbHkoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRoZSBjdXJyZW50IHBvaW50IHRvIGEgbmV3IHBvaW50IHdpdGggYSBzdHJhaWdodCBsaW5lLiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl9lbnN1cmVQb2x5KCk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGZyb21YICE9PSB4IHx8IGZyb21ZICE9PSB5KSB7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBwYXRoLiBUaGUgYXJjIGlzIGNlbnRlcmVkIGF0ICh4LCB5KVxuICAgKiAgcG9zaXRpb24gd2l0aCByYWRpdXMgYHJhZGl1c2Agc3RhcnRpbmcgYXQgYHN0YXJ0QW5nbGVgIGFuZCBlbmRpbmcgYXQgYGVuZEFuZ2xlYC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBjZW50ZXIuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgY2VudGVyLlxuICAgKiBAcGFyYW0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjLlxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgYXJjLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlIG9mIHRoZSBhcmMsIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSBjb3VudGVyY2xvY2t3aXNlIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGFyYyBzaG91bGQgYmUgZHJhd24gaW4gdGhlIGFudGljbG9ja3dpc2UgZGlyZWN0aW9uLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyY2xvY2t3aXNlKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seShmYWxzZSk7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGJ1aWxkQXJjKHBvaW50cywgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBwYXRoIHdpdGggdGhlIGFyYyB0YW5nZW50IHRvIHRoZSBsaW5lIGpvaW5pbmcgdHdvIHNwZWNpZmllZCBwb2ludHMuXG4gICAqIFRoZSBhcmMgcmFkaXVzIGlzIHNwZWNpZmllZCBieSBgcmFkaXVzYC5cbiAgICogQHBhcmFtIHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB5MSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cztcbiAgICBidWlsZEFyY1RvKHBvaW50cywgeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gU1ZHLXN0eWxlIGFyYyB0byB0aGUgcGF0aCwgYWxsb3dpbmcgZm9yIGVsbGlwdGljYWwgYXJjcyBiYXNlZCBvbiB0aGUgU1ZHIHNwZWMuXG4gICAqIEBwYXJhbSByeCAtIFRoZSB4LXJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJ5IC0gVGhlIHktcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geEF4aXNSb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBvZiB0aGUgZWxsaXBzZSdzIHgtYXhpcyByZWxhdGl2ZVxuICAgKiB0byB0aGUgeC1heGlzIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSwgaW4gZGVncmVlcy5cbiAgICogQHBhcmFtIGxhcmdlQXJjRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cbiAgICogQHBhcmFtIHN3ZWVwRmxhZyAtIERldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgc3dlcHQgaW4gYSBwb3NpdGl2ZSBhbmdsZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGVuZCBwb2ludC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUb1N2ZyhyeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY3VycmVudFBvbHkucG9pbnRzO1xuICAgIGJ1aWxkQXJjVG9TdmcoXG4gICAgICBwb2ludHMsXG4gICAgICB0aGlzLl9jdXJyZW50UG9seS5sYXN0WCxcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5Lmxhc3RZLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGxhcmdlQXJjRmxhZyxcbiAgICAgIHN3ZWVwRmxhZ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjdWJpYyBCZXppZXIgY3VydmUgdG8gdGhlIHBhdGguXG4gICAqIEl0IHJlcXVpcmVzIHRocmVlIHBvaW50czogdGhlIGZpcnN0IHR3byBhcmUgY29udHJvbCBwb2ludHMgYW5kIHRoZSB0aGlyZCBvbmUgaXMgdGhlIGVuZCBwb2ludC5cbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDF4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIGNwMXkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AyeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSBzbW9vdGhuZXNzIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzKSB7XG4gICAgdGhpcy5fZW5zdXJlUG9seSgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb2x5ID0gdGhpcy5fY3VycmVudFBvbHk7XG4gICAgYnVpbGRBZGFwdGl2ZUJlemllcihcbiAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cyxcbiAgICAgIGN1cnJlbnRQb2x5Lmxhc3RYLFxuICAgICAgY3VycmVudFBvbHkubGFzdFksXG4gICAgICBjcDF4LFxuICAgICAgY3AxeSxcbiAgICAgIGNwMngsXG4gICAgICBjcDJ5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBzbW9vdGhuZXNzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgcmVxdWlyZXMgdHdvIHBvaW50czogdGhlIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuXG4gICAqIFRoZSBzdGFydGluZyBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgY3VycmVudCBwYXRoLlxuICAgKiBAcGFyYW0gY3AxeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDF5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RoaW5nIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIGFkanVzdCB0aGUgc21vb3RobmVzcyBvZiB0aGUgY3VydmUuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbyhjcDF4LCBjcDF5LCB4LCB5LCBzbW9vdGhpbmcpIHtcbiAgICB0aGlzLl9lbnN1cmVQb2x5KCk7XG4gICAgY29uc3QgY3VycmVudFBvbHkgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBidWlsZEFkYXB0aXZlUXVhZHJhdGljKFxuICAgICAgdGhpcy5fY3VycmVudFBvbHkucG9pbnRzLFxuICAgICAgY3VycmVudFBvbHkubGFzdFgsXG4gICAgICBjdXJyZW50UG9seS5sYXN0WSxcbiAgICAgIGNwMXgsXG4gICAgICBjcDF5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBzbW9vdGhpbmdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCBieSBkcmF3aW5nIGEgc3RyYWlnaHQgbGluZSBiYWNrIHRvIHRoZSBzdGFydC5cbiAgICogSWYgdGhlIHNoYXBlIGlzIGFscmVhZHkgY2xvc2VkIG9yIHRoZXJlIGFyZSBubyBwb2ludHMgaW4gdGhlIHBhdGgsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5lbmRQb2x5KHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgcGF0aCB0byB0aGUgY3VycmVudCBwYXRoLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjb21iaW5hdGlvbiBvZiBtdWx0aXBsZSBwYXRocyBpbnRvIG9uZS5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgYEdyYXBoaWNzUGF0aGAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byBhZGQuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcGF0aCBiZWZvcmUgYWRkaW5nIGl0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZFBhdGgocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5lbmRQb2x5KCk7XG4gICAgaWYgKHRyYW5zZm9ybSAmJiAhdHJhbnNmb3JtLmlzSWRlbnRpdHkoKSkge1xuICAgICAgcGF0aCA9IHBhdGguY2xvbmUodHJ1ZSk7XG4gICAgICBwYXRoLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGguaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHBhdGguaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdGhpc1tpbnN0cnVjdGlvbi5hY3Rpb25dKC4uLmluc3RydWN0aW9uLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBkcmF3aW5nIG9mIHRoZSBjdXJyZW50IHBhdGguIE9wdGlvbmFsbHksIGl0IGNhbiBjbG9zZSB0aGUgcGF0aC5cbiAgICogQHBhcmFtIGNsb3NlUGF0aCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHBhdGggYWZ0ZXIgZmluaXNoaW5nLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgKi9cbiAgZmluaXNoKGNsb3NlUGF0aCA9IGZhbHNlKSB7XG4gICAgdGhpcy5lbmRQb2x5KGNsb3NlUGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgdywgaCksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBDaXJjbGUoeCwgeSwgcmFkaXVzKSwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHNoYXBlLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvbiBvZiBjb21wbGV4IHBvbHlnb25zIGJ5IHNwZWNpZnlpbmcgYSBzZXF1ZW5jZSBvZiBwb2ludHMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBvciBhbiBhcnJheSBvZiBQb2ludERhdGEgb2JqZWN0cyBlZyBbe3gseX0sIHt4LHl9LCB7eCx5fV1cbiAgICogcmVwcmVzZW50aW5nIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uJ3MgdmVydGljZXMsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0gY2xvc2UgLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwb2x5Z29uIHBhdGguIFRydWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIGBNYXRyaXhgIG9iamVjdCB0byBhcHBseSBhIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHBvbHkocG9pbnRzLCBjbG9zZSwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgcG9seWdvbi5jbG9zZVBhdGggPSBjbG9zZTtcbiAgICB0aGlzLmRyYXdTaGFwZShwb2x5Z29uLCB0cmFuc2Zvcm0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlZ3VsYXIgcG9seWdvbiB3aXRoIGEgc3BlY2lmaWVkIG51bWJlciBvZiBzaWRlcy4gQWxsIHNpZGVzIGFuZCBhbmdsZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgcG9seWdvbiwgaW4gcmFkaWFucy4gWmVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24gPSAwLCB0cmFuc2Zvcm0pIHtcbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHwgMCwgMyk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDIgKyByb3RhdGlvbjtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gICAgY29uc3QgcG9seWdvbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY29uc3QgYW5nbGUgPSBpICogZGVsdGEgKyBzdGFydEFuZ2xlO1xuICAgICAgcG9seWdvbi5wdXNoKFxuICAgICAgICB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnBvbHkocG9seWdvbiwgdHJ1ZSwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBTaW1pbGFyIHRvIGByZWd1bGFyUG9seWAgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gcm91bmQgdGhlIGNvcm5lcnMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmN1bXNjcmliZWQgY2lyY2xlIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gc2lkZXMgLSBUaGUgbnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBNdXN0IGJlIDMgb3IgbW9yZS5cbiAgICogQHBhcmFtIGNvcm5lciAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kaW5nIG9mIHRoZSBjb3JuZXJzLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSByb3VuZGluZy5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgY29ybmVyLCByb3RhdGlvbiA9IDAsIHNtb290aG5lc3MpIHtcbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHwgMCwgMyk7XG4gICAgaWYgKGNvcm5lciA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWd1bGFyUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCByb3RhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHNpZGVMZW5ndGggPSByYWRpdXMgKiBNYXRoLnNpbihNYXRoLlBJIC8gc2lkZXMpIC0gMWUtMztcbiAgICBjb3JuZXIgPSBNYXRoLm1pbihjb3JuZXIsIHNpZGVMZW5ndGgpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyICsgcm90YXRpb247XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIHNpZGVzO1xuICAgIGNvbnN0IGludGVybmFsQW5nbGUgPSAoc2lkZXMgLSAyKSAqIE1hdGguUEkgLyBzaWRlcyAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBkZWx0YSArIHN0YXJ0QW5nbGU7XG4gICAgICBjb25zdCB4MCA9IHggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBjb25zdCB5MCA9IHkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBjb25zdCBhMSA9IGFuZ2xlICsgTWF0aC5QSSArIGludGVybmFsQW5nbGU7XG4gICAgICBjb25zdCBhMiA9IGFuZ2xlIC0gTWF0aC5QSSAtIGludGVybmFsQW5nbGU7XG4gICAgICBjb25zdCB4MSA9IHgwICsgY29ybmVyICogTWF0aC5jb3MoYTEpO1xuICAgICAgY29uc3QgeTEgPSB5MCArIGNvcm5lciAqIE1hdGguc2luKGExKTtcbiAgICAgIGNvbnN0IHgzID0geDAgKyBjb3JuZXIgKiBNYXRoLmNvcyhhMik7XG4gICAgICBjb25zdCB5MyA9IHkwICsgY29ybmVyICogTWF0aC5zaW4oYTIpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGluZVRvKHgxLCB5MSk7XG4gICAgICB9XG4gICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oeDAsIHkwLCB4MywgeTMsIHNtb290aG5lc3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzaGFwZSB3aXRoIHJvdW5kZWQgY29ybmVycy4gVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjdXN0b20gcmFkaXVzIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgc2hhcGUuXG4gICAqIE9wdGlvbmFsbHksIGNvcm5lcnMgY2FuIGJlIHJvdW5kZWQgdXNpbmcgYSBxdWFkcmF0aWMgY3VydmUgaW5zdGVhZCBvZiBhbiBhcmMsIHByb3ZpZGluZyBhIGRpZmZlcmVudCBhZXN0aGV0aWMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBgUm91bmRlZFBvaW50YCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHNoYXBlIHRvIGRyYXcuXG4gICAqIEEgbWluaW11bSBvZiAzIHBvaW50cyBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBkZWZhdWx0IHJhZGl1cyBmb3IgdGhlIGNvcm5lcnMuXG4gICAqIFRoaXMgcmFkaXVzIGlzIGFwcGxpZWQgdG8gYWxsIGNvcm5lcnMgdW5sZXNzIG92ZXJyaWRkZW4gaW4gYHBvaW50c2AuXG4gICAqIEBwYXJhbSB1c2VRdWFkcmF0aWMgLSBJZiBzZXQgdG8gdHJ1ZSwgcm91bmRlZCBjb3JuZXJzIGFyZSBkcmF3biB1c2luZyBhIHF1YWRyYXRpY0N1cnZlXG4gICAqICBtZXRob2QgaW5zdGVhZCBvZiBhbiBhcmMgbWV0aG9kLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBTcGVjaWZpZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlIHdoZW4gYHVzZVF1YWRyYXRpY2AgaXMgdHJ1ZS5cbiAgICogSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBjdXJ2ZSBzbW9vdGhlci5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMgPSBmYWxzZSwgc21vb3RobmVzcykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh1c2VRdWFkcmF0aWMpIHtcbiAgICAgIHJvdW5kZWRTaGFwZVF1YWRyYXRpY0N1cnZlKHRoaXMsIHBvaW50cywgcmFkaXVzLCBzbW9vdGhuZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRlZFNoYXBlQXJjKHRoaXMsIHBvaW50cywgcmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXcgUmVjdGFuZ2xlIHdpdGggZmlsbGV0IGNvcm5lcnMuIFRoaXMgaXMgbXVjaCBsaWtlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAqIGhvd2V2ZXIgaXQgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzIGFzIHdlbGwgZm9yIHRoZSBjb3JuZXIgcmFkaXVzLlxuICAgKiBAcGFyYW0geCAtIFVwcGVyIGxlZnQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHkgLSBVcHBlciByaWdodCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiByZWN0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgcmVjdFxuICAgKiBAcGFyYW0gZmlsbGV0IC0gYWNjZXB0IG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHZhbHVlc1xuICAgKi9cbiAgZmlsbGV0UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsZXQpIHtcbiAgICBpZiAoZmlsbGV0ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBtYXhGaWxsZXQgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgY29uc3QgaW5zZXQgPSBNYXRoLm1pbihtYXhGaWxsZXQsIE1hdGgubWF4KC1tYXhGaWxsZXQsIGZpbGxldCkpO1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIHdpZHRoO1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBoZWlnaHQ7XG4gICAgY29uc3QgZGlyID0gaW5zZXQgPCAwID8gLWluc2V0IDogMDtcbiAgICBjb25zdCBzaXplID0gTWF0aC5hYnMoaW5zZXQpO1xuICAgIHJldHVybiB0aGlzLm1vdmVUbyh4LCB5ICsgc2l6ZSkuYXJjVG8oeCArIGRpciwgeSArIGRpciwgeCArIHNpemUsIHksIHNpemUpLmxpbmVUbyhyaWdodCAtIHNpemUsIHkpLmFyY1RvKHJpZ2h0IC0gZGlyLCB5ICsgZGlyLCByaWdodCwgeSArIHNpemUsIHNpemUpLmxpbmVUbyhyaWdodCwgYm90dG9tIC0gc2l6ZSkuYXJjVG8ocmlnaHQgLSBkaXIsIGJvdHRvbSAtIGRpciwgeCArIHdpZHRoIC0gc2l6ZSwgYm90dG9tLCBzaXplKS5saW5lVG8oeCArIHNpemUsIGJvdHRvbSkuYXJjVG8oeCArIGRpciwgYm90dG9tIC0gZGlyLCB4LCBib3R0b20gLSBzaXplLCBzaXplKS5jbG9zZVBhdGgoKTtcbiAgfVxuICAvKipcbiAgICogRHJhdyBSZWN0YW5nbGUgd2l0aCBjaGFtZmVyIGNvcm5lcnMuIFRoZXNlIGFyZSBhbmdsZWQgY29ybmVycy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGNoYW1mZXIgLSBub24temVybyByZWFsIG51bWJlciwgc2l6ZSBvZiBjb3JuZXIgY3V0b3V0XG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1cbiAgICovXG4gIGNoYW1mZXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW1mZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmIChjaGFtZmVyIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGluc2V0ID0gTWF0aC5taW4oY2hhbWZlciwgTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyKTtcbiAgICBjb25zdCByaWdodCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIHggKyBpbnNldCxcbiAgICAgIHksXG4gICAgICByaWdodCAtIGluc2V0LFxuICAgICAgeSxcbiAgICAgIHJpZ2h0LFxuICAgICAgeSArIGluc2V0LFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20gLSBpbnNldCxcbiAgICAgIHJpZ2h0IC0gaW5zZXQsXG4gICAgICBib3R0b20sXG4gICAgICB4ICsgaW5zZXQsXG4gICAgICBib3R0b20sXG4gICAgICB4LFxuICAgICAgYm90dG9tIC0gaW5zZXQsXG4gICAgICB4LFxuICAgICAgeSArIGluc2V0XG4gICAgXTtcbiAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMjsgaSAtPSAyKSB7XG4gICAgICBpZiAocG9pbnRzW2ldID09PSBwb2ludHNbaSAtIDJdICYmIHBvaW50c1tpIC0gMV0gPT09IHBvaW50c1tpIC0gM10pIHtcbiAgICAgICAgcG9pbnRzLnNwbGljZShpIC0gMSwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvbHkocG9pbnRzLCB0cnVlLCB0cmFuc2Zvcm0pO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhbiBlbGxpcHNlIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gYW5kIHdpdGggdGhlIGdpdmVuIHggYW5kIHkgcmFkaWkuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCBhbGxvd2luZyBmb3Igcm90YXRpb24sIHNjYWxpbmcsIGFuZCB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcmFkaXVzWCAtIFRoZSBob3Jpem9udGFsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1kgLSBUaGUgdmVydGljYWwgcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGVsbGlwc2UuIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IEVsbGlwc2UoeCwgeSwgcmFkaXVzWCwgcmFkaXVzWSksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBUaGUgY29ybmVyIHJhZGl1cyBjYW4gYmUgc3BlY2lmaWVkIHRvIGRldGVybWluZSBob3cgcm91bmRlZCB0aGUgY29ybmVycyBzaG91bGQgYmUuXG4gICAqIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBhcHBsaWVkLCB3aGljaCBhbGxvd3MgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGUncyBjb3JuZXJzLiBJZiBub3Qgc3BlY2lmaWVkLCBjb3JuZXJzIHdpbGwgYmUgc2hhcnAuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHcsIGgsIHJhZGl1cyksIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgZ2l2ZW4gc2hhcGUgb24gdGhlIGNhbnZhcy5cbiAgICogVGhpcyBpcyBhIGdlbmVyaWMgbWV0aG9kIHRoYXQgY2FuIGRyYXcgYW55IHR5cGUgb2Ygc2hhcGUgc3BlY2lmaWVkIGJ5IHRoZSBgU2hhcGVQcmltaXRpdmVgIHBhcmFtZXRlci5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gbWF0cml4IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZSwgYWxsb3dpbmcgZm9yIGNvbXBsZXggdHJhbnNmb3JtYXRpb25zLlxuICAgKiBAcGFyYW0gc2hhcGUgLSBUaGUgc2hhcGUgdG8gZHJhdywgZGVmaW5lZCBhcyBhIGBTaGFwZVByaW1pdGl2ZWAgb2JqZWN0LlxuICAgKiBAcGFyYW0gbWF0cml4IC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgZm9yIHRyYW5zZm9ybWluZyB0aGUgc2hhcGUuIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLFxuICAgKiBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGRyYXdTaGFwZShzaGFwZSwgbWF0cml4KSB7XG4gICAgdGhpcy5lbmRQb2x5KCk7XG4gICAgdGhpcy5zaGFwZVByaW1pdGl2ZXMucHVzaCh7IHNoYXBlLCB0cmFuc2Zvcm06IG1hdHJpeCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIGEgbmV3IHBvbHlnb24gcGF0aCBmcm9tIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgcG9pbnQuXG4gICAqIFRoaXMgbWV0aG9kIGluaXRpYWxpemVzIGEgbmV3IHBvbHlnb24gb3IgZW5kcyB0aGUgY3VycmVudCBvbmUgaWYgaXQgZXhpc3RzLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBuZXcgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbmV3IHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgc3RhcnRQb2x5KHgsIHkpIHtcbiAgICBsZXQgY3VycmVudFBvbHkgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBpZiAoY3VycmVudFBvbHkpIHtcbiAgICAgIHRoaXMuZW5kUG9seSgpO1xuICAgIH1cbiAgICBjdXJyZW50UG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgY3VycmVudFBvbHkucG9pbnRzLnB1c2goeCwgeSk7XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBjdXJyZW50UG9seTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5kcyB0aGUgY3VycmVudCBwb2x5Z29uIHBhdGguIElmIGBjbG9zZVBhdGhgIGlzIHNldCB0byB0cnVlLFxuICAgKiB0aGUgcGF0aCBpcyBjbG9zZWQgYnkgY29ubmVjdGluZyB0aGUgbGFzdCBwb2ludCB0byB0aGUgZmlyc3Qgb25lLlxuICAgKiBUaGlzIG1ldGhvZCBmaW5hbGl6ZXMgdGhlIGN1cnJlbnQgcG9seWdvbiBhbmQgcHJlcGFyZXMgaXQgZm9yIGRyYXdpbmcgb3IgYWRkaW5nIHRvIHRoZSBzaGFwZSBwcmltaXRpdmVzLlxuICAgKiBAcGFyYW0gY2xvc2VQYXRoIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBjbG9zZSB0aGUgcG9seWdvbiBieSBjb25uZWN0aW5nIHRoZSBsYXN0IHBvaW50XG4gICAqICBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbmRQb2x5KGNsb3NlUGF0aCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9jdXJyZW50UG9seTtcbiAgICBpZiAoc2hhcGUgJiYgc2hhcGUucG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHNoYXBlLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLnB1c2goeyBzaGFwZSB9KTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9lbnN1cmVQb2x5KHN0YXJ0ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50UG9seSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9jdXJyZW50UG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBjb25zdCBsYXN0U2hhcGUgPSB0aGlzLnNoYXBlUHJpbWl0aXZlc1t0aGlzLnNoYXBlUHJpbWl0aXZlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0U2hhcGUpIHtcbiAgICAgICAgbGV0IGx4ID0gbGFzdFNoYXBlLnNoYXBlLng7XG4gICAgICAgIGxldCBseSA9IGxhc3RTaGFwZS5zaGFwZS55O1xuICAgICAgICBpZiAoIWxhc3RTaGFwZS50cmFuc2Zvcm0uaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgY29uc3QgdCA9IGxhc3RTaGFwZS50cmFuc2Zvcm07XG4gICAgICAgICAgY29uc3QgdGVtcFggPSBseDtcbiAgICAgICAgICBseCA9IHQuYSAqIGx4ICsgdC5jICogbHkgKyB0LnR4O1xuICAgICAgICAgIGx5ID0gdC5iICogdGVtcFggKyB0LmQgKiBseSArIHQudHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudFBvbHkucG9pbnRzLnB1c2gobHgsIGx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQb2x5LnBvaW50cy5wdXNoKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQnVpbGRzIHRoZSBwYXRoLiAqL1xuICBidWlsZFBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuX2dyYXBoaWNzUGF0aDJEO1xuICAgIHRoaXMuc2hhcGVQcmltaXRpdmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY3VycmVudFBvbHkgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gcGF0aC5pbnN0cnVjdGlvbnNbaV07XG4gICAgICB0aGlzW2luc3RydWN0aW9uLmFjdGlvbl0oLi4uaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoKCk7XG4gIH1cbiAgLyoqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgcGF0aC4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgY29uc3Qgc2hhcGVQcmltaXRpdmVzID0gdGhpcy5zaGFwZVByaW1pdGl2ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZVByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYXBlUHJpbWl0aXZlID0gc2hhcGVQcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgYm91bmRzUmVjdCA9IHNoYXBlUHJpbWl0aXZlLnNoYXBlLmdldEJvdW5kcyh0ZW1wUmVjdGFuZ2xlKTtcbiAgICAgIGlmIChzaGFwZVByaW1pdGl2ZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgYm91bmRzLmFkZFJlY3QoYm91bmRzUmVjdCwgc2hhcGVQcmltaXRpdmUudHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5hZGRSZWN0KGJvdW5kc1JlY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoYXBlUGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhcGVQYXRoLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBTVkdUb0dyYXBoaWNzUGF0aCB9IGZyb20gJy4uL3N2Zy9TVkdUb0dyYXBoaWNzUGF0aC5tanMnO1xuaW1wb3J0IHsgU2hhcGVQYXRoIH0gZnJvbSAnLi9TaGFwZVBhdGgubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBHcmFwaGljc1BhdGgge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGBHcmFwaGljc1BhdGhgIGluc3RhbmNlIG9wdGlvbmFsbHkgZnJvbSBhbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAuXG4gICAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgLSBBbiBTVkcgcGF0aCBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgYFBhdGhJbnN0cnVjdGlvbmAgb2JqZWN0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RydWN0aW9ucykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgdGhpcy51aWQgPSB1aWQoXCJncmFwaGljc1BhdGhcIik7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBTVkdUb0dyYXBoaWNzUGF0aChpbnN0cnVjdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucz8uc2xpY2UoKSA/PyBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW50ZXJuYWwgc2hhcGUgcGF0aCwgZW5zdXJpbmcgaXQgaXMgdXAtdG8tZGF0ZSB3aXRoIHRoZSBjdXJyZW50IGluc3RydWN0aW9ucy5cbiAgICogQHJldHVybnMgVGhlIGBTaGFwZVBhdGhgIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBHcmFwaGljc1BhdGhgLlxuICAgKi9cbiAgZ2V0IHNoYXBlUGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX3NoYXBlUGF0aCkge1xuICAgICAgdGhpcy5fc2hhcGVQYXRoID0gbmV3IFNoYXBlUGF0aCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2hhcGVQYXRoLmJ1aWxkUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcGVQYXRoO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgYEdyYXBoaWNzUGF0aGAgdG8gdGhpcyBwYXRoLCBvcHRpb25hbGx5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIHRvIGFkZC5cbiAgICogQHBhcmFtIHRyYW5zZm9ybSAtIEFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBhZGRlZCBwYXRoLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFkZFBhdGgocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgcGF0aCA9IHBhdGguY2xvbmUoKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImFkZFBhdGhcIiwgZGF0YTogW3BhdGgsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyYyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJhcmNcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXJjVG9TdmcoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiYXJjVG9TdmdcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgY3ViaWMgQmV6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxuICAgKiBJdCByZXF1aXJlcyB0d28gcG9pbnRzOiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgYW5kIHRoZSBlbmQgcG9pbnQuIFRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmVcbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcDJ4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvU2hvcnQoY3AyeCwgY3AyeSwgeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcDF4ID0gMDtcbiAgICBsZXQgY3AxeSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcImJlemllckN1cnZlVG9cIikge1xuICAgICAgY3AxeCA9IGxhc3RQb2ludC54O1xuICAgICAgY3AxeSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcDF4ID0gbGFzdC5kYXRhWzJdO1xuICAgICAgY3AxeSA9IGxhc3QuZGF0YVszXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3AxeCA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3AxeCk7XG4gICAgICBjcDF5ID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcDF5KTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJiZXppZXJDdXJ2ZVRvXCIsIGRhdGE6IFtjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoIGJ5IGRyYXdpbmcgYSBzdHJhaWdodCBsaW5lIGJhY2sgdG8gdGhlIHN0YXJ0LlxuICAgKiBJZiB0aGUgc2hhcGUgaXMgYWxyZWFkeSBjbG9zZWQgb3IgdGhlcmUgYXJlIG5vIHBvaW50cyBpbiB0aGUgcGF0aCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcImNsb3NlUGF0aFwiLCBkYXRhOiBbXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZWxsaXBzZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJlbGxpcHNlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpbmVUbyguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJsaW5lVG9cIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbW92ZVRvKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcIm1vdmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHF1YWRyYXRpY0N1cnZlVG8oLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicXVhZHJhdGljQ3VydmVUb1wiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgcGF0aC4gSXQgdXNlcyB0aGUgcHJldmlvdXMgcG9pbnQgYXMgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvU2hvcnQoeCwgeSwgc21vb3RobmVzcykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLmluc3RydWN0aW9uc1t0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmdldExhc3RQb2ludChQb2ludC5zaGFyZWQpO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgaWYgKCFsYXN0IHx8IGxhc3QuYWN0aW9uICE9PSBcInF1YWRyYXRpY0N1cnZlVG9cIikge1xuICAgICAgY3B4MSA9IGxhc3RQb2ludC54O1xuICAgICAgY3B5MSA9IGxhc3RQb2ludC55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjcHgxID0gbGFzdC5kYXRhWzBdO1xuICAgICAgY3B5MSA9IGxhc3QuZGF0YVsxXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRYID0gbGFzdFBvaW50Lng7XG4gICAgICBjb25zdCBjdXJyZW50WSA9IGxhc3RQb2ludC55O1xuICAgICAgY3B4MSA9IGN1cnJlbnRYICsgKGN1cnJlbnRYIC0gY3B4MSk7XG4gICAgICBjcHkxID0gY3VycmVudFkgKyAoY3VycmVudFkgLSBjcHkxKTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsIGRhdGE6IFtjcHgxLCBjcHkxLCB4LCB5LCBzbW9vdGhuZXNzXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHJlY3RhbmdsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB3IC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwicmVjdFwiLCBkYXRhOiBbeCwgeSwgdywgaCwgdHJhbnNmb3JtXSB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIGEgY2lyY2xlIHNoYXBlLiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IGNpcmNsZSBwYXRoIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBBbiBvcHRpb25hbCBgTWF0cml4YCBvYmplY3QgdG8gYXBwbHkgYSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiY2lyY2xlXCIsIGRhdGE6IFt4LCB5LCByYWRpdXMsIHRyYW5zZm9ybV0gfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFJlY3RcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJwb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ3VsYXJQb2x5KC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBcInJlZ3VsYXJQb2x5XCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kUG9seSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFBvbHlcIiwgZGF0YTogYXJncyB9KTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm91bmRTaGFwZSguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJyb3VuZFNoYXBlXCIsIGRhdGE6IGFyZ3MgfSk7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbGxldFJlY3QoLi4uYXJncykge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goeyBhY3Rpb246IFwiZmlsbGV0UmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjaGFtZmVyUmVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh7IGFjdGlvbjogXCJjaGFtZmVyUmVjdFwiLCBkYXRhOiBhcmdzIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IGEgc3BlY2lmaWVkIGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvblxuICAgKiAgb2Ygc3RhcnMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBwb2ludHMsIG91dGVyIHJhZGl1cywgb3B0aW9uYWwgaW5uZXIgcmFkaXVzLCBhbmQgcm90YXRpb24uXG4gICAqIFRoZSBzdGFyIGlzIGRyYXduIGFzIGEgY2xvc2VkIHBvbHlnb24gd2l0aCBhbHRlcm5hdGluZyBvdXRlciBhbmQgaW5uZXIgdmVydGljZXMgdG8gY3JlYXRlIHRoZSBzdGFyJ3MgcG9pbnRzLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCB0byBzY2FsZSwgcm90YXRlLCBvciB0cmFuc2xhdGUgdGhlIHN0YXIgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIgKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogQHBhcmFtIGlubmVyUmFkaXVzIC0gT3B0aW9uYWwuIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXJcbiAgICogKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaW5uZXIgcG9pbnRzIGJldHdlZW4gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gaGFsZiBvZiB0aGUgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIE9wdGlvbmFsLiBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyBhbGlnbmVkIHdpdGggdGhlIHktYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gMCwgbWVhbmluZyBvbmUgcG9pbnQgaXMgZGlyZWN0bHkgdXB3YXJkLlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHN0YXIuXG4gICAqIFRoaXMgY2FuIGluY2x1ZGUgcm90YXRpb25zLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBzdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24sIHRyYW5zZm9ybSkge1xuICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgcmFkaXVzIC8gMjtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gLTEgKiBNYXRoLlBJIC8gMiArIHJvdGF0aW9uO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cyAqIDI7XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLlBJICogMiAvIGxlbjtcbiAgICBjb25zdCBwb2x5Z29uID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgciA9IGkgJSAyID8gaW5uZXJSYWRpdXMgOiByYWRpdXM7XG4gICAgICBjb25zdCBhbmdsZSA9IGkgKiBkZWx0YSArIHN0YXJ0QW5nbGU7XG4gICAgICBwb2x5Z29uLnB1c2goXG4gICAgICAgIHggKyByICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5ICsgciAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wb2x5KHBvbHlnb24sIHRydWUsIHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGBHcmFwaGljc1BhdGhgIGluc3RhbmNlLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBib3RoIHNoYWxsb3cgYW5kIGRlZXAgY2xvbmluZy5cbiAgICogQSBzaGFsbG93IGNsb25lIGNvcGllcyB0aGUgcmVmZXJlbmNlIG9mIHRoZSBpbnN0cnVjdGlvbnMgYXJyYXksIHdoaWxlIGEgZGVlcCBjbG9uZSBjcmVhdGVzIGEgbmV3IGFycmF5IGFuZFxuICAgKiBjb3BpZXMgZWFjaCBpbnN0cnVjdGlvbiBpbmRpdmlkdWFsbHksIGVuc3VyaW5nIHRoYXQgbW9kaWZpY2F0aW9ucyB0byB0aGUgaW5zdHJ1Y3Rpb25zIG9mIHRoZSBjbG9uZWQgYEdyYXBoaWNzUGF0aGBcbiAgICogZG8gbm90IGFmZmVjdCB0aGUgb3JpZ2luYWwgYEdyYXBoaWNzUGF0aGAgYW5kIHZpY2UgdmVyc2EuXG4gICAqIEBwYXJhbSBkZWVwIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbG9uZSBzaG91bGQgYmUgZGVlcC5cbiAgICogQHJldHVybnMgQSBuZXcgYEdyYXBoaWNzUGF0aGAgaW5zdGFuY2UgdGhhdCBpcyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgKi9cbiAgY2xvbmUoZGVlcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbmV3R3JhcGhpY3NQYXRoMkQgPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgaWYgKCFkZWVwKSB7XG4gICAgICBuZXdHcmFwaGljc1BhdGgyRC5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIG5ld0dyYXBoaWNzUGF0aDJELmluc3RydWN0aW9ucy5wdXNoKHsgYWN0aW9uOiBpbnN0cnVjdGlvbi5hY3Rpb24sIGRhdGE6IGluc3RydWN0aW9uLmRhdGEuc2xpY2UoKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0dyYXBoaWNzUGF0aDJEO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucyB3aXRoaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBlbmFibGVzIHRoZSBtb2RpZmljYXRpb24gb2YgdGhlIHBhdGgncyBnZW9tZXRyeSBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAqIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgd2hpY2ggY2FuIGluY2x1ZGUgdHJhbnNsYXRpb25zLCByb3RhdGlvbnMsIHNjYWxpbmcsIGFuZCBza2V3aW5nLlxuICAgKlxuICAgKiBFYWNoIGRyYXdpbmcgaW5zdHJ1Y3Rpb24gaW4gdGhlIHBhdGggaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSB0cmFuc2Zvcm1hdGlvbixcbiAgICogZW5zdXJpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGF0aCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGFwcGxpZWQgbWF0cml4LlxuICAgKlxuICAgKiBOb3RlOiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgY29vcmRpbmF0ZXMgYW5kIGNvbnRyb2wgcG9pbnRzIG9mIHRoZSBkcmF3aW5nIGluc3RydWN0aW9ucyxcbiAgICogbm90IHRvIHRoZSBwYXRoIGFzIGEgd2hvbGUuIFRoaXMgbWVhbnMgdGhlIHRyYW5zZm9ybWF0aW9uJ3MgZWZmZWN0cyBhcmUgYmFrZWQgaW50byB0aGUgaW5kaXZpZHVhbCBpbnN0cnVjdGlvbnMsXG4gICAqIGFsbG93aW5nIGZvciBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBwYXRoJ3MgYXBwZWFyYW5jZS5cbiAgICogQHBhcmFtIG1hdHJpeCAtIEEgYE1hdHJpeGAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nIGZ1cnRoZXIgb3BlcmF0aW9ucy5cbiAgICovXG4gIHRyYW5zZm9ybShtYXRyaXgpIHtcbiAgICBpZiAobWF0cml4LmlzSWRlbnRpdHkoKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGEgPSBtYXRyaXguYTtcbiAgICBjb25zdCBiID0gbWF0cml4LmI7XG4gICAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICAgIGNvbnN0IGQgPSBtYXRyaXguZDtcbiAgICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjcHgxID0gMDtcbiAgICBsZXQgY3B5MSA9IDA7XG4gICAgbGV0IGNweDIgPSAwO1xuICAgIGxldCBjcHkyID0gMDtcbiAgICBsZXQgcnggPSAwO1xuICAgIGxldCByeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgc3dpdGNoIChpbnN0cnVjdGlvbi5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgICBjYXNlIFwibGluZVRvXCI6XG4gICAgICAgICAgeCA9IGRhdGFbMF07XG4gICAgICAgICAgeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmV6aWVyQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIGNweDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGNweTIgPSBkYXRhWzNdO1xuICAgICAgICAgIHggPSBkYXRhWzRdO1xuICAgICAgICAgIHkgPSBkYXRhWzVdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIGNweDIgKyBjICogY3B5MiArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogY3B4MiArIGQgKiBjcHkyICsgdHk7XG4gICAgICAgICAgZGF0YVs0XSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgICAgICBkYXRhWzVdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicXVhZHJhdGljQ3VydmVUb1wiOlxuICAgICAgICAgIGNweDEgPSBkYXRhWzBdO1xuICAgICAgICAgIGNweTEgPSBkYXRhWzFdO1xuICAgICAgICAgIHggPSBkYXRhWzJdO1xuICAgICAgICAgIHkgPSBkYXRhWzNdO1xuICAgICAgICAgIGRhdGFbMF0gPSBhICogY3B4MSArIGMgKiBjcHkxICsgdHg7XG4gICAgICAgICAgZGF0YVsxXSA9IGIgKiBjcHgxICsgZCAqIGNweTEgKyB0eTtcbiAgICAgICAgICBkYXRhWzJdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgICAgICAgIGRhdGFbM10gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcmNUb1N2Z1wiOlxuICAgICAgICAgIHggPSBkYXRhWzVdO1xuICAgICAgICAgIHkgPSBkYXRhWzZdO1xuICAgICAgICAgIHJ4ID0gZGF0YVswXTtcbiAgICAgICAgICByeSA9IGRhdGFbMV07XG4gICAgICAgICAgZGF0YVswXSA9IGEgKiByeCArIGMgKiByeTtcbiAgICAgICAgICBkYXRhWzFdID0gYiAqIHJ4ICsgZCAqIHJ5O1xuICAgICAgICAgIGRhdGFbNV0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICAgICAgZGF0YVs2XSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgIGRhdGFbNF0gPSBhZGp1c3RUcmFuc2Zvcm0oZGF0YVszXSwgbWF0cml4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgICBkYXRhWzRdID0gYWRqdXN0VHJhbnNmb3JtKGRhdGFbNF0sIG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgZGF0YVs4XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzhdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm91bmRSZWN0XCI6XG4gICAgICAgICAgZGF0YVs1XSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzVdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICAgIGRhdGFbMF0udHJhbnNmb3JtKG1hdHJpeCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb2x5XCI6XG4gICAgICAgICAgZGF0YVsyXSA9IGFkanVzdFRyYW5zZm9ybShkYXRhWzJdLCBtYXRyaXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdhcm4oXCJ1bmtub3duIHRyYW5zZm9ybSBhY3Rpb25cIiwgaW5zdHJ1Y3Rpb24uYWN0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhcGVQYXRoLmJvdW5kcztcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBpbnN0cnVjdGlvbnMgaW4gdGhlIGBHcmFwaGljc1BhdGhgLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIG9wZXJhdGlvbnMgdGhhdCBkZXBlbmQgb24gdGhlIHBhdGgncyBjdXJyZW50IGVuZHBvaW50LFxuICAgKiBzdWNoIGFzIGNvbm5lY3Rpbmcgc3Vic2VxdWVudCBzaGFwZXMgb3IgcGF0aHMuIEl0IHN1cHBvcnRzIHZhcmlvdXMgZHJhd2luZyBpbnN0cnVjdGlvbnMsXG4gICAqIGVuc3VyaW5nIHRoZSBsYXN0IHBvaW50J3MgcG9zaXRpb24gaXMgYWNjdXJhdGVseSBkZXRlcm1pbmVkIHJlZ2FyZGxlc3Mgb2YgdGhlIHBhdGgncyBjb21wbGV4aXR5LlxuICAgKlxuICAgKiBJZiB0aGUgbGFzdCBpbnN0cnVjdGlvbiBpcyBhIGBjbG9zZVBhdGhgLCB0aGUgbWV0aG9kIGl0ZXJhdGVzIGJhY2t3YXJkIHRocm91Z2ggdGhlIGluc3RydWN0aW9uc1xuICAgKiAgdW50aWwgaXQgZmluZHMgYW4gYWN0aW9uYWJsZSBpbnN0cnVjdGlvbiB0aGF0IGRlZmluZXMgYSBwb2ludCAoZS5nLiwgYG1vdmVUb2AsIGBsaW5lVG9gLFxuICAgKiBgcXVhZHJhdGljQ3VydmVUb2AsIGV0Yy4pLiBGb3IgY29tcG91bmQgcGF0aHMgYWRkZWQgdmlhIGBhZGRQYXRoYCwgaXQgcmVjdXJzaXZlbHkgcmV0cmlldmVzXG4gICAqIHRoZSBsYXN0IHBvaW50IGZyb20gdGhlIG5lc3RlZCBwYXRoLlxuICAgKiBAcGFyYW0gb3V0IC0gQSBgUG9pbnRgIG9iamVjdCB3aGVyZSB0aGUgbGFzdCBwb2ludCdzIGNvb3JkaW5hdGVzIHdpbGwgYmUgc3RvcmVkLlxuICAgKiBUaGlzIG9iamVjdCBpcyBtb2RpZmllZCBkaXJlY3RseSB0byBjb250YWluIHRoZSByZXN1bHQuXG4gICAqIEByZXR1cm5zIFRoZSBgUG9pbnRgIG9iamVjdCBjb250YWluaW5nIHRoZSBsYXN0IHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRMYXN0UG9pbnQob3V0KSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbaW5kZXhdO1xuICAgIGlmICghbGFzdEluc3RydWN0aW9uKSB7XG4gICAgICBvdXQueCA9IDA7XG4gICAgICBvdXQueSA9IDA7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB3aGlsZSAobGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJjbG9zZVBhdGhcIikge1xuICAgICAgaW5kZXgtLTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgb3V0LnggPSAwO1xuICAgICAgICBvdXQueSA9IDA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICBsYXN0SW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpbmRleF07XG4gICAgfVxuICAgIHN3aXRjaCAobGFzdEluc3RydWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBcIm1vdmVUb1wiOlxuICAgICAgY2FzZSBcImxpbmVUb1wiOlxuICAgICAgICBvdXQueCA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzBdO1xuICAgICAgICBvdXQueSA9IGxhc3RJbnN0cnVjdGlvbi5kYXRhWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJxdWFkcmF0aWNDdXJ2ZVRvXCI6XG4gICAgICAgIG91dC54ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbMl07XG4gICAgICAgIG91dC55ID0gbGFzdEluc3RydWN0aW9uLmRhdGFbM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJlemllckN1cnZlVG9cIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs0XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYXJjXCI6XG4gICAgICBjYXNlIFwiYXJjVG9TdmdcIjpcbiAgICAgICAgb3V0LnggPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs1XTtcbiAgICAgICAgb3V0LnkgPSBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVs2XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWRkUGF0aFwiOlxuICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YVswXS5nZXRMYXN0UG9pbnQob3V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFRyYW5zZm9ybShjdXJyZW50TWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKGN1cnJlbnRNYXRyaXgpIHtcbiAgICByZXR1cm4gY3VycmVudE1hdHJpeC5wcmVwZW5kKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybS5jbG9uZSgpO1xufVxuXG5leHBvcnQgeyBHcmFwaGljc1BhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzUGF0aC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuLi9wYXRoL0dyYXBoaWNzUGF0aC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIFNWR1BhcnNlcihzdmcsIGdyYXBoaWNzQ29udGV4dCkge1xuICBpZiAodHlwZW9mIHN2ZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IHN2Zy50cmltKCk7XG4gICAgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICBjb250ZXh0OiBncmFwaGljc0NvbnRleHQsXG4gICAgcGF0aDogbmV3IEdyYXBoaWNzUGF0aCgpXG4gIH07XG4gIHJlbmRlckNoaWxkcmVuKHN2Zywgc2Vzc2lvbiwgbnVsbCwgbnVsbCk7XG4gIHJldHVybiBncmFwaGljc0NvbnRleHQ7XG59XG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbihzdmcsIHNlc3Npb24sIGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGRyZW47XG4gIGNvbnN0IHsgZmlsbFN0eWxlOiBmMSwgc3Ryb2tlU3R5bGU6IHMxIH0gPSBwYXJzZVN0eWxlKHN2Zyk7XG4gIGlmIChmMSAmJiBmaWxsU3R5bGUpIHtcbiAgICBmaWxsU3R5bGUgPSB7IC4uLmZpbGxTdHlsZSwgLi4uZjEgfTtcbiAgfSBlbHNlIGlmIChmMSkge1xuICAgIGZpbGxTdHlsZSA9IGYxO1xuICB9XG4gIGlmIChzMSAmJiBzdHJva2VTdHlsZSkge1xuICAgIHN0cm9rZVN0eWxlID0geyAuLi5zdHJva2VTdHlsZSwgLi4uczEgfTtcbiAgfSBlbHNlIGlmIChzMSkge1xuICAgIHN0cm9rZVN0eWxlID0gczE7XG4gIH1cbiAgc2Vzc2lvbi5jb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIGxldCB4O1xuICBsZXQgeTtcbiAgbGV0IHgxO1xuICBsZXQgeTE7XG4gIGxldCB4MjtcbiAgbGV0IHkyO1xuICBsZXQgY3g7XG4gIGxldCBjeTtcbiAgbGV0IHI7XG4gIGxldCByeDtcbiAgbGV0IHJ5O1xuICBsZXQgcG9pbnRzO1xuICBsZXQgcG9pbnRzU3RyaW5nO1xuICBsZXQgZDtcbiAgbGV0IGdyYXBoaWNzUGF0aDtcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBzd2l0Y2ggKHN2Zy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICAgIGQgPSBzdmcuZ2V0QXR0cmlidXRlKFwiZFwiKTtcbiAgICAgIGdyYXBoaWNzUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoZCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucGF0aChncmFwaGljc1BhdGgpO1xuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgY3ggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJjeFwiLCAwKTtcbiAgICAgIGN5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3lcIiwgMCk7XG4gICAgICByID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiclwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5lbGxpcHNlKGN4LCBjeSwgciwgcik7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInhcIiwgMCk7XG4gICAgICB5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieVwiLCAwKTtcbiAgICAgIHdpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwid2lkdGhcIiwgMCk7XG4gICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJoZWlnaHRcIiwgMCk7XG4gICAgICByeCA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcInJ4XCIsIDApO1xuICAgICAgcnkgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeVwiLCAwKTtcbiAgICAgIGlmIChyeCB8fCByeSkge1xuICAgICAgICBzZXNzaW9uLmNvbnRleHQucm91bmRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJ4IHx8IHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlc3Npb24uY29udGV4dC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LmZpbGwoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVsbGlwc2VcIjpcbiAgICAgIGN4ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwiY3hcIiwgMCk7XG4gICAgICBjeSA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcImN5XCIsIDApO1xuICAgICAgcnggPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJyeFwiLCAwKTtcbiAgICAgIHJ5ID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwicnlcIiwgMCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQuZWxsaXBzZShjeCwgY3ksIHJ4LCByeSk7XG4gICAgICBpZiAoZmlsbFN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlKVxuICAgICAgICBzZXNzaW9uLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGluZVwiOlxuICAgICAgeDEgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ4MVwiLCAwKTtcbiAgICAgIHkxID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwieTFcIiwgMCk7XG4gICAgICB4MiA9IHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBcIngyXCIsIDApO1xuICAgICAgeTIgPSBwYXJzZUZsb2F0QXR0cmlidXRlKHN2ZywgXCJ5MlwiLCAwKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHNlc3Npb24uY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICAgIHBvaW50c1N0cmluZyA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIik7XG4gICAgICBwb2ludHMgPSBwb2ludHNTdHJpbmcubWF0Y2goL1xcZCsvZykubWFwKChuKSA9PiBwYXJzZUludChuLCAxMCkpO1xuICAgICAgc2Vzc2lvbi5jb250ZXh0LnBvbHkocG9pbnRzLCB0cnVlKTtcbiAgICAgIGlmIChmaWxsU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUpXG4gICAgICAgIHNlc3Npb24uY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb2x5bGluZVwiOlxuICAgICAgcG9pbnRzU3RyaW5nID0gc3ZnLmdldEF0dHJpYnV0ZShcInBvaW50c1wiKTtcbiAgICAgIHBvaW50cyA9IHBvaW50c1N0cmluZy5tYXRjaCgvXFxkKy9nKS5tYXAoKG4pID0+IHBhcnNlSW50KG4sIDEwKSk7XG4gICAgICBzZXNzaW9uLmNvbnRleHQucG9seShwb2ludHMsIGZhbHNlKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSlcbiAgICAgICAgc2Vzc2lvbi5jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zb2xlLmluZm8oYFtTVkcgcGFyc2VyXSA8JHtzdmcubm9kZU5hbWV9PiBlbGVtZW50cyB1bnN1cHBvcnRlZGApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICByZW5kZXJDaGlsZHJlbihjaGlsZHJlbltpXSwgc2Vzc2lvbiwgZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRBdHRyaWJ1dGUoc3ZnLCBpZCwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IHZhbHVlID0gc3ZnLmdldEF0dHJpYnV0ZShpZCk7XG4gIHJldHVybiB2YWx1ZSA/IE51bWJlcih2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN2Zykge1xuICBjb25zdCBzdHlsZSA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgY29uc3Qgc3Ryb2tlU3R5bGUgPSB7fTtcbiAgY29uc3QgZmlsbFN0eWxlID0ge307XG4gIGxldCB1c2VGaWxsID0gZmFsc2U7XG4gIGxldCB1c2VTdHJva2UgPSBmYWxzZTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgY29uc3Qgc3R5bGVQYXJ0cyA9IHN0eWxlLnNwbGl0KFwiO1wiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0eWxlUGFydCA9IHN0eWxlUGFydHNbaV07XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBzdHlsZVBhcnQuc3BsaXQoXCI6XCIpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcInN0cm9rZVwiOlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHZhbHVlKS50b051bWJlcigpO1xuICAgICAgICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJva2Utd2lkdGhcIjpcbiAgICAgICAgICBzdHJva2VTdHlsZS53aWR0aCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdXNlRmlsbCA9IHRydWU7XG4gICAgICAgICAgICBmaWxsU3R5bGUuY29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmlsbC1vcGFjaXR5XCI6XG4gICAgICAgICAgZmlsbFN0eWxlLmFscGhhID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cm9rZS1vcGFjaXR5XCI6XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib3BhY2l0eVwiOlxuICAgICAgICAgIGZpbGxTdHlsZS5hbHBoYSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUuYWxwaGEgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJva2UgPSBzdmcuZ2V0QXR0cmlidXRlKFwic3Ryb2tlXCIpO1xuICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgdXNlU3Ryb2tlID0gdHJ1ZTtcbiAgICAgIHN0cm9rZVN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZSkudG9OdW1iZXIoKTtcbiAgICAgIHN0cm9rZVN0eWxlLndpZHRoID0gcGFyc2VGbG9hdEF0dHJpYnV0ZShzdmcsIFwic3Ryb2tlLXdpZHRoXCIsIDEpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsID0gc3ZnLmdldEF0dHJpYnV0ZShcImZpbGxcIik7XG4gICAgaWYgKGZpbGwgJiYgZmlsbCAhPT0gXCJub25lXCIpIHtcbiAgICAgIHVzZUZpbGwgPSB0cnVlO1xuICAgICAgZmlsbFN0eWxlLmNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGZpbGwpLnRvTnVtYmVyKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3Ryb2tlU3R5bGU6IHVzZVN0cm9rZSA/IHN0cm9rZVN0eWxlIDogbnVsbCxcbiAgICBmaWxsU3R5bGU6IHVzZUZpbGwgPyBmaWxsU3R5bGUgOiBudWxsXG4gIH07XG59XG5cbmV4cG9ydCB7IFNWR1BhcnNlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHUGFyc2VyLm1qcy5tYXBcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL2NvbG9yL0NvbG9yLm1qcyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi8uLi8uLi9tYXRocy9tYXRyaXgvTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL3BvaW50L1BvaW50Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4uLy4uL2NvbnRhaW5lci9ib3VuZHMvQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BhdGggfSBmcm9tICcuL3BhdGgvR3JhcGhpY3NQYXRoLm1qcyc7XG5pbXBvcnQgeyBTVkdQYXJzZXIgfSBmcm9tICcuL3N2Zy9TVkdQYXJzZXIubWpzJztcbmltcG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9IGZyb20gJy4vdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdG1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5jb25zdCBfR3JhcGhpY3NDb250ZXh0ID0gY2xhc3MgX0dyYXBoaWNzQ29udGV4dCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy51aWQgPSB1aWQoXCJncmFwaGljc0NvbnRleHRcIik7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5iYXRjaE1vZGUgPSBcImF1dG9cIjtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBuZXcgR3JhcGhpY3NQYXRoKCk7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IHsgLi4uX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlIH07XG4gICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSB7IC4uLl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlIH07XG4gICAgdGhpcy5fc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgICB0aGlzLl9ib3VuZHNEaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NDb250ZXh0IG9iamVjdCB0aGF0IGlzIGEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZSwgY29weWluZyBhbGwgcHJvcGVydGllcyxcbiAgICogaW5jbHVkaW5nIHRoZSBjdXJyZW50IGRyYXdpbmcgc3RhdGUsIHRyYW5zZm9ybWF0aW9ucywgc3R5bGVzLCBhbmQgaW5zdHJ1Y3Rpb25zLlxuICAgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljc0NvbnRleHQgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFuZCBzdGF0ZSBhcyB0aGlzIG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IF9HcmFwaGljc0NvbnRleHQoKTtcbiAgICBjbG9uZS5iYXRjaE1vZGUgPSB0aGlzLmJhdGNoTW9kZTtcbiAgICBjbG9uZS5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5zbGljZSgpO1xuICAgIGNsb25lLl9hY3RpdmVQYXRoID0gdGhpcy5fYWN0aXZlUGF0aC5jbG9uZSgpO1xuICAgIGNsb25lLl90cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKTtcbiAgICBjbG9uZS5fZmlsbFN0eWxlID0geyAuLi50aGlzLl9maWxsU3R5bGUgfTtcbiAgICBjbG9uZS5fc3Ryb2tlU3R5bGUgPSB7IC4uLnRoaXMuX3N0cm9rZVN0eWxlIH07XG4gICAgY2xvbmUuX3N0YXRlU3RhY2sgPSB0aGlzLl9zdGF0ZVN0YWNrLnNsaWNlKCk7XG4gICAgY2xvbmUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcy5jbG9uZSgpO1xuICAgIGNsb25lLl9ib3VuZHNEaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGlzIGNhbiBiZSBhIGNvbG9yLCBncmFkaWVudCwgcGF0dGVybiwgb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgZGVmaW5lZCBieSBhIEZpbGxTdHlsZSBvYmplY3QuXG4gICAqL1xuICBnZXQgZmlsbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsU3R5bGU7XG4gIH1cbiAgc2V0IGZpbGxTdHlsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSh2YWx1ZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3Ryb2tlIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBTaW1pbGFyIHRvIGZpbGwgc3R5bGVzLCBzdHJva2Ugc3R5bGVzIGNhbiBlbmNvbXBhc3MgY29sb3JzLCBncmFkaWVudHMsIHBhdHRlcm5zLCBvciBtb3JlIGRldGFpbGVkIGNvbmZpZ3VyYXRpb25zIHZpYSBhIFN0cm9rZVN0eWxlIG9iamVjdC5cbiAgICovXG4gIGdldCBzdHJva2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlU3R5bGU7XG4gIH1cbiAgc2V0IHN0cm9rZVN0eWxlKHZhbHVlKSB7XG4gICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBmaWxsIHN0eWxlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGUgZmlsbCBzdHlsZSBjYW4gYmUgYSBjb2xvciwgZ3JhZGllbnQsXG4gICAqIHBhdHRlcm4sIG9yIGEgbW9yZSBjb21wbGV4IHN0eWxlIGRlZmluZWQgYnkgYSBGaWxsU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgZmlsbCBzdHlsZSB0byBhcHBseS4gVGhpcyBjYW4gYmUgYSBzaW1wbGUgY29sb3IsIGEgZ3JhZGllbnQgb3IgcGF0dGVybiBvYmplY3QsXG4gICAqICAgICAgICAgICAgICAgIG9yIGEgRmlsbFN0eWxlIG9yIENvbnZlcnRlZEZpbGxTdHlsZSBvYmplY3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIHNldEZpbGxTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShzdHlsZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUgb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuIFNpbWlsYXIgdG8gZmlsbCBzdHlsZXMsIHN0cm9rZSBzdHlsZXMgY2FuXG4gICAqIGVuY29tcGFzcyBjb2xvcnMsIGdyYWRpZW50cywgcGF0dGVybnMsIG9yIG1vcmUgZGV0YWlsZWQgY29uZmlndXJhdGlvbnMgdmlhIGEgU3Ryb2tlU3R5bGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3Ryb2tlIHN0eWxlIHRvIGFwcGx5LiBDYW4gYmUgZGVmaW5lZCBhcyBhIGNvbG9yLCBhIGdyYWRpZW50IG9yIHBhdHRlcm4sXG4gICAqICAgICAgICAgICAgICAgIG9yIGEgU3Ryb2tlU3R5bGUgb3IgQ29udmVydGVkU3Ryb2tlU3R5bGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzZXRTdHJva2VTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuX3N0cm9rZVN0eWxlID0gY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlKHN0eWxlLCBfR3JhcGhpY3NDb250ZXh0LmRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGV4dHVyZSh0ZXh0dXJlLCB0aW50LCBkeCwgZHksIGR3LCBkaCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcInRleHR1cmVcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaW1hZ2U6IHRleHR1cmUsXG4gICAgICAgIGR4OiBkeCB8fCAwLFxuICAgICAgICBkeTogZHkgfHwgMCxcbiAgICAgICAgZHc6IGR3IHx8IHRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAgIGRoOiBkaCB8fCB0ZXh0dXJlLmZyYW1lLmhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSxcbiAgICAgICAgYWxwaGE6IHRoaXMuX2ZpbGxTdHlsZS5hbHBoYSxcbiAgICAgICAgc3R5bGU6IHRpbnQgPyBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGludCkudG9OdW1iZXIoKSA6IDE2Nzc3MjE1XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgcGF0aC4gQW55IHByZXZpb3VzIHBhdGggYW5kIGl0cyBjb21tYW5kcyBhcmUgZGlzY2FyZGVkIGFuZCBhIG5ldyBwYXRoIGlzXG4gICAqIHN0YXJ0ZWQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBiZWZvcmUgYmVnaW5uaW5nIGEgbmV3IHNoYXBlIG9yIHNlcmllcyBvZiBkcmF3aW5nIGNvbW1hbmRzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBiZWdpblBhdGgoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaWxsKHN0eWxlLCBhbHBoYSkge1xuICAgIGxldCBwYXRoO1xuICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0aGlzLl90aWNrID09PSAwICYmIGxhc3RJbnN0cnVjdGlvbiAmJiBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAoYWxwaGEgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc3R5bGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkdyYXBoaWNzQ29udGV4dC5maWxsKGNvbG9yLCBhbHBoYSkgaXMgZGVwcmVjYXRlZCwgdXNlIEdyYXBoaWNzQ29udGV4dC5maWxsKHsgY29sb3IsIGFscGhhIH0pIGluc3RlYWRcIik7XG4gICAgICAgIHN0eWxlID0geyBjb2xvcjogc3R5bGUsIGFscGhhIH07XG4gICAgICB9XG4gICAgICB0aGlzLl9maWxsU3R5bGUgPSBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUoc3R5bGUsIF9HcmFwaGljc0NvbnRleHQuZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgYWN0aW9uOiBcImZpbGxcIixcbiAgICAgIC8vIFRPRE8gY29weSBmaWxsIHN0eWxlIVxuICAgICAgZGF0YTogeyBzdHlsZTogdGhpcy5maWxsU3R5bGUsIHBhdGggfVxuICAgIH0pO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICB0aGlzLl9pbml0TmV4dFBhdGhMb2NhdGlvbigpO1xuICAgIHRoaXMuX3RpY2sgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0TmV4dFBhdGhMb2NhdGlvbigpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX2FjdGl2ZVBhdGguZ2V0TGFzdFBvaW50KFBvaW50LnNoYXJlZCk7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5jbGVhcigpO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgubW92ZVRvKHgsIHkpO1xuICB9XG4gIC8qKlxuICAgKiBTdHJva2VzIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuIFRoaXMgbWV0aG9kIGNhbiB0YWtlIGFuIG9wdGlvbmFsXG4gICAqIEZpbGxTdHlsZUlucHV0cyBwYXJhbWV0ZXIgdG8gZGVmaW5lIHRoZSBzdHJva2UncyBhcHBlYXJhbmNlLCBpbmNsdWRpbmcgaXRzIGNvbG9yLCB3aWR0aCwgYW5kIG90aGVyIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBzdHlsZSAtIChPcHRpb25hbCkgVGhlIHN0cm9rZSBzdHlsZSB0byBhcHBseS4gQ2FuIGJlIGRlZmluZWQgYXMgYSBzaW1wbGUgY29sb3Igb3IgYSBtb3JlIGNvbXBsZXggc3R5bGUgb2JqZWN0LiBJZiBvbWl0dGVkLCB1c2VzIHRoZSBjdXJyZW50IHN0cm9rZSBzdHlsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IEdyYXBoaWNzQ29udGV4dCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgc3Ryb2tlKHN0eWxlKSB7XG4gICAgbGV0IHBhdGg7XG4gICAgY29uc3QgbGFzdEluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvbnNbdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMuX3RpY2sgPT09IDAgJiYgbGFzdEluc3RydWN0aW9uICYmIGxhc3RJbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICBwYXRoID0gbGFzdEluc3RydWN0aW9uLmRhdGEucGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMuX2FjdGl2ZVBhdGguY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB0aGlzLl9zdHJva2VTdHlsZSA9IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZShzdHlsZSwgX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgIGFjdGlvbjogXCJzdHJva2VcIixcbiAgICAgIC8vIFRPRE8gY29weSBmaWxsIHN0eWxlIVxuICAgICAgZGF0YTogeyBzdHlsZTogdGhpcy5zdHJva2VTdHlsZSwgcGF0aCB9XG4gICAgfSk7XG4gICAgdGhpcy5vblVwZGF0ZSgpO1xuICAgIHRoaXMuX2luaXROZXh0UGF0aExvY2F0aW9uKCk7XG4gICAgdGhpcy5fdGljayA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjdXRvdXQgdG8gdGhlIGxhc3QgZHJhd24gc2hhcGUuIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgaG9sZXMgb3IgY29tcGxleCBzaGFwZXMgYnlcbiAgICogc3VidHJhY3RpbmcgYSBwYXRoIGZyb20gdGhlIHByZXZpb3VzbHkgZHJhd24gcGF0aC4gSWYgYSBob2xlIGlzIG5vdCBjb21wbGV0ZWx5IGluIGEgc2hhcGUsIGl0IHdpbGxcbiAgICogZmFpbCB0byBjdXQgY29ycmVjdGx5IVxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBjdXQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGNvbnN0IGxhc3RJbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25zW3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgIGNvbnN0IGhvbGVQYXRoID0gdGhpcy5fYWN0aXZlUGF0aC5jbG9uZSgpO1xuICAgICAgaWYgKGxhc3RJbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAobGFzdEluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIiB8fCBsYXN0SW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcImZpbGxcIikge1xuICAgICAgICAgIGlmIChsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlKSB7XG4gICAgICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlLmFkZFBhdGgoaG9sZVBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0SW5zdHJ1Y3Rpb24uZGF0YS5ob2xlID0gaG9sZVBhdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5pdE5leHRQYXRoTG9jYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aCwgd2hpY2ggaXMgY2VudGVyZWQgYXQgKHgsIHkpIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMsXG4gICAqIHN0YXJ0aW5nIGFuZCBlbmRpbmcgYW5nbGVzLCBhbmQgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGFyYydzIGNlbnRlci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBjZW50ZXIuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgYXJjJ3MgcmFkaXVzLlxuICAgKiBAcGFyYW0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIGNvdW50ZXJjbG9ja3dpc2UgLSAoT3B0aW9uYWwpIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBhcmMgaXMgZHJhd24gY291bnRlcmNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlcmNsb2Nrd2lzZSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguYXJjKFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5LFxuICAgICAgcmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgY291bnRlcmNsb2Nrd2lzZVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBjdXJyZW50IHBhdGggd2l0aCB0aGUgZ2l2ZW4gY29udHJvbCBwb2ludHMgYW5kIHJhZGl1cywgY29ubmVjdGVkIHRvIHRoZSBwcmV2aW91cyBwb2ludFxuICAgKiBieSBhIHN0cmFpZ2h0IGxpbmUgaWYgbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0geDEgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHkyIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgYXJjJ3MgcmFkaXVzLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2Zvcm07XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hcmNUbyhcbiAgICAgIHQuYSAqIHgxICsgdC5jICogeTEgKyB0LnR4LFxuICAgICAgdC5iICogeDEgKyB0LmQgKiB5MSArIHQudHksXG4gICAgICB0LmEgKiB4MiArIHQuYyAqIHkyICsgdC50eCxcbiAgICAgIHQuYiAqIHgyICsgdC5kICogeTIgKyB0LnR5LFxuICAgICAgcmFkaXVzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBTVkctc3R5bGUgYXJjIHRvIHRoZSBwYXRoLCBhbGxvd2luZyBmb3IgZWxsaXB0aWNhbCBhcmNzIGJhc2VkIG9uIHRoZSBTVkcgc3BlYy5cbiAgICogQHBhcmFtIHJ4IC0gVGhlIHgtcmFkaXVzIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0gcnkgLSBUaGUgeS1yYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB4QXhpc1JvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBlbGxpcHNlJ3MgeC1heGlzIHJlbGF0aXZlXG4gICAqIHRvIHRoZSB4LWF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtLCBpbiBkZWdyZWVzLlxuICAgKiBAcGFyYW0gbGFyZ2VBcmNGbGFnIC0gRGV0ZXJtaW5lcyBpZiB0aGUgYXJjIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgbGVzcyB0aGFuIDE4MCBkZWdyZWVzLlxuICAgKiBAcGFyYW0gc3dlZXBGbGFnIC0gRGV0ZXJtaW5lcyBpZiB0aGUgYXJjIHNob3VsZCBiZSBzd2VwdCBpbiBhIHBvc2l0aXZlIGFuZ2xlIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBhcmMncyBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYXJjJ3MgZW5kIHBvaW50LlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIGFyY1RvU3ZnKHJ4LCByeSwgeEF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmFyY1RvU3ZnKFxuICAgICAgcngsXG4gICAgICByeSxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICAvLyBzaG91bGQgd2Ugcm90YXRlIHRoaXMgd2l0aCB0cmFuc2Zvcm0/P1xuICAgICAgbGFyZ2VBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGN1YmljIEJlemllciBjdXJ2ZSB0byB0aGUgcGF0aC5cbiAgICogSXQgcmVxdWlyZXMgdGhyZWUgcG9pbnRzOiB0aGUgZmlyc3QgdHdvIGFyZSBjb250cm9sIHBvaW50cyBhbmQgdGhlIHRoaXJkIG9uZSBpcyB0aGUgZW5kIHBvaW50LlxuICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIGNwMXggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3AxeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSBjcDJ5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gYWRqdXN0IHRoZSBzbW9vdGhuZXNzIG9mIHRoZSBjdXJ2ZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHksIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLmJlemllckN1cnZlVG8oXG4gICAgICB0LmEgKiBjcDF4ICsgdC5jICogY3AxeSArIHQudHgsXG4gICAgICB0LmIgKiBjcDF4ICsgdC5kICogY3AxeSArIHQudHksXG4gICAgICB0LmEgKiBjcDJ4ICsgdC5jICogY3AyeSArIHQudHgsXG4gICAgICB0LmIgKiBjcDJ4ICsgdC5kICogY3AyeSArIHQudHksXG4gICAgICB0LmEgKiB4ICsgdC5jICogeSArIHQudHgsXG4gICAgICB0LmIgKiB4ICsgdC5kICogeSArIHQudHksXG4gICAgICBzbW9vdGhuZXNzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGggYnkgZHJhd2luZyBhIHN0cmFpZ2h0IGxpbmUgYmFjayB0byB0aGUgc3RhcnQuXG4gICAqIElmIHRoZSBzaGFwZSBpcyBhbHJlYWR5IGNsb3NlZCBvciB0aGVyZSBhcmUgbm8gcG9pbnRzIGluIHRoZSBwYXRoLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoPy5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYW4gZWxsaXBzZSBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIGFuZCB3aXRoIHRoZSBnaXZlbiB4IGFuZCB5IHJhZGlpLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgYWxsb3dpbmcgZm9yIHJvdGF0aW9uLCBzY2FsaW5nLCBhbmQgdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHJhZGl1c1ggLSBUaGUgaG9yaXpvbnRhbCByYWRpdXMgb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSByYWRpdXNZIC0gVGhlIHZlcnRpY2FsIHJhZGl1cyBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBlbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1kpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5lbGxpcHNlKHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBjaXJjbGUgc2hhcGUuIFRoaXMgbWV0aG9kIGFkZHMgYSBuZXcgY2lyY2xlIHBhdGggdG8gdGhlIGN1cnJlbnQgZHJhd2luZy5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBjaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguY2lyY2xlKHgsIHksIHJhZGl1cywgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgYEdyYXBoaWNzUGF0aGAgdG8gdGhpcyBwYXRoLCBvcHRpb25hbGx5IGFwcGx5aW5nIGEgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIGBHcmFwaGljc1BhdGhgIHRvIGFkZC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBwYXRoKHBhdGgpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5hZGRQYXRoKHBhdGgsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIGN1cnJlbnQgcG9pbnQgdG8gYSBuZXcgcG9pbnQgd2l0aCBhIHN0cmFpZ2h0IGxpbmUuIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQgdG8gY29ubmVjdCB0by5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBjb25zdCB0ID0gdGhpcy5fdHJhbnNmb3JtO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgubGluZVRvKFxuICAgICAgdC5hICogeCArIHQuYyAqIHkgKyB0LnR4LFxuICAgICAgdC5iICogeCArIHQuZCAqIHkgKyB0LnR5XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIGEgbmV3IHN1Yi1wYXRoLiBBbnkgc3Vic2VxdWVudCBkcmF3aW5nIGNvbW1hbmRzIGFyZSBjb25zaWRlcmVkIHBhcnQgb2YgdGhpcyBwYXRoLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgZm9yIHRoZSBzdGFydGluZyBwb2ludC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIGZvciB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLl9hY3RpdmVQYXRoLmluc3RydWN0aW9ucztcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFggPSB0LmEgKiB4ICsgdC5jICogeSArIHQudHg7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRZID0gdC5iICogeCArIHQuZCAqIHkgKyB0LnR5O1xuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxICYmIGluc3RydWN0aW9uc1swXS5hY3Rpb24gPT09IFwibW92ZVRvXCIpIHtcbiAgICAgIGluc3RydWN0aW9uc1swXS5kYXRhWzBdID0gdHJhbnNmb3JtZWRYO1xuICAgICAgaW5zdHJ1Y3Rpb25zWzBdLmRhdGFbMV0gPSB0cmFuc2Zvcm1lZFk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5tb3ZlVG8oXG4gICAgICB0cmFuc2Zvcm1lZFgsXG4gICAgICB0cmFuc2Zvcm1lZFlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcXVhZHJhdGljIGN1cnZlIHRvIHRoZSBwYXRoLiBJdCByZXF1aXJlcyB0d28gcG9pbnRzOiB0aGUgY29udHJvbCBwb2ludCBhbmQgdGhlIGVuZCBwb2ludC5cbiAgICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IGluIHRoZSBjdXJyZW50IHBhdGguXG4gICAqIEBwYXJhbSBjcHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICAgKiBAcGFyYW0gY3B5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gc21vb3RobmVzcyAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBhZGp1c3QgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHksIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICB0LmEgKiBjcHggKyB0LmMgKiBjcHkgKyB0LnR4LFxuICAgICAgdC5iICogY3B4ICsgdC5kICogY3B5ICsgdC50eSxcbiAgICAgIHQuYSAqIHggKyB0LmMgKiB5ICsgdC50eCxcbiAgICAgIHQuYiAqIHggKyB0LmQgKiB5ICsgdC50eSxcbiAgICAgIHNtb290aG5lc3NcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS4gVGhpcyBtZXRob2QgYWRkcyBhIG5ldyByZWN0YW5nbGUgcGF0aCB0byB0aGUgY3VycmVudCBkcmF3aW5nLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yZWN0KHgsIHksIHcsIGgsIHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuXG4gICAqIFRoZSBjb3JuZXIgcmFkaXVzIGNhbiBiZSBzcGVjaWZpZWQgdG8gZGV0ZXJtaW5lIGhvdyByb3VuZGVkIHRoZSBjb3JuZXJzIHNob3VsZCBiZS5cbiAgICogQW4gb3B0aW9uYWwgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGFwcGxpZWQsIHdoaWNoIGFsbG93cyBmb3Igcm90YXRpb24sIHNjYWxpbmcsIGFuZCB0cmFuc2xhdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gaCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSdzIGNvcm5lcnMuIElmIG5vdCBzcGVjaWZpZWQsIGNvcm5lcnMgd2lsbCBiZSBzaGFycC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaXVzKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGgucm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1cywgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHBvbHlnb24gc2hhcGUgYnkgc3BlY2lmeWluZyBhIHNlcXVlbmNlIG9mIHBvaW50cy4gVGhpcyBtZXRob2QgYWxsb3dzIGZvciB0aGUgY3JlYXRpb24gb2YgY29tcGxleCBwb2x5Z29ucyxcbiAgICogd2hpY2ggY2FuIGJlIGJvdGggb3BlbiBhbmQgY2xvc2VkLiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCwgZW5hYmxpbmcgdGhlIHBvbHlnb24gdG8gYmUgc2NhbGVkLFxuICAgKiByb3RhdGVkLCBvciB0cmFuc2xhdGVkIGFzIG5lZWRlZC5cbiAgICogQHBhcmFtIHBvaW50cyAtIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGFuIGFycmF5IG9mIFBvaW50RGF0YSBvYmplY3RzIGVnIFt7eCx5fSwge3gseX0sIHt4LHl9XVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMsIG9mIHRoZSBwb2x5Z29uJ3MgdmVydGljZXMsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0gY2xvc2UgLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNsb3NlIHRoZSBwb2x5Z29uIHBhdGguIFRydWUgYnkgZGVmYXVsdC5cbiAgICovXG4gIHBvbHkocG9pbnRzLCBjbG9zZSkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnBvbHkocG9pbnRzLCBjbG9zZSwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBhIHJlZ3VsYXIgcG9seWdvbiB3aXRoIGEgc3BlY2lmaWVkIG51bWJlciBvZiBzaWRlcy4gQWxsIHNpZGVzIGFuZCBhbmdsZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjdW1zY3JpYmVkIGNpcmNsZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHNpZGVzIC0gVGhlIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gTXVzdCBiZSAzIG9yIG1vcmUuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIFRoZSByb3RhdGlvbiBhbmdsZSBvZiB0aGUgcG9seWdvbiwgaW4gcmFkaWFucy4gWmVybyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gQW4gb3B0aW9uYWwgYE1hdHJpeGAgb2JqZWN0IHRvIGFwcGx5IGEgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVndWxhclBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgcm90YXRpb24gPSAwLCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yZWd1bGFyUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCByb3RhdGlvbiwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBwb2x5Z29uIHdpdGggcm91bmRlZCBjb3JuZXJzLlxuICAgKiBTaW1pbGFyIHRvIGByZWd1bGFyUG9seWAgYnV0IHdpdGggdGhlIGFiaWxpdHkgdG8gcm91bmQgdGhlIGNvcm5lcnMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmN1bXNjcmliZWQgY2lyY2xlIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0gc2lkZXMgLSBUaGUgbnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBNdXN0IGJlIDMgb3IgbW9yZS5cbiAgICogQHBhcmFtIGNvcm5lciAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kaW5nIG9mIHRoZSBjb3JuZXJzLlxuICAgKiBAcGFyYW0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gYW5nbGUgb2YgdGhlIHBvbHlnb24sIGluIHJhZGlhbnMuIFplcm8gYnkgZGVmYXVsdC5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFBvbHkoeCwgeSwgcmFkaXVzLCBzaWRlcywgY29ybmVyLCByb3RhdGlvbikge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnJvdW5kUG9seSh4LCB5LCByYWRpdXMsIHNpZGVzLCBjb3JuZXIsIHJvdGF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzaGFwZSB3aXRoIHJvdW5kZWQgY29ybmVycy4gVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjdXN0b20gcmFkaXVzIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgc2hhcGUuXG4gICAqIE9wdGlvbmFsbHksIGNvcm5lcnMgY2FuIGJlIHJvdW5kZWQgdXNpbmcgYSBxdWFkcmF0aWMgY3VydmUgaW5zdGVhZCBvZiBhbiBhcmMsIHByb3ZpZGluZyBhIGRpZmZlcmVudCBhZXN0aGV0aWMuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBBbiBhcnJheSBvZiBgUm91bmRlZFBvaW50YCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHNoYXBlIHRvIGRyYXcuXG4gICAqIEEgbWluaW11bSBvZiAzIHBvaW50cyBpcyByZXF1aXJlZC5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBkZWZhdWx0IHJhZGl1cyBmb3IgdGhlIGNvcm5lcnMuXG4gICAqIFRoaXMgcmFkaXVzIGlzIGFwcGxpZWQgdG8gYWxsIGNvcm5lcnMgdW5sZXNzIG92ZXJyaWRkZW4gaW4gYHBvaW50c2AuXG4gICAqIEBwYXJhbSB1c2VRdWFkcmF0aWMgLSBJZiBzZXQgdG8gdHJ1ZSwgcm91bmRlZCBjb3JuZXJzIGFyZSBkcmF3biB1c2luZyBhIHF1YWRyYXRpY0N1cnZlXG4gICAqICBtZXRob2QgaW5zdGVhZCBvZiBhbiBhcmMgbWV0aG9kLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHBhcmFtIHNtb290aG5lc3MgLSBTcGVjaWZpZXMgdGhlIHNtb290aG5lc3Mgb2YgdGhlIGN1cnZlIHdoZW4gYHVzZVF1YWRyYXRpY2AgaXMgdHJ1ZS5cbiAgICogSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBjdXJ2ZSBzbW9vdGhlci5cbiAgICogQHJldHVybnMgVGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICByb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMsIHNtb290aG5lc3MpIHtcbiAgICB0aGlzLl90aWNrKys7XG4gICAgdGhpcy5fYWN0aXZlUGF0aC5yb3VuZFNoYXBlKHBvaW50cywgcmFkaXVzLCB1c2VRdWFkcmF0aWMsIHNtb290aG5lc3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGZpbGxldCBjb3JuZXJzLiBUaGlzIGlzIG11Y2ggbGlrZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgKiBob3dldmVyIGl0IHN1cHBvcnQgbmVnYXRpdmUgbnVtYmVycyBhcyB3ZWxsIGZvciB0aGUgY29ybmVyIHJhZGl1cy5cbiAgICogQHBhcmFtIHggLSBVcHBlciBsZWZ0IGNvcm5lciBvZiByZWN0XG4gICAqIEBwYXJhbSB5IC0gVXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgcmVjdFxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHJlY3RcbiAgICogQHBhcmFtIGZpbGxldCAtIGFjY2VwdCBuZWdhdGl2ZSBvciBwb3NpdGl2ZSB2YWx1ZXNcbiAgICovXG4gIGZpbGxldFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbGV0KSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguZmlsbGV0UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3IFJlY3RhbmdsZSB3aXRoIGNoYW1mZXIgY29ybmVycy4gVGhlc2UgYXJlIGFuZ2xlZCBjb3JuZXJzLlxuICAgKiBAcGFyYW0geCAtIFVwcGVyIGxlZnQgY29ybmVyIG9mIHJlY3RcbiAgICogQHBhcmFtIHkgLSBVcHBlciByaWdodCBjb3JuZXIgb2YgcmVjdFxuICAgKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiByZWN0XG4gICAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgcmVjdFxuICAgKiBAcGFyYW0gY2hhbWZlciAtIG5vbi16ZXJvIHJlYWwgbnVtYmVyLCBzaXplIG9mIGNvcm5lciBjdXRvdXRcbiAgICogQHBhcmFtIHRyYW5zZm9ybVxuICAgKi9cbiAgY2hhbWZlclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbWZlciwgdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fdGljaysrO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGguY2hhbWZlclJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbWZlciwgdHJhbnNmb3JtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRHJhd3MgYSBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IGEgc3BlY2lmaWVkIGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHRoZSBjcmVhdGlvblxuICAgKiAgb2Ygc3RhcnMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBwb2ludHMsIG91dGVyIHJhZGl1cywgb3B0aW9uYWwgaW5uZXIgcmFkaXVzLCBhbmQgcm90YXRpb24uXG4gICAqIFRoZSBzdGFyIGlzIGRyYXduIGFzIGEgY2xvc2VkIHBvbHlnb24gd2l0aCBhbHRlcm5hdGluZyBvdXRlciBhbmQgaW5uZXIgdmVydGljZXMgdG8gY3JlYXRlIHRoZSBzdGFyJ3MgcG9pbnRzLlxuICAgKiBBbiBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBjYW4gYmUgYXBwbGllZCB0byBzY2FsZSwgcm90YXRlLCBvciB0cmFuc2xhdGUgdGhlIHN0YXIgYXMgbmVlZGVkLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgbnVtYmVyIG9mIHBvaW50cyBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIgKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgb3V0ZXIgcG9pbnRzKS5cbiAgICogQHBhcmFtIGlubmVyUmFkaXVzIC0gT3B0aW9uYWwuIFRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXJcbiAgICogKGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaW5uZXIgcG9pbnRzIGJldHdlZW4gdGhlIG91dGVyIHBvaW50cykuXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gaGFsZiBvZiB0aGUgYHJhZGl1c2AuXG4gICAqIEBwYXJhbSByb3RhdGlvbiAtIE9wdGlvbmFsLiBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyBhbGlnbmVkIHdpdGggdGhlIHktYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gMCwgbWVhbmluZyBvbmUgcG9pbnQgaXMgZGlyZWN0bHkgdXB3YXJkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGZvciBjaGFpbmluZyBmdXJ0aGVyIGRyYXdpbmcgY29tbWFuZHMuXG4gICAqL1xuICBzdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cyA9IDAsIHJvdGF0aW9uID0gMCkge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICB0aGlzLl9hY3RpdmVQYXRoLnN0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzLCByb3RhdGlvbiwgdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIHJlbmRlcnMgYW4gU1ZHIHN0cmluZyBpbnRvIHRoZSBncmFwaGljcyBjb250ZXh0LiBUaGlzIGFsbG93cyBmb3IgY29tcGxleCBzaGFwZXMgYW5kIHBhdGhzXG4gICAqIGRlZmluZWQgaW4gU1ZHIGZvcm1hdCB0byBiZSBkcmF3biB3aXRoaW4gdGhlIGdyYXBoaWNzIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzdmcgLSBUaGUgU1ZHIHN0cmluZyB0byBiZSBwYXJzZWQgYW5kIHJlbmRlcmVkLlxuICAgKi9cbiAgc3ZnKHN2Zykge1xuICAgIHRoaXMuX3RpY2srKztcbiAgICBTVkdQYXJzZXIoc3ZnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIG1vc3QgcmVjZW50bHkgc2F2ZWQgZ3JhcGhpY3Mgc3RhdGUgYnkgcG9wcGluZyB0aGUgdG9wIG9mIHRoZSBncmFwaGljcyBzdGF0ZSBzdGFjay5cbiAgICogVGhpcyBpbmNsdWRlcyB0cmFuc2Zvcm1hdGlvbnMsIGZpbGwgc3R5bGVzLCBhbmQgc3Ryb2tlIHN0eWxlcy5cbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtO1xuICAgICAgdGhpcy5fZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgICAgdGhpcy5fc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIFNhdmVzIHRoZSBjdXJyZW50IGdyYXBoaWNzIHN0YXRlLCBpbmNsdWRpbmcgdHJhbnNmb3JtYXRpb25zLCBmaWxsIHN0eWxlcywgYW5kIHN0cm9rZSBzdHlsZXMsIG9udG8gYSBzdGFjay4gKi9cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2goe1xuICAgICAgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0uY2xvbmUoKSxcbiAgICAgIGZpbGxTdHlsZTogeyAuLi50aGlzLl9maWxsU3R5bGUgfSxcbiAgICAgIHN0cm9rZVN0eWxlOiB7IC4uLnRoaXMuX3N0cm9rZVN0eWxlIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQuXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICovXG4gIGdldFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHRoZSBpZGVudGl0eSBtYXRyaXgsIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFueSB0cmFuc2Zvcm1hdGlvbnMgKHJvdGF0aW9uLCBzY2FsaW5nLCB0cmFuc2xhdGlvbikgcHJldmlvdXNseSBhcHBsaWVkLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICByZXNldFRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBncmFwaGljcyBjb250ZXh0IGFyb3VuZCB0aGUgY3VycmVudCBvcmlnaW4uXG4gICAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICByb3RhdGUoYW5nbGUpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0ucm90YXRlKGFuZ2xlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHNjYWxpbmcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHQsIHNjYWxpbmcgZHJhd2luZ3MgYnkgeCBob3Jpem9udGFsbHkgYW5kIGJ5IHkgdmVydGljYWxseS5cbiAgICogQHBhcmFtIHggLSBUaGUgc2NhbGUgZmFjdG9yIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHkgLSAoT3B0aW9uYWwpIFRoZSBzY2FsZSBmYWN0b3IgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHggdmFsdWUgaXMgdXNlZCBmb3IgYm90aCBkaXJlY3Rpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICBzY2FsZSh4LCB5ID0geCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybS5zY2FsZSh4LCB5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZHgsIGR5KSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybS5zZXQoYS5hLCBhLmIsIGEuYywgYS5kLCBhLnR4LCBhLnR5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl90cmFuc2Zvcm0uc2V0KGEsIGIsIGMsIGQsIGR4LCBkeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGR4LCBkeSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0uYXBwZW5kKGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRlbXBNYXRyaXguc2V0KGEsIGIsIGMsIGQsIGR4LCBkeSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtLmFwcGVuZCh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBhIHRyYW5zbGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBncmFwaGljcyBjb250ZXh0LCBtb3ZpbmcgdGhlIG9yaWdpbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudHMuXG4gICAqIEBwYXJhbSB4IC0gVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0geSAtIChPcHRpb25hbCkgVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHggdmFsdWUgaXMgdXNlZCBmb3IgYm90aCBkaXJlY3Rpb25zLlxuICAgKiBAcmV0dXJucyBUaGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3NDb250ZXh0IGZvciBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICB0cmFuc2xhdGUoeCwgeSA9IHgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0udHJhbnNsYXRlKHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGRyYXdpbmcgY29tbWFuZHMgZnJvbSB0aGUgZ3JhcGhpY3MgY29udGV4dCwgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIGl0LiBUaGlzIGluY2x1ZGVzIGNsZWFyaW5nIHRoZSBwYXRoLFxuICAgKiBhbmQgb3B0aW9uYWxseSByZXNldHRpbmcgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBHcmFwaGljc0NvbnRleHQgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvblVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcywgMTYpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKiogVGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZS4gKi9cbiAgZ2V0IGJvdW5kcygpIHtcbiAgICBpZiAoIXRoaXMuX2JvdW5kc0RpcnR5KVxuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGluc3RydWN0aW9uLmFjdGlvbjtcbiAgICAgIGlmIChhY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkQm91bmRzKGRhdGEucGF0aC5ib3VuZHMpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoZGF0YS5keCwgZGF0YS5keSwgZGF0YS5keCArIGRhdGEuZHcsIGRhdGEuZHkgKyBkYXRhLmRoLCBkYXRhLnRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbi5kYXRhO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gZGF0YS5zdHlsZS53aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IF9ib3VuZHMgPSBkYXRhLnBhdGguYm91bmRzO1xuICAgICAgICBib3VuZHMuYWRkRnJhbWUoXG4gICAgICAgICAgX2JvdW5kcy5taW5YIC0gcGFkZGluZyxcbiAgICAgICAgICBfYm91bmRzLm1pblkgLSBwYWRkaW5nLFxuICAgICAgICAgIF9ib3VuZHMubWF4WCArIHBhZGRpbmcsXG4gICAgICAgICAgX2JvdW5kcy5tYXhZICsgcGFkZGluZ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSBwb2ludCAtIFBvaW50IHRvIGNoZWNrIGlmIGl0J3MgY29udGFpbmVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxuICAgKi9cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5ib3VuZHMuY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICBsZXQgaGFzSGl0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2tdO1xuICAgICAgY29uc3QgZGF0YSA9IGluc3RydWN0aW9uLmRhdGE7XG4gICAgICBjb25zdCBwYXRoID0gZGF0YS5wYXRoO1xuICAgICAgaWYgKCFpbnN0cnVjdGlvbi5hY3Rpb24gfHwgIXBhdGgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgICAgY29uc3Qgc2hhcGVzID0gcGF0aC5zaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbaV0uc2hhcGU7XG4gICAgICAgIGlmICghc3R5bGUgfHwgIXNoYXBlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzaGFwZXNbaV0udHJhbnNmb3JtO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdG1wUG9pbnQpIDogcG9pbnQ7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwiZmlsbFwiKSB7XG4gICAgICAgICAgaGFzSGl0ID0gc2hhcGUuY29udGFpbnModHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0hpdCA9IHNoYXBlLnN0cm9rZUNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBzdHlsZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9sZXMgPSBkYXRhLmhvbGU7XG4gICAgICAgIGlmIChob2xlcykge1xuICAgICAgICAgIGNvbnN0IGhvbGVTaGFwZXMgPSBob2xlcy5zaGFwZVBhdGg/LnNoYXBlUHJpbWl0aXZlcztcbiAgICAgICAgICBpZiAoaG9sZVNoYXBlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBob2xlU2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChob2xlU2hhcGVzW2pdLnNoYXBlLmNvbnRhaW5zKHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55KSkge1xuICAgICAgICAgICAgICAgIGhhc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIaXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzSGl0O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3NEYXRhIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlP1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmVTb3VyY2U9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgc291cmNlIG9mIHRoZSBmaWxsL3N0cm9rZSBzdHlsZT9cbiAgICovXG4gIGRlc3Ryb3kob3B0aW9ucyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmU7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICBjb25zdCBkZXN0cm95VGV4dHVyZVNvdXJjZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy50ZXh0dXJlU291cmNlO1xuICAgICAgaWYgKHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS50ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0cm9rZVN0eWxlLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlU3R5bGUudGV4dHVyZS5kZXN0cm95KGRlc3Ryb3lUZXh0dXJlU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmlsbFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHJva2VTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVBhdGggPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGVTdGFjayA9IG51bGw7XG4gICAgdGhpcy5jdXN0b21TaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IG51bGw7XG4gIH1cbn07XG4vKiogVGhlIGRlZmF1bHQgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiBub25lIGlzIHByb3ZpZGVkLiAqL1xuX0dyYXBoaWNzQ29udGV4dC5kZWZhdWx0RmlsbFN0eWxlID0ge1xuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIGNvbG9yOiAxNjc3NzIxNSxcbiAgLyoqIFRoZSBhbHBoYSB2YWx1ZSB0byB1c2UgZm9yIHRoZSBmaWxsLiAqL1xuICBhbHBoYTogMSxcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbi8qKiBUaGUgZGVmYXVsdCBzdHJva2Ugc3R5bGUgdG8gdXNlIHdoZW4gbm9uZSBpcyBwcm92aWRlZC4gKi9cbl9HcmFwaGljc0NvbnRleHQuZGVmYXVsdFN0cm9rZVN0eWxlID0ge1xuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBzdHJva2UuICovXG4gIHdpZHRoOiAxLFxuICAvKiogVGhlIGNvbG9yIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgY29sb3I6IDE2Nzc3MjE1LFxuICAvKiogVGhlIGFscGhhIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHN0cm9rZS4gKi9cbiAgYWxwaGE6IDEsXG4gIC8qKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBzdHJva2UuICovXG4gIGFsaWdubWVudDogMC41LFxuICAvKiogVGhlIG1pdGVyIGxpbWl0IHRvIHVzZS4gKi9cbiAgbWl0ZXJMaW1pdDogMTAsXG4gIC8qKiBUaGUgbGluZSBjYXAgc3R5bGUgdG8gdXNlLiAqL1xuICBjYXA6IFwiYnV0dFwiLFxuICAvKiogVGhlIGxpbmUgam9pbiBzdHlsZSB0byB1c2UuICovXG4gIGpvaW46IFwibWl0ZXJcIixcbiAgLyoqIFRoZSB0ZXh0dXJlIHRvIHVzZSBmb3IgdGhlIGZpbGwuICovXG4gIHRleHR1cmU6IFRleHR1cmUuV0hJVEUsXG4gIC8qKiBUaGUgbWF0cml4IHRvIGFwcGx5LiAqL1xuICBtYXRyaXg6IG51bGwsXG4gIC8qKiBUaGUgZmlsbCBwYXR0ZXJuIHRvIHVzZS4gKi9cbiAgZmlsbDogbnVsbFxufTtcbmxldCBHcmFwaGljc0NvbnRleHQgPSBfR3JhcGhpY3NDb250ZXh0O1xuXG5leHBvcnQgeyBHcmFwaGljc0NvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6653\n')},4108:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  hJ: () => (/* binding */ GraphicsContextSystem)\n});\n\n// UNUSED EXPORTS: GpuGraphicsContext, GraphicsContextRenderData\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs\nvar BatchGeometry = __webpack_require__(2971);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs\nvar getTextureBatchBindGroup = __webpack_require__(3018);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs + 3 modules\nvar Batcher = __webpack_require__(2067);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs\nvar InstructionSet = __webpack_require__(1854);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(5906);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs\n\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=buildUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs\n\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\n\n//# sourceMappingURL=transformVertices.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs\nvar BatchableGraphics = __webpack_require__(26);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs\n\nconst buildCircle = {\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === "circle") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === "ellipse") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1134);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs\n\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs\n\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\n\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs\n\n\n\n\n"use strict";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point/* Point */.E(points[0], points[1]);\n  const lastPoint = new Point/* Point */.E(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === "round") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === "round") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === "round") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === "round") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === "square") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs\n\n\n"use strict";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\n\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs\n\n\n"use strict";\nconst emptyArray = [];\nconst buildPolygon = {\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\n\n//# sourceMappingURL=buildPolygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs\n\nconst buildRectangle = {\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs\n\nconst buildTriangle = {\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\n\n//# sourceMappingURL=buildTriangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst buildMap = {\n  rectangle: buildRectangle,\n  polygon: buildPolygon,\n  triangle: buildTriangle,\n  circle: buildCircle,\n  ellipse: buildCircle,\n  roundedRectangle: buildCircle\n};\nconst tempRect = new Rectangle/* Rectangle */.A();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === "texture") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === "fill" || instruction.action === "stroke") {\n      const isStroke = instruction.action === "stroke";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = buildMap.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = buildMap[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn("[Pixi Graphics] only the last shape have be cut out");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture/* Texture */.x.WHITE) {\n      const textureMatrix = style.matrix;\n      if (matrix) {\n        textureMatrix.append(matrix.clone().invert());\n      }\n      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.I);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = buildMap[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\n\n//# sourceMappingURL=buildContextBatches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry/* BatchGeometry */.J();\n    this.instructions = new InstructionSet/* InstructionSet */.h();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._activeBatchers = [];\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    this._needsContextNeedsRebuild = [];\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  prerender() {\n    this._returnActiveBatchers();\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === "no-batch") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === "auto") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _returnActiveBatchers() {\n    for (let i = 0; i < this._activeBatchers.length; i++) {\n      PoolGroup/* BigPool */.u.return(this._activeBatchers[i]);\n    }\n    this._activeBatchers.length = 0;\n  }\n  _initContextRenderData(context) {\n    const graphicsData = PoolGroup/* BigPool */.u.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = PoolGroup/* BigPool */.u.get(Batcher/* Batcher */.m);\n    this._activeBatchers.push(batcher);\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = (0,getTextureBatchBindGroup/* getTextureBatchBindGroup */.Q)(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on("update", this.onGraphicsContextUpdate, this);\n    context.on("destroy", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextUpdate(context) {\n    this._needsContextNeedsRebuild.push(context);\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off("update", this.onGraphicsContextUpdate, this);\n    context.off("destroy", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        PoolGroup/* BigPool */.u.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        PoolGroup/* BigPool */.u.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const context of this._needsContextNeedsRebuild) {\n      if (this._gpuContextHash[context.uid]) {\n        this.onGraphicsContextDestroy(context);\n      }\n    }\n    this._needsContextNeedsRebuild.length = 0;\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.nw.WebGLSystem,\n    Extensions/* ExtensionType */.nw.WebGPUSystem,\n    Extensions/* ExtensionType */.nw.CanvasSystem\n  ],\n  name: "graphicsContext"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\n\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JELE1BQU0sd0JBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTztBQUNoQyxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0Esb0JBQW9CLHdCQUFPLEtBQUssc0JBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQU87QUFDZixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Y7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy9idWlsZFV2cy5tanM/NjJjNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS91dGlscy90cmFuc2Zvcm1WZXJ0aWNlcy5tanM/OTc0ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZENpcmNsZS5tanM/NGViNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvY29uc3QubWpzP2RhYTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL3V0aWxzL2dldE9yaWVudGF0aW9uT2ZQb2ludHMubWpzP2M5NGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRMaW5lLm1qcz83ZTU1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC91dGlscy90cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanM/MWRhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvYnVpbGRDb21tYW5kcy9idWlsZFBvbHlnb24ubWpzPzk3ZTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRSZWN0YW5nbGUubWpzPzZiN2QiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL2J1aWxkQ29tbWFuZHMvYnVpbGRUcmlhbmdsZS5tanM/Y2Y1MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanM/M2ZjNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcz8zYmNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYnVpbGRVdnModmVydGljZXMsIHZlcnRpY2VzU3RyaWRlLCB2ZXJ0aWNlc09mZnNldCwgdXZzLCB1dnNPZmZzZXQsIHV2c1N0cmlkZSwgc2l6ZSwgbWF0cml4ID0gbnVsbCkge1xuICBsZXQgaW5kZXggPSAwO1xuICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICBjb25zdCBiID0gbWF0cml4LmI7XG4gIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICBjb25zdCB0eCA9IG1hdHJpeC50eDtcbiAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gIHdoaWxlIChpbmRleCA8IHNpemUpIHtcbiAgICBjb25zdCB4ID0gdmVydGljZXNbdmVydGljZXNPZmZzZXRdO1xuICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIDFdO1xuICAgIHV2c1t1dnNPZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHV2c1t1dnNPZmZzZXQgKyAxXSA9IGIgKiB4ICsgZCAqIHkgKyB0eTtcbiAgICB1dnNPZmZzZXQgKz0gdXZzU3RyaWRlO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGV4Kys7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkU2ltcGxlVXZzKHV2cywgdXZzT2Zmc2V0LCB1dnNTdHJpZGUsIHNpemUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgdXZzT2Zmc2V0ICo9IHV2c1N0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIHV2c1t1dnNPZmZzZXRdID0gMDtcbiAgICB1dnNbdXZzT2Zmc2V0ICsgMV0gPSAwO1xuICAgIHV2c09mZnNldCArPSB1dnNTdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNpbXBsZVV2cywgYnVpbGRVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVXZzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGljZXModmVydGljZXMsIG0sIG9mZnNldCwgc3RyaWRlLCBzaXplKSB7XG4gIGNvbnN0IGEgPSBtLmE7XG4gIGNvbnN0IGIgPSBtLmI7XG4gIGNvbnN0IGMgPSBtLmM7XG4gIGNvbnN0IGQgPSBtLmQ7XG4gIGNvbnN0IHR4ID0gbS50eDtcbiAgY29uc3QgdHkgPSBtLnR5O1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgc3RyaWRlID0gc3RyaWRlIHx8IDI7XG4gIHNpemUgPSBzaXplIHx8IHZlcnRpY2VzLmxlbmd0aCAvIHN0cmlkZSAtIG9mZnNldDtcbiAgbGV0IGluZGV4ID0gb2Zmc2V0ICogc3RyaWRlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHggPSB2ZXJ0aWNlc1tpbmRleF07XG4gICAgY29uc3QgeSA9IHZlcnRpY2VzW2luZGV4ICsgMV07XG4gICAgdmVydGljZXNbaW5kZXhdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgaW5kZXggKz0gc3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1WZXJ0aWNlcy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGJ1aWxkQ2lyY2xlID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTtcbiAgICBsZXQgcng7XG4gICAgbGV0IHJ5O1xuICAgIGlmIChzaGFwZS50eXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBzaGFwZTtcbiAgICAgIHggPSBjaXJjbGUueDtcbiAgICAgIHkgPSBjaXJjbGUueTtcbiAgICAgIHJ4ID0gcnkgPSBjaXJjbGUucmFkaXVzO1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIGlmIChzaGFwZS50eXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgY29uc3QgZWxsaXBzZSA9IHNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueDtcbiAgICAgIHkgPSBlbGxpcHNlLnk7XG4gICAgICByeCA9IGVsbGlwc2UuaGFsZldpZHRoO1xuICAgICAgcnkgPSBlbGxpcHNlLmhhbGZIZWlnaHQ7XG4gICAgICBkeCA9IGR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgcm91bmRlZFJlY3QgPSBzaGFwZTtcbiAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHJvdW5kZWRSZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgeCA9IHJvdW5kZWRSZWN0LnggKyBoYWxmV2lkdGg7XG4gICAgICB5ID0gcm91bmRlZFJlY3QueSArIGhhbGZIZWlnaHQ7XG4gICAgICByeCA9IHJ5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm91bmRlZFJlY3QucmFkaXVzLCBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQpKSk7XG4gICAgICBkeCA9IGhhbGZXaWR0aCAtIHJ4O1xuICAgICAgZHkgPSBoYWxmSGVpZ2h0IC0gcnk7XG4gICAgfVxuICAgIGlmICghKHJ4ID49IDAgJiYgcnkgPj0gMCAmJiBkeCA+PSAwICYmIGR5ID49IDApKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSk7XG4gICAgY29uc3QgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIGlmIChtID09PSAwKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzZdID0geCArIGR4O1xuICAgICAgcG9pbnRzWzFdID0gcG9pbnRzWzNdID0geSArIGR5O1xuICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzRdID0geCAtIGR4O1xuICAgICAgcG9pbnRzWzVdID0gcG9pbnRzWzddID0geSAtIGR5O1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgbGV0IGoxID0gMDtcbiAgICBsZXQgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDI7XG4gICAgbGV0IGozID0gajI7XG4gICAgbGV0IGo0ID0gbTtcbiAgICBsZXQgeDAgPSBkeCArIHJ4O1xuICAgIGxldCB5MCA9IGR5O1xuICAgIGxldCB4MSA9IHggKyB4MDtcbiAgICBsZXQgeDIgPSB4IC0geDA7XG4gICAgbGV0IHkxID0geSArIHkwO1xuICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgIHBvaW50c1tqMSsrXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgIHBvaW50c1stLWoyXSA9IHgyO1xuICAgIGlmIChkeSkge1xuICAgICAgY29uc3QgeTIyID0geSAtIHkwO1xuICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjI7XG4gICAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLlBJIC8gMiAqIChpIC8gbik7XG4gICAgICBjb25zdCB4MDIgPSBkeCArIE1hdGguY29zKGEpICogcng7XG4gICAgICBjb25zdCB5MDIgPSBkeSArIE1hdGguc2luKGEpICogcnk7XG4gICAgICBjb25zdCB4MTIgPSB4ICsgeDAyO1xuICAgICAgY29uc3QgeDIyID0geCAtIHgwMjtcbiAgICAgIGNvbnN0IHkxMiA9IHkgKyB5MDI7XG4gICAgICBjb25zdCB5MjIgPSB5IC0geTAyO1xuICAgICAgcG9pbnRzW2oxKytdID0geDEyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geTEyO1xuICAgICAgcG9pbnRzWy0tajJdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geDIyO1xuICAgICAgcG9pbnRzW2ozKytdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geTIyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDEyO1xuICAgIH1cbiAgICB4MCA9IGR4O1xuICAgIHkwID0gZHkgKyByeTtcbiAgICB4MSA9IHggKyB4MDtcbiAgICB4MiA9IHggLSB4MDtcbiAgICB5MSA9IHkgKyB5MDtcbiAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICBwb2ludHNbajErK10gPSB4MTtcbiAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICBwb2ludHNbLS1qNF0gPSB4MTtcbiAgICBpZiAoZHgpIHtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgyO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgyO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2VudGVyWCA9IDA7XG4gICAgbGV0IGNlbnRlclkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjZW50ZXJYICs9IHBvaW50c1tpXTtcbiAgICAgIGNlbnRlclkgKz0gcG9pbnRzW2kgKyAxXTtcbiAgICB9XG4gICAgY2VudGVyWCAvPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBjZW50ZXJZIC89IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIGxldCBjb3VudCA9IHZlcnRpY2VzT2Zmc2V0O1xuICAgIHZlcnRpY2VzW2NvdW50ICogdmVydGljZXNTdHJpZGVdID0gY2VudGVyWDtcbiAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBjZW50ZXJZO1xuICAgIGNvbnN0IGNlbnRlckluZGV4ID0gY291bnQrKztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmVydGljZXNbY291bnQgKiB2ZXJ0aWNlc1N0cmlkZV0gPSBwb2ludHNbaV07XG4gICAgICB2ZXJ0aWNlc1tjb3VudCAqIHZlcnRpY2VzU3RyaWRlICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50O1xuICAgICAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSBjZW50ZXJJbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY291bnQgLSAxO1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gY2VudGVySW5kZXggKyAxO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNlbnRlckluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IGNvdW50IC0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRDaXJjbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkQ2lyY2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY2xvc2VQb2ludEVwcyA9IDFlLTQ7XG5jb25zdCBjdXJ2ZUVwcyA9IDFlLTQ7XG5cbmV4cG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKSB7XG4gIGNvbnN0IG0gPSBwb2ludHMubGVuZ3RoO1xuICBpZiAobSA8IDYpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IHkyID0gcG9pbnRzW2kgKyAxXTtcbiAgICBhcmVhICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgaWYgKGFyZWEgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBnZXRPcmllbnRhdGlvbk9mUG9pbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvcG9pbnQvUG9pbnQubWpzJztcbmltcG9ydCB7IGNsb3NlUG9pbnRFcHMsIGN1cnZlRXBzIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IGdldE9yaWVudGF0aW9uT2ZQb2ludHMgfSBmcm9tICcuLi91dGlscy9nZXRPcmllbnRhdGlvbk9mUG9pbnRzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3F1YXJlKHgsIHksIG54LCBueSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBjbG9ja3dpc2UsIHZlcnRzKSB7XG4gIGNvbnN0IGl4ID0geCAtIG54ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IGl5ID0geSAtIG55ICogaW5uZXJXZWlnaHQ7XG4gIGNvbnN0IG94ID0geCArIG54ICogb3V0ZXJXZWlnaHQ7XG4gIGNvbnN0IG95ID0geSArIG55ICogb3V0ZXJXZWlnaHQ7XG4gIGxldCBleHg7XG4gIGxldCBleXk7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICBleHggPSBueTtcbiAgICBleXkgPSAtbng7XG4gIH0gZWxzZSB7XG4gICAgZXh4ID0gLW55O1xuICAgIGV5eSA9IG54O1xuICB9XG4gIGNvbnN0IGVpeCA9IGl4ICsgZXh4O1xuICBjb25zdCBlaXkgPSBpeSArIGV5eTtcbiAgY29uc3QgZW94ID0gb3ggKyBleHg7XG4gIGNvbnN0IGVveSA9IG95ICsgZXl5O1xuICB2ZXJ0cy5wdXNoKGVpeCwgZWl5KTtcbiAgdmVydHMucHVzaChlb3gsIGVveSk7XG4gIHJldHVybiAyO1xufVxuZnVuY3Rpb24gcm91bmQoY3gsIGN5LCBzeCwgc3ksIGV4LCBleSwgdmVydHMsIGNsb2Nrd2lzZSkge1xuICBjb25zdCBjeDJwMHggPSBzeCAtIGN4O1xuICBjb25zdCBjeTJwMHkgPSBzeSAtIGN5O1xuICBsZXQgYW5nbGUwID0gTWF0aC5hdGFuMihjeDJwMHgsIGN5MnAweSk7XG4gIGxldCBhbmdsZTEgPSBNYXRoLmF0YW4yKGV4IC0gY3gsIGV5IC0gY3kpO1xuICBpZiAoY2xvY2t3aXNlICYmIGFuZ2xlMCA8IGFuZ2xlMSkge1xuICAgIGFuZ2xlMCArPSBNYXRoLlBJICogMjtcbiAgfSBlbHNlIGlmICghY2xvY2t3aXNlICYmIGFuZ2xlMCA+IGFuZ2xlMSkge1xuICAgIGFuZ2xlMSArPSBNYXRoLlBJICogMjtcbiAgfVxuICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlMDtcbiAgY29uc3QgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwO1xuICBjb25zdCBhYnNBbmdsZURpZmYgPSBNYXRoLmFicyhhbmdsZURpZmYpO1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoY3gycDB4ICogY3gycDB4ICsgY3kycDB5ICogY3kycDB5KTtcbiAgY29uc3Qgc2VnQ291bnQgPSAoMTUgKiBhYnNBbmdsZURpZmYgKiBNYXRoLnNxcnQocmFkaXVzKSAvIE1hdGguUEkgPj4gMCkgKyAxO1xuICBjb25zdCBhbmdsZUluYyA9IGFuZ2xlRGlmZiAvIHNlZ0NvdW50O1xuICBzdGFydEFuZ2xlICs9IGFuZ2xlSW5jO1xuICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goc3gsIHN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3gsIGN5KTtcbiAgICAgIHZlcnRzLnB1c2goXG4gICAgICAgIGN4ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgICBjeSArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1c1xuICAgICAgKTtcbiAgICB9XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIHZlcnRzLnB1c2goZXgsIGV5KTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0cy5wdXNoKHN4LCBzeSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIGZvciAobGV0IGkgPSAxLCBhbmdsZSA9IHN0YXJ0QW5nbGU7IGkgPCBzZWdDb3VudDsgaSsrLCBhbmdsZSArPSBhbmdsZUluYykge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzXG4gICAgICApO1xuICAgICAgdmVydHMucHVzaChjeCwgY3kpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGV4LCBleSk7XG4gICAgdmVydHMucHVzaChjeCwgY3kpO1xuICB9XG4gIHJldHVybiBzZWdDb3VudCAqIDI7XG59XG5mdW5jdGlvbiBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZsaXBBbGlnbm1lbnQsIGNsb3NlZCwgdmVydGljZXMsIF92ZXJ0aWNlc1N0cmlkZSwgX3ZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBfaW5kaWNlc09mZnNldCkge1xuICBjb25zdCBlcHMgPSBjbG9zZVBvaW50RXBzO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdHlsZSA9IGxpbmVTdHlsZTtcbiAgbGV0IGFsaWdubWVudCA9IHN0eWxlLmFsaWdubWVudDtcbiAgaWYgKGxpbmVTdHlsZS5hbGlnbm1lbnQgIT09IDAuNSkge1xuICAgIGxldCBvcmllbnRhdGlvbiA9IGdldE9yaWVudGF0aW9uT2ZQb2ludHMocG9pbnRzKTtcbiAgICBpZiAoZmxpcEFsaWdubWVudClcbiAgICAgIG9yaWVudGF0aW9uICo9IC0xO1xuICAgIGFsaWdubWVudCA9IChhbGlnbm1lbnQgLSAwLjUpICogb3JpZW50YXRpb24gKyAwLjU7XG4gIH1cbiAgY29uc3QgZmlyc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gIGNvbnN0IGxhc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY2xvc2VkU2hhcGUgPSBjbG9zZWQ7XG4gIGNvbnN0IGNsb3NlZFBhdGggPSBNYXRoLmFicyhmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgPCBlcHMgJiYgTWF0aC5hYnMoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpIDwgZXBzO1xuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcbiAgICBpZiAoY2xvc2VkUGF0aCkge1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgbGFzdFBvaW50LnNldChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY29uc3QgbWlkUG9pbnRYID0gKGZpcnN0UG9pbnQueCArIGxhc3RQb2ludC54KSAqIDAuNTtcbiAgICBjb25zdCBtaWRQb2ludFkgPSAobGFzdFBvaW50LnkgKyBmaXJzdFBvaW50LnkpICogMC41O1xuICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gIH1cbiAgY29uc3QgdmVydHMgPSB2ZXJ0aWNlcztcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gIGNvbnN0IHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xuICBjb25zdCB3aWR0aFNxdWFyZWQgPSB3aWR0aCAqIHdpZHRoO1xuICBjb25zdCBtaXRlckxpbWl0U3F1YXJlZCA9IHN0eWxlLm1pdGVyTGltaXQgKiBzdHlsZS5taXRlckxpbWl0O1xuICBsZXQgeDAgPSBwb2ludHNbMF07XG4gIGxldCB5MCA9IHBvaW50c1sxXTtcbiAgbGV0IHgxID0gcG9pbnRzWzJdO1xuICBsZXQgeTEgPSBwb2ludHNbM107XG4gIGxldCB4MiA9IDA7XG4gIGxldCB5MiA9IDA7XG4gIGxldCBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gIGxldCBwZXJwWSA9IHgwIC0geDE7XG4gIGxldCBwZXJwMXggPSAwO1xuICBsZXQgcGVycDF5ID0gMDtcbiAgbGV0IGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gYWxpZ25tZW50O1xuICBjb25zdCBpbm5lcldlaWdodCA9ICgxIC0gcmF0aW8pICogMjtcbiAgY29uc3Qgb3V0ZXJXZWlnaHQgPSByYXRpbyAqIDI7XG4gIGlmICghY2xvc2VkU2hhcGUpIHtcbiAgICBpZiAoc3R5bGUuY2FwID09PSBcInJvdW5kXCIpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgIHgwIC0gcGVycFggKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHkwIC0gcGVycFkgKiAoaW5uZXJXZWlnaHQgLSBvdXRlcldlaWdodCkgKiAwLjUsXG4gICAgICAgIHgwIC0gcGVycFggKiBpbm5lcldlaWdodCxcbiAgICAgICAgeTAgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB4MCArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkwICsgcGVycFkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgdmVydHMsXG4gICAgICAgIHRydWVcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MCwgeTAsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCB0cnVlLCB2ZXJ0cyk7XG4gICAgfVxuICB9XG4gIHZlcnRzLnB1c2goXG4gICAgeDAgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgIHkwIC0gcGVycFkgKiBpbm5lcldlaWdodFxuICApO1xuICB2ZXJ0cy5wdXNoKFxuICAgIHgwICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICB5MCArIHBlcnBZICogb3V0ZXJXZWlnaHRcbiAgKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB4MCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgeTAgPSBwb2ludHNbKGkgLSAxKSAqIDIgKyAxXTtcbiAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICBwZXJwWCA9IC0oeTAgLSB5MSk7XG4gICAgcGVycFkgPSB4MCAtIHgxO1xuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICAgIHBlcnBYIC89IGRpc3Q7XG4gICAgcGVycFkgLz0gZGlzdDtcbiAgICBwZXJwWCAqPSB3aWR0aDtcbiAgICBwZXJwWSAqPSB3aWR0aDtcbiAgICBwZXJwMXggPSAtKHkxIC0geTIpO1xuICAgIHBlcnAxeSA9IHgxIC0geDI7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJwMXggKiBwZXJwMXggKyBwZXJwMXkgKiBwZXJwMXkpO1xuICAgIHBlcnAxeCAvPSBkaXN0O1xuICAgIHBlcnAxeSAvPSBkaXN0O1xuICAgIHBlcnAxeCAqPSB3aWR0aDtcbiAgICBwZXJwMXkgKj0gd2lkdGg7XG4gICAgY29uc3QgZHgwID0geDEgLSB4MDtcbiAgICBjb25zdCBkeTAgPSB5MCAtIHkxO1xuICAgIGNvbnN0IGR4MSA9IHgxIC0geDI7XG4gICAgY29uc3QgZHkxID0geTIgLSB5MTtcbiAgICBjb25zdCBkb3QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gICAgY29uc3QgY3Jvc3MgPSBkeTAgKiBkeDEgLSBkeTEgKiBkeDA7XG4gICAgY29uc3QgY2xvY2t3aXNlID0gY3Jvc3MgPCAwO1xuICAgIGlmIChNYXRoLmFicyhjcm9zcykgPCAxZS0zICogTWF0aC5hYnMoZG90KSkge1xuICAgICAgdmVydHMucHVzaChcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHRcbiAgICAgICk7XG4gICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgIHkxICsgcGVycFkgKiBvdXRlcldlaWdodFxuICAgICAgKTtcbiAgICAgIGlmIChkb3QgPj0gMCkge1xuICAgICAgICBpZiAoc3R5bGUuam9pbiA9PT0gXCJyb3VuZFwiKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSAtIHBlcnBYICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSAtIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgIHkxIC0gcGVycDF5ICogb3V0ZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICB4MSArIHBlcnAxeCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgIHkxICsgcGVycDF5ICogaW5uZXJXZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjMSA9ICgtcGVycFggKyB4MCkgKiAoLXBlcnBZICsgeTEpIC0gKC1wZXJwWCArIHgxKSAqICgtcGVycFkgKyB5MCk7XG4gICAgY29uc3QgYzIgPSAoLXBlcnAxeCArIHgyKSAqICgtcGVycDF5ICsgeTEpIC0gKC1wZXJwMXggKyB4MSkgKiAoLXBlcnAxeSArIHkyKTtcbiAgICBjb25zdCBweCA9IChkeDAgKiBjMiAtIGR4MSAqIGMxKSAvIGNyb3NzO1xuICAgIGNvbnN0IHB5ID0gKGR5MSAqIGMxIC0gZHkwICogYzIpIC8gY3Jvc3M7XG4gICAgY29uc3QgcERpc3QgPSAocHggLSB4MSkgKiAocHggLSB4MSkgKyAocHkgLSB5MSkgKiAocHkgLSB5MSk7XG4gICAgY29uc3QgaW14ID0geDEgKyAocHggLSB4MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBpbXkgPSB5MSArIChweSAtIHkxKSAqIGlubmVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teCA9IHgxIC0gKHB4IC0geDEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgb215ID0geTEgLSAocHkgLSB5MSkgKiBvdXRlcldlaWdodDtcbiAgICBjb25zdCBzbWFsbGVySW5zaWRlU2VnbWVudFNxID0gTWF0aC5taW4oZHgwICogZHgwICsgZHkwICogZHkwLCBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgIGNvbnN0IGluc2lkZVdlaWdodCA9IGNsb2Nrd2lzZSA/IGlubmVyV2VpZ2h0IDogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZURpYWdvbmFsU3EgPSBzbWFsbGVySW5zaWRlU2VnbWVudFNxICsgaW5zaWRlV2VpZ2h0ICogaW5zaWRlV2VpZ2h0ICogd2lkdGhTcXVhcmVkO1xuICAgIGNvbnN0IGluc2lkZU1pdGVyT2sgPSBwRGlzdCA8PSBzbWFsbGVySW5zaWRlRGlhZ29uYWxTcTtcbiAgICBpZiAoaW5zaWRlTWl0ZXJPaykge1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwiYmV2ZWxcIiB8fCBwRGlzdCAvIHdpZHRoU3F1YXJlZCA+IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICAgICAgdmVydHMucHVzaChvbXgsIG9teSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5qb2luID09PSBcInJvdW5kXCIpIHtcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXkpO1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApICsgNDtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDQ7XG4gICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSk7XG4gICAgICAgIHZlcnRzLnB1c2gob214LCBvbXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycFggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0KTtcbiAgICAgIHZlcnRzLnB1c2goeDEgKyBwZXJwWCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IFwicm91bmRcIikge1xuICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICB4MSArIHBlcnBYICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB5MSArIHBlcnBZICogb3V0ZXJXZWlnaHQsXG4gICAgICAgICAgICB4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCxcbiAgICAgICAgICAgIHZlcnRzLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeTEgLSBwZXJwWSAqIGlubmVyV2VpZ2h0LFxuICAgICAgICAgICAgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCxcbiAgICAgICAgICAgIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsXG4gICAgICAgICAgICB2ZXJ0cyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSArIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUuam9pbiA9PT0gXCJtaXRlclwiICYmIHBEaXN0IC8gd2lkdGhTcXVhcmVkIDw9IG1pdGVyTGltaXRTcXVhcmVkKSB7XG4gICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKG9teCwgb215KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgICB2ZXJ0cy5wdXNoKGlteCwgaW15KTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQpO1xuICAgICAgdmVydHMucHVzaCh4MSArIHBlcnAxeCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnAxeSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICB9XG4gIH1cbiAgeDAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMl07XG4gIHkwID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDIgKyAxXTtcbiAgeDEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMl07XG4gIHkxID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDIgKyAxXTtcbiAgcGVycFggPSAtKHkwIC0geTEpO1xuICBwZXJwWSA9IHgwIC0geDE7XG4gIGRpc3QgPSBNYXRoLnNxcnQocGVycFggKiBwZXJwWCArIHBlcnBZICogcGVycFkpO1xuICBwZXJwWCAvPSBkaXN0O1xuICBwZXJwWSAvPSBkaXN0O1xuICBwZXJwWCAqPSB3aWR0aDtcbiAgcGVycFkgKj0gd2lkdGg7XG4gIHZlcnRzLnB1c2goeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQpO1xuICB2ZXJ0cy5wdXNoKHgxICsgcGVycFggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0KTtcbiAgaWYgKCFjbG9zZWRTaGFwZSkge1xuICAgIGlmIChzdHlsZS5jYXAgPT09IFwicm91bmRcIikge1xuICAgICAgaW5kZXhDb3VudCArPSByb3VuZChcbiAgICAgICAgeDEgLSBwZXJwWCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeTEgLSBwZXJwWSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSxcbiAgICAgICAgeDEgLSBwZXJwWCAqIGlubmVyV2VpZ2h0LFxuICAgICAgICB5MSAtIHBlcnBZICogaW5uZXJXZWlnaHQsXG4gICAgICAgIHgxICsgcGVycFggKiBvdXRlcldlaWdodCxcbiAgICAgICAgeTEgKyBwZXJwWSAqIG91dGVyV2VpZ2h0LFxuICAgICAgICB2ZXJ0cyxcbiAgICAgICAgZmFsc2VcbiAgICAgICkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBcInNxdWFyZVwiKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnBYLCBwZXJwWSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBmYWxzZSwgdmVydHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBlcHMyID0gY3VydmVFcHMgKiBjdXJ2ZUVwcztcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSkge1xuICAgIHgwID0gdmVydHNbaSAqIDJdO1xuICAgIHkwID0gdmVydHNbaSAqIDIgKyAxXTtcbiAgICB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgeDIgPSB2ZXJ0c1soaSArIDIpICogMl07XG4gICAgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdO1xuICAgIGlmIChNYXRoLmFicyh4MCAqICh5MSAtIHkyKSArIHgxICogKHkyIC0geTApICsgeDIgKiAoeTAgLSB5MSkpIDwgZXBzMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xuICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkTGluZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRMaW5lLm1qcy5tYXBcbiIsImltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB0cmlhbmd1bGF0ZVdpdGhIb2xlcyhwb2ludHMsIGhvbGVzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChwb2ludHMsIGhvbGVzLCAyKTtcbiAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaV0gKyB2ZXJ0aWNlc09mZnNldDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB0cmlhbmdsZXNbaSArIDFdICsgdmVydGljZXNPZmZzZXQ7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdHJpYW5nbGVzW2kgKyAyXSArIHZlcnRpY2VzT2Zmc2V0O1xuICB9XG4gIGxldCBpbmRleCA9IHZlcnRpY2VzT2Zmc2V0ICogdmVydGljZXNTdHJpZGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnRzW2ldO1xuICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBwb2ludHNbaSArIDFdO1xuICAgIGluZGV4ICs9IHZlcnRpY2VzU3RyaWRlO1xuICB9XG59XG5cbmV4cG9ydCB7IHRyaWFuZ3VsYXRlV2l0aEhvbGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmlhbmd1bGF0ZVdpdGhIb2xlcy5tanMubWFwXG4iLCJpbXBvcnQgeyB0cmlhbmd1bGF0ZVdpdGhIb2xlcyB9IGZyb20gJy4uL3V0aWxzL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuY29uc3QgYnVpbGRQb2x5Z29uID0ge1xuICBidWlsZChzaGFwZSwgcG9pbnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvaW50c1tpXSA9IHNoYXBlLnBvaW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMocG9pbnRzLCBlbXB0eUFycmF5LCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRQb2x5Z29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFBvbHlnb24ubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIGNvbnN0IHJlY3REYXRhID0gc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgaWYgKCEod2lkdGggPj0gMCAmJiBoZWlnaHQgPj0gMCkpIHtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHBvaW50c1swXSA9IHg7XG4gICAgcG9pbnRzWzFdID0geTtcbiAgICBwb2ludHNbMl0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzNdID0geTtcbiAgICBwb2ludHNbNF0gPSB4ICsgd2lkdGg7XG4gICAgcG9pbnRzWzVdID0geSArIGhlaWdodDtcbiAgICBwb2ludHNbNl0gPSB4O1xuICAgIHBvaW50c1s3XSA9IHkgKyBoZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgdHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgdmVydGljZXNTdHJpZGUsIHZlcnRpY2VzT2Zmc2V0LCBpbmRpY2VzLCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB2ZXJ0aWNlc09mZnNldCAqPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1swXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbMV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbMl07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzNdO1xuICAgIGNvdW50ICs9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzZdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1s3XTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1s0XTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbNV07XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgY29uc3QgdmVydGljZXNJbmRleCA9IHZlcnRpY2VzT2Zmc2V0IC8gdmVydGljZXNTdHJpZGU7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMTtcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMztcbiAgICBpbmRpY2VzW2luZGljZXNPZmZzZXQrK10gPSB2ZXJ0aWNlc0luZGV4ICsgMjtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRUcmlhbmdsZSA9IHtcbiAgYnVpbGQoc2hhcGUsIHBvaW50cykge1xuICAgIHBvaW50c1swXSA9IHNoYXBlLng7XG4gICAgcG9pbnRzWzFdID0gc2hhcGUueTtcbiAgICBwb2ludHNbMl0gPSBzaGFwZS54MjtcbiAgICBwb2ludHNbM10gPSBzaGFwZS55MjtcbiAgICBwb2ludHNbNF0gPSBzaGFwZS54MztcbiAgICBwb2ludHNbNV0gPSBzaGFwZS55MztcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICB0cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCB2ZXJ0aWNlc1N0cmlkZSwgdmVydGljZXNPZmZzZXQsIGluZGljZXMsIGluZGljZXNPZmZzZXQpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHZlcnRpY2VzT2Zmc2V0ICo9IHZlcnRpY2VzU3RyaWRlO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnRdID0gcG9pbnRzWzBdO1xuICAgIHZlcnRpY2VzW3ZlcnRpY2VzT2Zmc2V0ICsgY291bnQgKyAxXSA9IHBvaW50c1sxXTtcbiAgICBjb3VudCArPSB2ZXJ0aWNlc1N0cmlkZTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50XSA9IHBvaW50c1syXTtcbiAgICB2ZXJ0aWNlc1t2ZXJ0aWNlc09mZnNldCArIGNvdW50ICsgMV0gPSBwb2ludHNbM107XG4gICAgY291bnQgKz0gdmVydGljZXNTdHJpZGU7XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudF0gPSBwb2ludHNbNF07XG4gICAgdmVydGljZXNbdmVydGljZXNPZmZzZXQgKyBjb3VudCArIDFdID0gcG9pbnRzWzVdO1xuICAgIGNvbnN0IHZlcnRpY2VzSW5kZXggPSB2ZXJ0aWNlc09mZnNldCAvIHZlcnRpY2VzU3RyaWRlO1xuICAgIGluZGljZXNbaW5kaWNlc09mZnNldCsrXSA9IHZlcnRpY2VzSW5kZXg7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDE7XG4gICAgaW5kaWNlc1tpbmRpY2VzT2Zmc2V0KytdID0gdmVydGljZXNJbmRleCArIDI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGJ1aWxkVHJpYW5nbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkVHJpYW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRVdnMsIGJ1aWxkU2ltcGxlVXZzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvYnVpbGRVdnMubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVZlcnRpY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvdXRpbHMvdHJhbnNmb3JtVmVydGljZXMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlR3JhcGhpY3MgfSBmcm9tICcuLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZExpbmUgfSBmcm9tICcuLi9idWlsZENvbW1hbmRzL2J1aWxkTGluZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRQb2x5Z29uIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFBvbHlnb24ubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi4vYnVpbGRDb21tYW5kcy9idWlsZFJlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRUcmlhbmdsZSB9IGZyb20gJy4uL2J1aWxkQ29tbWFuZHMvYnVpbGRUcmlhbmdsZS5tanMnO1xuaW1wb3J0IHsgdHJpYW5ndWxhdGVXaXRoSG9sZXMgfSBmcm9tICcuL3RyaWFuZ3VsYXRlV2l0aEhvbGVzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYnVpbGRNYXAgPSB7XG4gIHJlY3RhbmdsZTogYnVpbGRSZWN0YW5nbGUsXG4gIHBvbHlnb246IGJ1aWxkUG9seWdvbixcbiAgdHJpYW5nbGU6IGJ1aWxkVHJpYW5nbGUsXG4gIGNpcmNsZTogYnVpbGRDaXJjbGUsXG4gIGVsbGlwc2U6IGJ1aWxkQ2lyY2xlLFxuICByb3VuZGVkUmVjdGFuZ2xlOiBidWlsZENpcmNsZVxufTtcbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuZnVuY3Rpb24gYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KSB7XG4gIGNvbnN0IHsgZ2VvbWV0cnlEYXRhLCBiYXRjaGVzIH0gPSBncHVDb250ZXh0O1xuICBiYXRjaGVzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gIGdlb21ldHJ5RGF0YS52ZXJ0aWNlcy5sZW5ndGggPSAwO1xuICBnZW9tZXRyeURhdGEudXZzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dC5pbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGNvbnRleHQuaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwidGV4dHVyZVwiKSB7XG4gICAgICBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoaW5zdHJ1Y3Rpb24uZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKTtcbiAgICB9IGVsc2UgaWYgKGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJmaWxsXCIgfHwgaW5zdHJ1Y3Rpb24uYWN0aW9uID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBjb25zdCBpc1N0cm9rZSA9IGluc3RydWN0aW9uLmFjdGlvbiA9PT0gXCJzdHJva2VcIjtcbiAgICAgIGNvbnN0IHNoYXBlUGF0aCA9IGluc3RydWN0aW9uLmRhdGEucGF0aC5zaGFwZVBhdGg7XG4gICAgICBjb25zdCBzdHlsZSA9IGluc3RydWN0aW9uLmRhdGEuc3R5bGU7XG4gICAgICBjb25zdCBob2xlID0gaW5zdHJ1Y3Rpb24uZGF0YS5ob2xlO1xuICAgICAgaWYgKGlzU3Ryb2tlICYmIGhvbGUpIHtcbiAgICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoaG9sZS5zaGFwZVBhdGgsIHN0eWxlLCBudWxsLCB0cnVlLCBiYXRjaGVzLCBnZW9tZXRyeURhdGEpO1xuICAgICAgfVxuICAgICAgYWRkU2hhcGVQYXRoVG9HZW9tZXRyeURhdGEoc2hhcGVQYXRoLCBzdHlsZSwgaG9sZSwgaXNTdHJva2UsIGJhdGNoZXMsIGdlb21ldHJ5RGF0YSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUZXh0dXJlVG9HZW9tZXRyeURhdGEoZGF0YSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBpbmRleE9mZnNldCA9IGluZGljZXMubGVuZ3RoO1xuICBjb25zdCB2ZXJ0T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IGJ1aWxkID0gYnVpbGRNYXAucmVjdGFuZ2xlO1xuICBjb25zdCByZWN0ID0gdGVtcFJlY3Q7XG4gIGNvbnN0IHRleHR1cmUgPSBkYXRhLmltYWdlO1xuICByZWN0LnggPSBkYXRhLmR4O1xuICByZWN0LnkgPSBkYXRhLmR5O1xuICByZWN0LndpZHRoID0gZGF0YS5kdztcbiAgcmVjdC5oZWlnaHQgPSBkYXRhLmRoO1xuICBjb25zdCBtYXRyaXggPSBkYXRhLnRyYW5zZm9ybTtcbiAgYnVpbGQuYnVpbGQocmVjdCwgcG9pbnRzKTtcbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVZlcnRpY2VzKHBvaW50cywgbWF0cml4KTtcbiAgfVxuICBidWlsZC50cmlhbmd1bGF0ZShwb2ludHMsIHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCBpbmRpY2VzLCBpbmRleE9mZnNldCk7XG4gIGNvbnN0IHRleHR1cmVVdnMgPSB0ZXh0dXJlLnV2cztcbiAgdXZzLnB1c2goXG4gICAgdGV4dHVyZVV2cy54MCxcbiAgICB0ZXh0dXJlVXZzLnkwLFxuICAgIHRleHR1cmVVdnMueDEsXG4gICAgdGV4dHVyZVV2cy55MSxcbiAgICB0ZXh0dXJlVXZzLngzLFxuICAgIHRleHR1cmVVdnMueTMsXG4gICAgdGV4dHVyZVV2cy54MixcbiAgICB0ZXh0dXJlVXZzLnkyXG4gICk7XG4gIGNvbnN0IGdyYXBoaWNzQmF0Y2ggPSBCaWdQb29sLmdldChCYXRjaGFibGVHcmFwaGljcyk7XG4gIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgZ3JhcGhpY3NCYXRjaC5pbmRleFNpemUgPSBpbmRpY2VzLmxlbmd0aCAtIGluZGV4T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLnZlcnRleE9mZnNldCA9IHZlcnRPZmZzZXQ7XG4gIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICBncmFwaGljc0JhdGNoLmNvbG9yID0gZGF0YS5zdHlsZTtcbiAgZ3JhcGhpY3NCYXRjaC5hbHBoYSA9IGRhdGEuYWxwaGE7XG4gIGdyYXBoaWNzQmF0Y2gudGV4dHVyZSA9IHRleHR1cmU7XG4gIGdyYXBoaWNzQmF0Y2guZ2VvbWV0cnlEYXRhID0gZ2VvbWV0cnlEYXRhO1xuICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG59XG5mdW5jdGlvbiBhZGRTaGFwZVBhdGhUb0dlb21ldHJ5RGF0YShzaGFwZVBhdGgsIHN0eWxlLCBob2xlLCBpc1N0cm9rZSwgYmF0Y2hlcywgZ2VvbWV0cnlEYXRhKSB7XG4gIGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gZ2VvbWV0cnlEYXRhO1xuICBjb25zdCBsYXN0SW5kZXggPSBzaGFwZVBhdGguc2hhcGVQcmltaXRpdmVzLmxlbmd0aCAtIDE7XG4gIHNoYXBlUGF0aC5zaGFwZVByaW1pdGl2ZXMuZm9yRWFjaCgoeyBzaGFwZSwgdHJhbnNmb3JtOiBtYXRyaXggfSwgaSkgPT4ge1xuICAgIGNvbnN0IGluZGV4T2Zmc2V0ID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3QgYnVpbGQgPSBidWlsZE1hcFtzaGFwZS50eXBlXTtcbiAgICBidWlsZC5idWlsZChzaGFwZSwgcG9pbnRzKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB0cmFuc2Zvcm1WZXJ0aWNlcyhwb2ludHMsIG1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgIGlmIChob2xlICYmIGxhc3RJbmRleCA9PT0gaSkge1xuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW1BpeGkgR3JhcGhpY3NdIG9ubHkgdGhlIGxhc3Qgc2hhcGUgaGF2ZSBiZSBjdXQgb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvbGVJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IG90aGVyUG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGhvbGVBcnJheXMgPSBnZXRIb2xlQXJyYXlzKGhvbGUuc2hhcGVQYXRoKTtcbiAgICAgICAgaG9sZUFycmF5cy5mb3JFYWNoKChob2xlUG9pbnRzKSA9PiB7XG4gICAgICAgICAgaG9sZUluZGljZXMucHVzaChvdGhlclBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgICBvdGhlclBvaW50cy5wdXNoKC4uLmhvbGVQb2ludHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJpYW5ndWxhdGVXaXRoSG9sZXMob3RoZXJQb2ludHMsIGhvbGVJbmRpY2VzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbGQudHJpYW5ndWxhdGUocG9pbnRzLCB2ZXJ0aWNlcywgMiwgdmVydE9mZnNldCwgaW5kaWNlcywgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjbG9zZSA9IHNoYXBlLmNsb3NlUGF0aCA/PyB0cnVlO1xuICAgICAgY29uc3QgbGluZVN0eWxlID0gc3R5bGU7XG4gICAgICBidWlsZExpbmUocG9pbnRzLCBsaW5lU3R5bGUsIGZhbHNlLCBjbG9zZSwgdmVydGljZXMsIDIsIHZlcnRPZmZzZXQsIGluZGljZXMsIGluZGV4T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgdXZzT2Zmc2V0ID0gdXZzLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgdGV4dHVyZSA9IHN0eWxlLnRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUgIT09IFRleHR1cmUuV0hJVEUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVNYXRyaXggPSBzdHlsZS5tYXRyaXg7XG4gICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgIHRleHR1cmVNYXRyaXguYXBwZW5kKG1hdHJpeC5jbG9uZSgpLmludmVydCgpKTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkVXZzKHZlcnRpY2VzLCAyLCB2ZXJ0T2Zmc2V0LCB1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQsIHRleHR1cmVNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWlsZFNpbXBsZVV2cyh1dnMsIHV2c09mZnNldCwgMiwgdmVydGljZXMubGVuZ3RoIC8gMiAtIHZlcnRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBncmFwaGljc0JhdGNoID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlR3JhcGhpY3MpO1xuICAgIGdyYXBoaWNzQmF0Y2guaW5kZXhPZmZzZXQgPSBpbmRleE9mZnNldDtcbiAgICBncmFwaGljc0JhdGNoLmluZGV4U2l6ZSA9IGluZGljZXMubGVuZ3RoIC0gaW5kZXhPZmZzZXQ7XG4gICAgZ3JhcGhpY3NCYXRjaC52ZXJ0ZXhPZmZzZXQgPSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2gudmVydGV4U2l6ZSA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSB2ZXJ0T2Zmc2V0O1xuICAgIGdyYXBoaWNzQmF0Y2guY29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICBncmFwaGljc0JhdGNoLmFscGhhID0gc3R5bGUuYWxwaGE7XG4gICAgZ3JhcGhpY3NCYXRjaC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBncmFwaGljc0JhdGNoLmdlb21ldHJ5RGF0YSA9IGdlb21ldHJ5RGF0YTtcbiAgICBiYXRjaGVzLnB1c2goZ3JhcGhpY3NCYXRjaCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SG9sZUFycmF5cyhzaGFwZSkge1xuICBpZiAoIXNoYXBlKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgaG9sZVByaW1pdGl2ZXMgPSBzaGFwZS5zaGFwZVByaW1pdGl2ZXM7XG4gIGNvbnN0IGhvbGVBcnJheXMgPSBbXTtcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBob2xlUHJpbWl0aXZlcy5sZW5ndGg7IGsrKykge1xuICAgIGNvbnN0IGhvbGVQcmltaXRpdmUgPSBob2xlUHJpbWl0aXZlc1trXS5zaGFwZTtcbiAgICBjb25zdCBob2xlUG9pbnRzID0gW107XG4gICAgY29uc3QgaG9sZUJ1aWxkZXIgPSBidWlsZE1hcFtob2xlUHJpbWl0aXZlLnR5cGVdO1xuICAgIGhvbGVCdWlsZGVyLmJ1aWxkKGhvbGVQcmltaXRpdmUsIGhvbGVQb2ludHMpO1xuICAgIGhvbGVBcnJheXMucHVzaChob2xlUG9pbnRzKTtcbiAgfVxuICByZXR1cm4gaG9sZUFycmF5cztcbn1cblxuZXhwb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDb250ZXh0QmF0Y2hlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2JhdGNoZXIvZ3B1L0JhdGNoR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dwdS9nZXRUZXh0dXJlQmF0Y2hCaW5kR3JvdXAubWpzJztcbmltcG9ydCB7IEJhdGNoZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvYmF0Y2hlci9zaGFyZWQvQmF0Y2hlci5tanMnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25TZXQgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9pbnN0cnVjdGlvbnMvSW5zdHJ1Y3Rpb25TZXQubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgYnVpbGRDb250ZXh0QmF0Y2hlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGRDb250ZXh0QmF0Y2hlcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdwdUdyYXBoaWNzQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuZ2VvbWV0cnlEYXRhID0ge1xuICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgdXZzOiBbXSxcbiAgICAgIGluZGljZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgQmF0Y2hHZW9tZXRyeSgpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gbmV3IEluc3RydWN0aW9uU2V0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5yZXNldCgpO1xuICB9XG59XG5jb25zdCBfR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gY2xhc3MgX0dyYXBoaWNzQ29udGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIHRoZSByb290IGNvbnRleHQgYmF0Y2hlcywgdXNlZCB0byBlaXRoZXIgbWFrZSBhIGJhdGNoIG9yIGdlb21ldHJ5XG4gICAgLy8gYWxsIGdyYXBoaWNzIHVzZSB0aGlzIGFzIGEgYmFzZVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzID0gW107XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2ggPSB7fTtcbiAgICAvLyB1c2VkIGZvciBub24tYmF0Y2hhYmxlIGdyYXBoaWNzXG4gICAgdGhpcy5fZ3JhcGhpY3NEYXRhQ29udGV4dEhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUnVubmVyIGluaXQgY2FsbGVkLCB1cGRhdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgKiBAaWdub3JlXG4gICAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICBfR3JhcGhpY3NDb250ZXh0U3lzdGVtLmRlZmF1bHRPcHRpb25zLmJlemllclNtb290aG5lc3MgPSBvcHRpb25zPy5iZXppZXJTbW9vdGhuZXNzID8/IF9HcmFwaGljc0NvbnRleHRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMuYmV6aWVyU21vb3RobmVzcztcbiAgfVxuICBwcmVyZW5kZXIoKSB7XG4gICAgdGhpcy5fcmV0dXJuQWN0aXZlQmF0Y2hlcnMoKTtcbiAgfVxuICBnZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dFJlbmRlckRhdGEoY29udGV4dCk7XG4gIH1cbiAgLy8gQ29udGV4dCBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuICB1cGRhdGVHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICBsZXQgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSB8fCB0aGlzLl9pbml0Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5kaXJ0eSkge1xuICAgICAgaWYgKGdwdUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5HcmFwaGljc0NvbnRleHREYXRhKGNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3B1Q29udGV4dCA9IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgYnVpbGRDb250ZXh0QmF0Y2hlcyhjb250ZXh0LCBncHVDb250ZXh0KTtcbiAgICAgIGNvbnN0IGJhdGNoTW9kZSA9IGNvbnRleHQuYmF0Y2hNb2RlO1xuICAgICAgaWYgKGNvbnRleHQuY3VzdG9tU2hhZGVyIHx8IGJhdGNoTW9kZSA9PT0gXCJuby1iYXRjaFwiKSB7XG4gICAgICAgIGdwdUNvbnRleHQuaXNCYXRjaGFibGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hNb2RlID09PSBcImF1dG9cIikge1xuICAgICAgICBncHVDb250ZXh0LmlzQmF0Y2hhYmxlID0gZ3B1Q29udGV4dC5nZW9tZXRyeURhdGEudmVydGljZXMubGVuZ3RoIDwgNDAwO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZ3B1Q29udGV4dDtcbiAgfVxuICBnZXRHcHVDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdIHx8IHRoaXMuX2luaXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG4gIF9yZXR1cm5BY3RpdmVCYXRjaGVycygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBCaWdQb29sLnJldHVybih0aGlzLl9hY3RpdmVCYXRjaGVyc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUJhdGNoZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX2luaXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gQmlnUG9vbC5nZXQoR3JhcGhpY3NDb250ZXh0UmVuZGVyRGF0YSk7XG4gICAgY29uc3QgeyBiYXRjaGVzLCBnZW9tZXRyeURhdGEgfSA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBjb25zdCB2ZXJ0ZXhTaXplID0gZ2VvbWV0cnlEYXRhLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBpbmRleFNpemUgPSBnZW9tZXRyeURhdGEuaW5kaWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXRjaGVzW2ldLmFwcGx5VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXIgPSBCaWdQb29sLmdldChCYXRjaGVyKTtcbiAgICB0aGlzLl9hY3RpdmVCYXRjaGVycy5wdXNoKGJhdGNoZXIpO1xuICAgIGJhdGNoZXIuZW5zdXJlQXR0cmlidXRlQnVmZmVyKHZlcnRleFNpemUpO1xuICAgIGJhdGNoZXIuZW5zdXJlSW5kZXhCdWZmZXIoaW5kZXhTaXplKTtcbiAgICBiYXRjaGVyLmJlZ2luKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICBiYXRjaGVyLmFkZChiYXRjaCk7XG4gICAgfVxuICAgIGJhdGNoZXIuZmluaXNoKGdyYXBoaWNzRGF0YS5pbnN0cnVjdGlvbnMpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZ3JhcGhpY3NEYXRhLmdlb21ldHJ5O1xuICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLnNldERhdGFXaXRoU2l6ZShiYXRjaGVyLmluZGV4QnVmZmVyLCBiYXRjaGVyLmluZGV4U2l6ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYnVmZmVyc1swXS5zZXREYXRhV2l0aFNpemUoYmF0Y2hlci5hdHRyaWJ1dGVCdWZmZXIuZmxvYXQzMlZpZXcsIGJhdGNoZXIuYXR0cmlidXRlU2l6ZSwgdHJ1ZSk7XG4gICAgY29uc3QgZHJhd0JhdGNoZXMgPSBiYXRjaGVyLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3QmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBkcmF3QmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoLmJpbmRHcm91cCA9IGdldFRleHR1cmVCYXRjaEJpbmRHcm91cChiYXRjaC50ZXh0dXJlcy50ZXh0dXJlcywgYmF0Y2gudGV4dHVyZXMuY291bnQpO1xuICAgIH1cbiAgICB0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0gPSBncmFwaGljc0RhdGE7XG4gICAgcmV0dXJuIGdyYXBoaWNzRGF0YTtcbiAgfVxuICBfaW5pdENvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSBuZXcgR3B1R3JhcGhpY3NDb250ZXh0KCk7XG4gICAgdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdID0gZ3B1Q29udGV4dDtcbiAgICBjb250ZXh0Lm9uKFwidXBkYXRlXCIsIHRoaXMub25HcmFwaGljc0NvbnRleHRVcGRhdGUsIHRoaXMpO1xuICAgIGNvbnRleHQub24oXCJkZXN0cm95XCIsIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdO1xuICB9XG4gIG9uR3JhcGhpY3NDb250ZXh0VXBkYXRlKGNvbnRleHQpIHtcbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQucHVzaChjb250ZXh0KTtcbiAgfVxuICBvbkdyYXBoaWNzQ29udGV4dERlc3Ryb3koY29udGV4dCkge1xuICAgIHRoaXMuX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KTtcbiAgICBjb250ZXh0Lm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uR3JhcGhpY3NDb250ZXh0VXBkYXRlLCB0aGlzKTtcbiAgICBjb250ZXh0Lm9mZihcImRlc3Ryb3lcIiwgdGhpcy5vbkdyYXBoaWNzQ29udGV4dERlc3Ryb3ksIHRoaXMpO1xuICAgIHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gIH1cbiAgX2NsZWFuR3JhcGhpY3NDb250ZXh0RGF0YShjb250ZXh0KSB7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMuX2dwdUNvbnRleHRIYXNoW2NvbnRleHQudWlkXTtcbiAgICBpZiAoIWdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLl9ncmFwaGljc0RhdGFDb250ZXh0SGFzaFtjb250ZXh0LnVpZF0pIHtcbiAgICAgICAgQmlnUG9vbC5yZXR1cm4odGhpcy5nZXRDb250ZXh0UmVuZGVyRGF0YShjb250ZXh0KSk7XG4gICAgICAgIHRoaXMuX2dyYXBoaWNzRGF0YUNvbnRleHRIYXNoW2NvbnRleHQudWlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmJhdGNoZXMpIHtcbiAgICAgIGdwdUNvbnRleHQuYmF0Y2hlcy5mb3JFYWNoKChiYXRjaCkgPT4ge1xuICAgICAgICBCaWdQb29sLnJldHVybihiYXRjaCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgdGhpcy5fbmVlZHNDb250ZXh0TmVlZHNSZWJ1aWxkKSB7XG4gICAgICBpZiAodGhpcy5fZ3B1Q29udGV4dEhhc2hbY29udGV4dC51aWRdKSB7XG4gICAgICAgIHRoaXMub25HcmFwaGljc0NvbnRleHREZXN0cm95KGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc0NvbnRleHROZWVkc1JlYnVpbGQubGVuZ3RoID0gMDtcbiAgfVxufTtcbi8qKiBAaWdub3JlICovXG5fR3JhcGhpY3NDb250ZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJncmFwaGljc0NvbnRleHRcIlxufTtcbi8qKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgR3JhcGhpY3NDb250ZXh0U3lzdGVtLiAqL1xuX0dyYXBoaWNzQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEEgdmFsdWUgZnJvbSAwIHRvIDEgdGhhdCBjb250cm9scyB0aGUgc21vb3RobmVzcyBvZiBiZXppZXIgY3VydmVzICh0aGUgaGlnaGVyIHRoZSBzbW9vdGhlcilcbiAgICogQGRlZmF1bHQgMC41XG4gICAqL1xuICBiZXppZXJTbW9vdGhuZXNzOiAwLjVcbn07XG5sZXQgR3JhcGhpY3NDb250ZXh0U3lzdGVtID0gX0dyYXBoaWNzQ29udGV4dFN5c3RlbTtcblxuZXhwb3J0IHsgR3B1R3JhcGhpY3NDb250ZXh0LCBHcmFwaGljc0NvbnRleHRSZW5kZXJEYXRhLCBHcmFwaGljc0NvbnRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzQ29udGV4dFN5c3RlbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4108\n')},557:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ FillGradient)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8409);\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3646);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9160);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n\n\n\n\n"use strict";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillGradient");\n    this.type = "linear";\n    this.gradientStops = [];\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .I.shared.setValue(color).toHex() });\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__/* .DOMAdapter */ .z.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext("2d");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__/* .Texture */ .x({\n      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__/* .ImageSource */ .c({\n        resource: canvas,\n        addressModeU: "clamp-to-edge",\n        addressModeV: "repeat"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__/* .Matrix */ .y();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\n\n//# sourceMappingURL=FillGradient.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRDtBQUNhO0FBQ0o7QUFDd0M7QUFDaEI7QUFDaEM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlLDREQUFLLGlDQUFpQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsbUJBQW1CLHlFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZGQUFPO0FBQzlCLGtCQUFrQiw2R0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLFlBQVksaUJBQWlCO0FBQzdCLGtCQUFrQixxRUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsR3JhZGllbnQubWpzPzc1MmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IEltYWdlU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9zb3VyY2VzL0ltYWdlU291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kYXRhL3VpZC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9GaWxsR3JhZGllbnQgPSBjbGFzcyBfRmlsbEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3IoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImZpbGxHcmFkaWVudFwiKTtcbiAgICB0aGlzLnR5cGUgPSBcImxpbmVhclwiO1xuICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IFtdO1xuICAgIHRoaXMueDAgPSB4MDtcbiAgICB0aGlzLnkwID0geTA7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgfVxuICBhZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcikge1xuICAgIHRoaXMuZ3JhZGllbnRTdG9wcy5wdXNoKHsgb2Zmc2V0LCBjb2xvcjogQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0hleCgpIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8vIFRPRE8gbW92ZSB0byB0aGUgc3lzdGVtIVxuICBidWlsZExpbmVhckdyYWRpZW50KCkge1xuICAgIGNvbnN0IGRlZmF1bHRTaXplID0gX0ZpbGxHcmFkaWVudC5kZWZhdWx0VGV4dHVyZVNpemU7XG4gICAgY29uc3QgeyBncmFkaWVudFN0b3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNhbnZhcyA9IERPTUFkYXB0ZXIuZ2V0KCkuY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gZGVmYXVsdFNpemU7XG4gICAgY2FudmFzLmhlaWdodCA9IGRlZmF1bHRTaXplO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgX0ZpbGxHcmFkaWVudC5kZWZhdWx0VGV4dHVyZVNpemUsIDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhZGllbnRTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RvcCA9IGdyYWRpZW50U3RvcHNbaV07XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHN0b3AuY29sb3IpO1xuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGRlZmF1bHRTaXplLCBkZWZhdWx0U2l6ZSk7XG4gICAgdGhpcy50ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgc291cmNlOiBuZXcgSW1hZ2VTb3VyY2Uoe1xuICAgICAgICByZXNvdXJjZTogY2FudmFzLFxuICAgICAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgICAgICBhZGRyZXNzTW9kZVY6IFwicmVwZWF0XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgeyB4MCwgeTAsIHgxLCB5MSB9ID0gdGhpcztcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeCgpO1xuICAgIGNvbnN0IGR4ID0geDEgLSB4MDtcbiAgICBjb25zdCBkeSA9IHkxIC0geTA7XG4gICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgbS50cmFuc2xhdGUoLXgwLCAteTApO1xuICAgIG0uc2NhbGUoMSAvIGRlZmF1bHRTaXplLCAxIC8gZGVmYXVsdFNpemUpO1xuICAgIG0ucm90YXRlKC1hbmdsZSk7XG4gICAgbS5zY2FsZSgyNTYgLyBkaXN0LCAxKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIH1cbn07XG5fRmlsbEdyYWRpZW50LmRlZmF1bHRUZXh0dXJlU2l6ZSA9IDI1NjtcbmxldCBGaWxsR3JhZGllbnQgPSBfRmlsbEdyYWRpZW50O1xuXG5leHBvcnQgeyBGaWxsR3JhZGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxHcmFkaWVudC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///557\n')},1261:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ FillPattern)\n/* harmony export */ });\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5321);\n/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6258);\n\n\n\n"use strict";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: "repeat",\n    addressModeV: "repeat"\n  },\n  "repeat-x": {\n    addressModeU: "repeat",\n    addressModeV: "clamp-to-edge"\n  },\n  "repeat-y": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "repeat"\n  },\n  "no-repeat": {\n    addressModeU: "clamp-to-edge",\n    addressModeV: "clamp-to-edge"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .h)("fillPattern");\n    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Matrix */ .y();\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n  }\n}\n\n\n//# sourceMappingURL=FillPattern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDtBQUNSOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFHO0FBQ2xCLHlCQUF5QixxRUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxQYXR0ZXJuLm1qcz8zNzAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IHVpZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RhdGEvdWlkLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgcmVwZXRpdGlvbk1hcCA9IHtcbiAgcmVwZWF0OiB7XG4gICAgYWRkcmVzc01vZGVVOiBcInJlcGVhdFwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJyZXBlYXRcIlxuICB9LFxuICBcInJlcGVhdC14XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwicmVwZWF0XCIsXG4gICAgYWRkcmVzc01vZGVWOiBcImNsYW1wLXRvLWVkZ2VcIlxuICB9LFxuICBcInJlcGVhdC15XCI6IHtcbiAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxuICAgIGFkZHJlc3NNb2RlVjogXCJyZXBlYXRcIlxuICB9LFxuICBcIm5vLXJlcGVhdFwiOiB7XG4gICAgYWRkcmVzc01vZGVVOiBcImNsYW1wLXRvLWVkZ2VcIixcbiAgICBhZGRyZXNzTW9kZVY6IFwiY2xhbXAtdG8tZWRnZVwiXG4gIH1cbn07XG5jbGFzcyBGaWxsUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIHJlcGV0aXRpb24pIHtcbiAgICB0aGlzLnVpZCA9IHVpZChcImZpbGxQYXR0ZXJuXCIpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUoXG4gICAgICAxIC8gdGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gICAgaWYgKHJlcGV0aXRpb24pIHtcbiAgICAgIHRleHR1cmUuc291cmNlLnN0eWxlLmFkZHJlc3NNb2RlVSA9IHJlcGV0aXRpb25NYXBbcmVwZXRpdGlvbl0uYWRkcmVzc01vZGVVO1xuICAgICAgdGV4dHVyZS5zb3VyY2Uuc3R5bGUuYWRkcmVzc01vZGVWID0gcmVwZXRpdGlvbk1hcFtyZXBldGl0aW9uXS5hZGRyZXNzTW9kZVY7XG4gICAgfVxuICB9XG4gIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIHRoaXMudHJhbnNmb3JtLmNvcHlGcm9tKHRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUoXG4gICAgICAxIC8gdGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIDEgLyB0ZXh0dXJlLmZyYW1lLmhlaWdodFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRmlsbFBhdHRlcm4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxQYXR0ZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1261\n')},4915:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ convertFillInputToFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8409);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5321);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(557);\n/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1261);\n\n\n\n\n\n\n"use strict";\nfunction convertFillInputToFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  let fillStyleToParse;\n  let styleToMerge;\n  if (value?.fill) {\n    styleToMerge = value.fill;\n    fillStyleToParse = { ...defaultStyle, ...value };\n  } else {\n    styleToMerge = value;\n    fillStyleToParse = defaultStyle;\n  }\n  if (_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.isColorLike(styleToMerge)) {\n    const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(styleToMerge ?? 0);\n    const opts = {\n      ...fillStyleToParse,\n      color: temp.toNumber(),\n      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,\n      texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE\n    };\n    return opts;\n  } else if (styleToMerge instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_2__/* .FillPattern */ .h) {\n    const pattern = styleToMerge;\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: pattern.texture,\n      matrix: pattern.transform,\n      fill: fillStyleToParse.fill ?? null\n    };\n  } else if (styleToMerge instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillGradient */ .f) {\n    const gradient = styleToMerge;\n    gradient.buildLinearGradient();\n    return {\n      ...fillStyleToParse,\n      color: 16777215,\n      texture: gradient.texture,\n      matrix: gradient.transform\n    };\n  }\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.WHITE) {\n      const m = style.matrix?.invert() || new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_4__/* .Matrix */ .y();\n      m.scale(\n        1 / style.texture.frame.width,\n        1 / style.texture.frame.height\n      );\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === "clamp-to-edge") {\n      sourceStyle.addressMode = "repeat";\n    }\n  }\n  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .I.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\n\n\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNTO0FBQ3dCO0FBQzdCO0FBQ0Y7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBSztBQUNYLGlCQUFpQiw0REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkZBQU87QUFDdEI7QUFDQTtBQUNBLElBQUksaUNBQWlDLHVFQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyx5RUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwwQkFBMEIsNkZBQU87QUFDakMsOENBQThDLHFFQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9ncmFwaGljcy9zaGFyZWQvdXRpbHMvY29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcz9iNWQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uL2ZpbGwvRmlsbEdyYWRpZW50Lm1qcyc7XG5pbXBvcnQgeyBGaWxsUGF0dGVybiB9IGZyb20gJy4uL2ZpbGwvRmlsbFBhdHRlcm4ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjb252ZXJ0RmlsbElucHV0VG9GaWxsU3R5bGUodmFsdWUsIGRlZmF1bHRTdHlsZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBmaWxsU3R5bGVUb1BhcnNlO1xuICBsZXQgc3R5bGVUb01lcmdlO1xuICBpZiAodmFsdWU/LmZpbGwpIHtcbiAgICBzdHlsZVRvTWVyZ2UgPSB2YWx1ZS5maWxsO1xuICAgIGZpbGxTdHlsZVRvUGFyc2UgPSB7IC4uLmRlZmF1bHRTdHlsZSwgLi4udmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZVRvTWVyZ2UgPSB2YWx1ZTtcbiAgICBmaWxsU3R5bGVUb1BhcnNlID0gZGVmYXVsdFN0eWxlO1xuICB9XG4gIGlmIChDb2xvci5pc0NvbG9yTGlrZShzdHlsZVRvTWVyZ2UpKSB7XG4gICAgY29uc3QgdGVtcCA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHlsZVRvTWVyZ2UgPz8gMCk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIC4uLmZpbGxTdHlsZVRvUGFyc2UsXG4gICAgICBjb2xvcjogdGVtcC50b051bWJlcigpLFxuICAgICAgYWxwaGE6IHRlbXAuYWxwaGEgPT09IDEgPyBmaWxsU3R5bGVUb1BhcnNlLmFscGhhIDogdGVtcC5hbHBoYSxcbiAgICAgIHRleHR1cmU6IFRleHR1cmUuV0hJVEVcbiAgICB9O1xuICAgIHJldHVybiBvcHRzO1xuICB9IGVsc2UgaWYgKHN0eWxlVG9NZXJnZSBpbnN0YW5jZW9mIEZpbGxQYXR0ZXJuKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHN0eWxlVG9NZXJnZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlsbFN0eWxlVG9QYXJzZSxcbiAgICAgIGNvbG9yOiAxNjc3NzIxNSxcbiAgICAgIHRleHR1cmU6IHBhdHRlcm4udGV4dHVyZSxcbiAgICAgIG1hdHJpeDogcGF0dGVybi50cmFuc2Zvcm0sXG4gICAgICBmaWxsOiBmaWxsU3R5bGVUb1BhcnNlLmZpbGwgPz8gbnVsbFxuICAgIH07XG4gIH0gZWxzZSBpZiAoc3R5bGVUb01lcmdlIGluc3RhbmNlb2YgRmlsbEdyYWRpZW50KSB7XG4gICAgY29uc3QgZ3JhZGllbnQgPSBzdHlsZVRvTWVyZ2U7XG4gICAgZ3JhZGllbnQuYnVpbGRMaW5lYXJHcmFkaWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5maWxsU3R5bGVUb1BhcnNlLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgdGV4dHVyZTogZ3JhZGllbnQudGV4dHVyZSxcbiAgICAgIG1hdHJpeDogZ3JhZGllbnQudHJhbnNmb3JtXG4gICAgfTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHsgLi4uZGVmYXVsdFN0eWxlLCAuLi52YWx1ZSB9O1xuICBpZiAoc3R5bGUudGV4dHVyZSkge1xuICAgIGlmIChzdHlsZS50ZXh0dXJlICE9PSBUZXh0dXJlLldISVRFKSB7XG4gICAgICBjb25zdCBtID0gc3R5bGUubWF0cml4Py5pbnZlcnQoKSB8fCBuZXcgTWF0cml4KCk7XG4gICAgICBtLnNjYWxlKFxuICAgICAgICAxIC8gc3R5bGUudGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgICAgMSAvIHN0eWxlLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgICApO1xuICAgICAgc3R5bGUubWF0cml4ID0gbTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlU3R5bGUgPSBzdHlsZS50ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICBpZiAoc291cmNlU3R5bGUuYWRkcmVzc01vZGUgPT09IFwiY2xhbXAtdG8tZWRnZVwiKSB7XG4gICAgICBzb3VyY2VTdHlsZS5hZGRyZXNzTW9kZSA9IFwicmVwZWF0XCI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0eWxlLmNvbG9yKTtcbiAgc3R5bGUuYWxwaGEgKj0gY29sb3IuYWxwaGE7XG4gIHN0eWxlLmNvbG9yID0gY29sb3IudG9OdW1iZXIoKTtcbiAgc3R5bGUubWF0cml4ID0gc3R5bGUubWF0cml4ID8gc3R5bGUubWF0cml4LmNsb25lKCkgOiBudWxsO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRGaWxsSW5wdXRUb0ZpbGxTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVydEZpbGxJbnB1dFRvRmlsbFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4915\n')},5263:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   j: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4973);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9853);\n/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3747);\n/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8400);\n\n\n\n\n\n"use strict";\nclass Sprite extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Container */ .W2 {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY) {\n    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      options = { texture: options };\n    }\n    const { texture, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: "Sprite",\n      ...rest\n    });\n    this.renderPipeId = "sprite";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._boundsDirty = true;\n    this._sourceBoundsDirty = true;\n    this._roundPixels = 0;\n    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__/* .ObservablePoint */ .A(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width)\n      this.width = width;\n    if (height)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x) {\n      return new Sprite(source);\n    }\n    return new Sprite(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Texture */ .x.EMPTY);\n    if (this._texture === value)\n      return;\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture\'s trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    if (this.renderGroup) {\n      this.renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__/* .updateQuadBounds */ .w)(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite\'s origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite\'s origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite\'s origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from \'pixi.js\';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /**\n   *  Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    let convertedWidth;\n    let convertedHeight;\n    if (typeof value !== "object") {\n      convertedWidth = value;\n      convertedHeight = height ?? value;\n    } else {\n      convertedWidth = value.width;\n      convertedHeight = value.height ?? value.width;\n    }\n    if (convertedWidth !== void 0) {\n      this._setWidth(convertedWidth, this._texture.orig.width);\n    }\n    if (convertedHeight !== void 0) {\n      this._setHeight(convertedHeight, this._texture.orig.height);\n    }\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBQ087QUFDTjtBQUNsQjs7QUFFdkQ7QUFDQSxxQkFBcUIseUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZGQUFPO0FBQy9CLDJCQUEyQiw2RkFBTztBQUNsQyxrQkFBa0I7QUFDbEI7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0ZBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZGQUFPO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsNkZBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQiw2RkFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJGQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS9TcHJpdGUubWpzPzNhOGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH0gZnJvbSAnLi4vLi4vbWF0aHMvcG9pbnQvT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YS91cGRhdGVRdWFkQm91bmRzLm1qcyc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi9jb250YWluZXIvQ29udGFpbmVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBzcHJpdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0gVGV4dHVyZS5FTVBUWSkge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3B0aW9ucyA9IHsgdGV4dHVyZTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBjb25zdCB7IHRleHR1cmUsIGFuY2hvciwgcm91bmRQaXhlbHMsIHdpZHRoLCBoZWlnaHQsIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgc3VwZXIoe1xuICAgICAgbGFiZWw6IFwiU3ByaXRlXCIsXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJQaXBlSWQgPSBcInNwcml0ZVwiO1xuICAgIHRoaXMuYmF0Y2hlZCA9IHRydWU7XG4gICAgdGhpcy5fZGlkU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgdGhpcy5fc291cmNlQm91bmRzID0geyBtaW5YOiAwLCBtYXhYOiAxLCBtaW5ZOiAwLCBtYXhZOiAwIH07XG4gICAgdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kc0RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IDA7XG4gICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludChcbiAgICAgIHtcbiAgICAgICAgX29uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vblZpZXdVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGFuY2hvcilcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5hbGxvd0NoaWxkcmVuID0gZmFsc2U7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IHJvdW5kUGl4ZWxzID8/IGZhbHNlO1xuICAgIGlmICh3aWR0aClcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICBpZiAoaGVpZ2h0KVxuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgc3ByaXRlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlLCB2aWRlbywgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIHRleHR1cmVcbiAgICogQHBhcmFtIHNvdXJjZSAtIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAqIEBwYXJhbSBbc2tpcENhY2hlXSAtIFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgb3Igbm90XG4gICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIHNwcml0ZVxuICAgKi9cbiAgc3RhdGljIGZyb20oc291cmNlLCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFNwcml0ZShzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNwcml0ZShUZXh0dXJlLmZyb20oc291cmNlLCBza2lwQ2FjaGUpKTtcbiAgfVxuICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgIHZhbHVlIHx8ICh2YWx1ZSA9IFRleHR1cmUuRU1QVFkpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgdGhpcy5vblZpZXdVcGRhdGUoKTtcbiAgfVxuICAvKiogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nLiAqL1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlLlxuICAgKiBAdHlwZSB7cmVuZGVyaW5nLkJvdW5kc31cbiAgICovXG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kc0RpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMuX2JvdW5kc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZSwgdGFraW5nIHRoZSB0ZXh0dXJlJ3MgdHJpbSBpbnRvIGFjY291bnQuXG4gICAqIEB0eXBlIHtyZW5kZXJpbmcuQm91bmRzfVxuICAgKi9cbiAgZ2V0IHNvdXJjZUJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5fc291cmNlQm91bmRzRGlydHkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZUJvdW5kcygpO1xuICAgICAgdGhpcy5fc291cmNlQm91bmRzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUJvdW5kcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLnNvdXJjZUJvdW5kcztcbiAgICBpZiAocG9pbnQueCA+PSBib3VuZHMubWF4WCAmJiBwb2ludC54IDw9IGJvdW5kcy5taW5YKSB7XG4gICAgICBpZiAocG9pbnQueSA+PSBib3VuZHMubWF4WSAmJiBwb2ludC55IDw9IGJvdW5kcy5taW5ZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGJvdW5kcyBvZiB0aGlzIG9iamVjdCB0byB0aGUgYm91bmRzIG9iamVjdC5cbiAgICogQHBhcmFtIGJvdW5kcyAtIFRoZSBvdXRwdXQgYm91bmRzIG9iamVjdC5cbiAgICovXG4gIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICBjb25zdCBfYm91bmRzID0gdGhpcy5fdGV4dHVyZS50cmltID8gdGhpcy5zb3VyY2VCb3VuZHMgOiB0aGlzLmJvdW5kcztcbiAgICBib3VuZHMuYWRkRnJhbWUoX2JvdW5kcy5taW5YLCBfYm91bmRzLm1pblksIF9ib3VuZHMubWF4WCwgX2JvdW5kcy5tYXhZKTtcbiAgfVxuICBvblZpZXdVcGRhdGUoKSB7XG4gICAgdGhpcy5fZGlkQ2hhbmdlSWQgKz0gMSA8PCAxMjtcbiAgICB0aGlzLl9kaWRTcHJpdGVVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kc0RpcnR5ID0gdGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kaWRWaWV3VXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yZW5kZXJHcm91cCkge1xuICAgICAgdGhpcy5yZW5kZXJHcm91cC5vbkNoaWxkVmlld1VwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgICB1cGRhdGVRdWFkQm91bmRzKHRoaXMuX2JvdW5kcywgdGhpcy5fYW5jaG9yLCB0aGlzLl90ZXh0dXJlLCAwKTtcbiAgfVxuICBfdXBkYXRlU291cmNlQm91bmRzKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBjb25zdCBzb3VyY2VCb3VuZHMgPSB0aGlzLl9zb3VyY2VCb3VuZHM7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0ZXh0dXJlLm9yaWc7XG4gICAgc291cmNlQm91bmRzLm1heFggPSAtYW5jaG9yLl94ICogd2lkdGg7XG4gICAgc291cmNlQm91bmRzLm1pblggPSBzb3VyY2VCb3VuZHMubWF4WCArIHdpZHRoO1xuICAgIHNvdXJjZUJvdW5kcy5tYXhZID0gLWFuY2hvci5feSAqIGhlaWdodDtcbiAgICBzb3VyY2VCb3VuZHMubWluWSA9IHNvdXJjZUJvdW5kcy5tYXhZICsgaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSByZW5kZXJhYmxlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgcmVuZGVyYWJsZSBhcyB3ZWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZVNvdXJjZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZVNvdXJjZSBvZiB0aGUgcmVuZGVyYWJsZSBhcyB3ZWxsXG4gICAqL1xuICBkZXN0cm95KG9wdGlvbnMgPSBmYWxzZSkge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgY29uc3QgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGRlc3Ryb3lUZXh0dXJlU291cmNlID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucyA6IG9wdGlvbnM/LnRleHR1cmVTb3VyY2U7XG4gICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koZGVzdHJveVRleHR1cmVTb3VyY2UpO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgIHRoaXMuX3NvdXJjZUJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHNwcml0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFRleHR1cmV9XG4gICAqIGFuZCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpcyBgKDAsMClgLCB0aGlzIG1lYW5zIHRoZSBzcHJpdGUncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxuICAgKlxuICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgwLjUsMC41KWAgbWVhbnMgdGhlIHNwcml0ZSdzIG9yaWdpbiBpcyBjZW50ZXJlZC5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMSwxKWAgd291bGQgbWVhbiB0aGUgc3ByaXRlJ3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIG9ubHkgc2luZ2xlIHBhcmFtZXRlciwgaXQgd2lsbCBzZXQgYm90aCB4IGFuZCB5IHRvIHRoZSBzYW1lIHZhbHVlIGFzIHNob3duIGluIHRoZSBleGFtcGxlIGJlbG93LlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdwaXhpLmpzJztcbiAgICpcbiAgICogY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZSh7dGV4dHVyZTogVGV4dHVyZS5XSElURX0pO1xuICAgKiBzcHJpdGUuYW5jaG9yLnNldCgwLjUpOyAvLyBUaGlzIHdpbGwgc2V0IHRoZSBvcmlnaW4gdG8gY2VudGVyLiAoMC41KSBpcyBzYW1lIGFzICgwLjUsIDAuNSkuXG4gICAqL1xuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gIH1cbiAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHRoaXMuX2FuY2hvci5zZXQodmFsdWUpIDogdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogIFdoZXRoZXIgb3Igbm90IHRvIHJvdW5kIHRoZSB4L3kgcG9zaXRpb24gb2YgdGhlIHNwcml0ZS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZSA/IDEgOiAwO1xuICB9XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXQuICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRXaWR0aCh2YWx1ZSwgdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoKTtcbiAgfVxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldC4gKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3NldEhlaWdodCh2YWx1ZSwgdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiB0aGUgU3ByaXRlIGFzIGEgW1NpemVde0BsaW5rIFNpemV9IG9iamVjdC5cbiAgICogVGhpcyBpcyBmYXN0ZXIgdGhhbiBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgc2VwYXJhdGVseS5cbiAgICogQHBhcmFtIG91dCAtIE9wdGlvbmFsIG9iamVjdCB0byBzdG9yZSB0aGUgc2l6ZSBpbi5cbiAgICogQHJldHVybnMgLSBUaGUgc2l6ZSBvZiB0aGUgU3ByaXRlLlxuICAgKi9cbiAgZ2V0U2l6ZShvdXQpIHtcbiAgICBpZiAoIW91dCkge1xuICAgICAgb3V0ID0ge307XG4gICAgfVxuICAgIG91dC53aWR0aCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgb3V0LmhlaWdodCA9IE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIFNwcml0ZSB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2V0dGluZyB0aGUgd2lkdGggYW5kIGhlaWdodCBzZXBhcmF0ZWx5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGlzIGNhbiBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYSBbU2l6ZV17QGxpbmsgU2l6ZX0gb2JqZWN0LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgd2lkdGhgIGlmIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHNldFNpemUodmFsdWUsIGhlaWdodCkge1xuICAgIGxldCBjb252ZXJ0ZWRXaWR0aDtcbiAgICBsZXQgY29udmVydGVkSGVpZ2h0O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnZlcnRlZFdpZHRoID0gdmFsdWU7XG4gICAgICBjb252ZXJ0ZWRIZWlnaHQgPSBoZWlnaHQgPz8gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnZlcnRlZFdpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICBjb252ZXJ0ZWRIZWlnaHQgPSB2YWx1ZS5oZWlnaHQgPz8gdmFsdWUud2lkdGg7XG4gICAgfVxuICAgIGlmIChjb252ZXJ0ZWRXaWR0aCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRXaWR0aChjb252ZXJ0ZWRXaWR0aCwgdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnZlcnRlZEhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9zZXRIZWlnaHQoY29udmVydGVkSGVpZ2h0LCB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgU3ByaXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcHJpdGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5263\n')},9026:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(3489);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs\nvar LoaderParser = __webpack_require__(4334);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(4796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/path.mjs\nvar path = __webpack_require__(1718);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/convertToList.mjs\nvar convertToList = __webpack_require__(9879);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs\n\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs\n\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs\n\n\n\n\n\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = (0,convertToList/* convertToList */.S)(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      (0,warn/* warn */.Z)(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        (0,warn/* warn */.Z)(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = (0,convertToList/* convertToList */.S)(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = (0,convertToList/* convertToList */.S)(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = (0,convertToList/* convertToList */.S)(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = (0,convertToList/* convertToList */.S)(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path/* path */.E.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs\nvar copySearchParams = __webpack_require__(8479);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(9853);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(3904);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs\n\n\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture/* Texture */.x ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle/* Rectangle */.A(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle/* Rectangle */.A(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle/* Rectangle */.A(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture/* Texture */.x({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs\n\n\n\n\n\n\n\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path/* path */.E.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: Extensions/* ExtensionType */.nw.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: Extensions/* ExtensionType */.nw.LoadParser,\n      priority: LoaderParser/* LoaderParserPriority */.Q.Normal\n    },\n    async testParse(asset, options) {\n      return path/* path */.E.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path/* path */.E.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture/* Texture */.x) {\n        texture = imageTexture;\n      } else {\n        const imagePath = (0,copySearchParams/* copySearchParams */.u)(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = (0,copySearchParams/* copySearchParams */.u)(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    unload(spritesheet) {\n      spritesheet.destroy(true);\n    }\n  }\n};\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/spritesheet/init.mjs\n\n\n\n\"use strict\";\nExtensions/* extensions */.Rw.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAyNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQzs7O0FDOUJhO0FBQ2I7O0FBRXdCO0FBQ3hCOzs7QUNKb0Q7QUFDUjtBQUNlO0FBQ2tCO0FBQ3BCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVMsRUFBRSx3QkFBd0IsRUFBRSxRQUFRO0FBQ2xHLHNGQUFzRixTQUFTLEVBQUUsd0JBQXdCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJFQUEyRSx3QkFBd0IsR0FBRyxxQ0FBcUM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIseUJBQXlCLHNDQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0NBQWtDO0FBQzFDLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVEsc0NBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQW9EO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixpQkFBaUIsK0JBQStCO0FBQ2hELE1BQU07QUFDTjtBQUNBLG1EQUFtRCwwQkFBMEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFJLGdDQUFnQyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQWE7QUFDcEM7QUFDQSxjQUFjLE1BQU07QUFDcEIsWUFBWSwyQkFBMkI7QUFDdkMsd0JBQXdCLHNDQUFhO0FBQ3JDO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsbUJBQW1CO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRCxzQkFBc0I7QUFDdEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyxnQkFBZ0Isc0NBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsV0FBVyxzQ0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSxlQUFlLEVBQUUsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBLDJCQUEyQixnQkFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDckM7Ozs7Ozs7OztBQzdnQjBEO0FBQ2tCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCLDBCQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVCO0FBQ3ZCOzs7QUNqS2lGO0FBQ3RCO0FBQ2E7QUFDWDtBQUNlO0FBQ25DO0FBQ087O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixnQkFBSTtBQUN6QjtBQUNBLDBDQUEwQyxTQUFTLEdBQUcsdUNBQXVDO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBYTtBQUMxQjtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFhO0FBQ3pCLGdCQUFnQix3Q0FBb0I7QUFDcEMsS0FBSztBQUNMO0FBQ0EsYUFBYSxnQkFBSTtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQixnQkFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBTztBQUN6QztBQUNBLFFBQVE7QUFDUiwwQkFBMEIsNENBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUI7OztBQzlJMEQ7QUFDQTs7QUFFMUQ7QUFDQSw2QkFBVSxLQUFLLGdCQUFnQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcz80NWFkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2Fzc2V0cy91dGlscy9pc1NpbmdsZUl0ZW0ubWpzPzZmMWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvYXNzZXRzL3Jlc29sdmVyL1Jlc29sdmVyLm1qcz84NmY2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3Nwcml0ZXNoZWV0L1Nwcml0ZXNoZWV0Lm1qcz9lNzdmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3Nwcml0ZXNoZWV0L3Nwcml0ZXNoZWV0QXNzZXQubWpzP2M5MWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc3ByaXRlc2hlZXQvaW5pdC5tanM/YWMxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHByb2Nlc3NYKGJhc2UsIGlkcywgZGVwdGgsIHJlc3VsdCwgdGFncykge1xuICBjb25zdCBpZCA9IGlkc1tkZXB0aF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlkW2ldO1xuICAgIGlmIChkZXB0aCA8IGlkcy5sZW5ndGggLSAxKSB7XG4gICAgICBwcm9jZXNzWChiYXNlLnJlcGxhY2UocmVzdWx0W2RlcHRoXSwgdmFsdWUpLCBpZHMsIGRlcHRoICsgMSwgcmVzdWx0LCB0YWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncy5wdXNoKGJhc2UucmVwbGFjZShyZXN1bHRbZGVwdGhdLCB2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyhzdHJpbmcpIHtcbiAgY29uc3QgcmVnZXggPSAvXFx7KC4qPylcXH0vZztcbiAgY29uc3QgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKHJlZ2V4KTtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBpZiAocmVzdWx0KSB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgcmVzdWx0LmZvckVhY2goKHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IHNwbGl0ID0gdmFycy5zdWJzdHJpbmcoMSwgdmFycy5sZW5ndGggLSAxKS5zcGxpdChcIixcIik7XG4gICAgICBpZHMucHVzaChzcGxpdCk7XG4gICAgfSk7XG4gICAgcHJvY2Vzc1goc3RyaW5nLCBpZHMsIDAsIHJlc3VsdCwgdGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGFncy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc1NpbmdsZUl0ZW0gPSAoaXRlbSkgPT4gIUFycmF5LmlzQXJyYXkoaXRlbSk7XG5cbmV4cG9ydCB7IGlzU2luZ2xlSXRlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTaW5nbGVJdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICcuLi8uLi91dGlscy9wYXRoLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyB9IGZyb20gJy4uL3V0aWxzL2NyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMubWpzJztcbmltcG9ydCB7IGlzU2luZ2xlSXRlbSB9IGZyb20gJy4uL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIFJlc29sdmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zID0ge1xuICAgICAgY29ubmVjdG9yOiBcIi1cIixcbiAgICAgIGNyZWF0ZUJ1bmRsZUFzc2V0SWQ6IChidW5kbGVJZCwgYXNzZXRJZCkgPT4gYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn0ke2Fzc2V0SWR9YCxcbiAgICAgIGV4dHJhY3RBc3NldElkRnJvbUJ1bmRsZTogKGJ1bmRsZUlkLCBhc3NldEJ1bmRsZUlkKSA9PiBhc3NldEJ1bmRsZUlkLnJlcGxhY2UoYCR7YnVuZGxlSWR9JHt0aGlzLl9idW5kbGVJZENvbm5lY3Rvcn1gLCBcIlwiKVxuICAgIH07XG4gICAgLyoqIFRoZSBjaGFyYWN0ZXIgdGhhdCBpcyB1c2VkIHRvIGNvbm5lY3QgdGhlIGJ1bmRsZUlkIGFuZCB0aGUgYXNzZXRJZCB3aGVuIGdlbmVyYXRpbmcgYSBidW5kbGUgYXNzZXQgaWQga2V5ICovXG4gICAgdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMuY29ubmVjdG9yO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSBidW5kbGUgYXNzZXQgaWQga2V5IGZyb20gYSBidW5kbGVJZCBhbmQgYW4gYXNzZXRJZFxuICAgICAqIEBwYXJhbSBidW5kbGVJZCAtIHRoZSBidW5kbGVJZFxuICAgICAqIEBwYXJhbSBhc3NldElkICAtIHRoZSBhc3NldElkXG4gICAgICogQHJldHVybnMgdGhlIGJ1bmRsZSBhc3NldCBpZCBrZXlcbiAgICAgKi9cbiAgICB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkID0gdGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zLmNyZWF0ZUJ1bmRsZUFzc2V0SWQ7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhbiBhc3NldElkIGZyb20gYSBidW5kbGUgYXNzZXQgaWQga2V5LiBUaGlzIGlzIHRoZSByZXZlcnNlIG9mIGdlbmVyYXRlQnVuZGxlQXNzZXRJZFxuICAgICAqIEBwYXJhbSBidW5kbGVJZCAtIHRoZSBidW5kbGVJZFxuICAgICAqIEBwYXJhbSBhc3NldEJ1bmRsZUlkIC0gdGhlIGJ1bmRsZSBhc3NldCBpZCBrZXlcbiAgICAgKiBAcmV0dXJucyB0aGUgYXNzZXRJZFxuICAgICAqL1xuICAgIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGU7XG4gICAgdGhpcy5fYXNzZXRNYXAgPSB7fTtcbiAgICB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdO1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgICB0aGlzLl9idW5kbGVzID0ge307XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGhvdyB0aGUgcmVzb2x2ZXIgZGVhbHMgd2l0aCBnZW5lcmF0aW5nIGJ1bmRsZSBpZHMuXG4gICAqIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBhbnkgYnVuZGxlcyBhcmUgYWRkZWRcbiAgICogQHBhcmFtIGJ1bmRsZUlkZW50aWZpZXIgLSB0aGUgYnVuZGxlIGlkZW50aWZpZXIgb3B0aW9uc1xuICAgKi9cbiAgc2V0QnVuZGxlSWRlbnRpZmllcihidW5kbGVJZGVudGlmaWVyKSB7XG4gICAgdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSBidW5kbGVJZGVudGlmaWVyLmNvbm5lY3RvciA/PyB0aGlzLl9idW5kbGVJZENvbm5lY3RvcjtcbiAgICB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkID0gYnVuZGxlSWRlbnRpZmllci5jcmVhdGVCdW5kbGVBc3NldElkID8/IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQ7XG4gICAgdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID0gYnVuZGxlSWRlbnRpZmllci5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPz8gdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlO1xuICAgIGlmICh0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoXCJmb29cIiwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChcImZvb1wiLCBcImJhclwiKSkgIT09IFwiYmFyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSZXNvbHZlcl0gR2VuZXJhdGVCdW5kbGVBc3NldElkIGFyZSBub3Qgd29ya2luZyBjb3JyZWN0bHlcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMZXQgdGhlIHJlc29sdmVyIGtub3cgd2hpY2ggYXNzZXRzIHlvdSBwcmVmZXIgdG8gdXNlIHdoZW4gcmVzb2x2aW5nIGFzc2V0cy5cbiAgICogTXVsdGlwbGUgcHJlZmVyIHVzZXIgZGVmaW5lZCBydWxlcyBjYW4gYmUgYWRkZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLnByZWZlcih7XG4gICAqICAgICAvLyBmaXJzdCBsb29rIGZvciBzb21ldGhpbmcgd2l0aCB0aGUgY29ycmVjdCBmb3JtYXQsIGFuZCB0aGVuIHRoZW4gY29ycmVjdCByZXNvbHV0aW9uXG4gICAqICAgICBwcmlvcml0eTogWydmb3JtYXQnLCAncmVzb2x1dGlvbiddLFxuICAgKiAgICAgcGFyYW1zOntcbiAgICogICAgICAgICBmb3JtYXQ6J3dlYnAnLCAvLyBwcmVmZXIgd2VicCBpbWFnZXNcbiAgICogICAgICAgICByZXNvbHV0aW9uOiAyLCAvLyBwcmVmZXIgYSByZXNvbHV0aW9uIG9mIDJcbiAgICogICAgIH1cbiAgICogfSlcbiAgICogcmVzb2x2ZXIuYWRkKCdmb28nLCBbJ2JhckAyeC53ZWJwJywgJ2JhckAyeC5wbmcnLCAnYmFyLndlYnAnLCAnYmFyLnBuZyddKTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJykgLy8gPT4gJ2JhckAyeC53ZWJwJ1xuICAgKiBAcGFyYW0gcHJlZmVyT3JkZXJzIC0gdGhlIHByZWZlciBvcHRpb25zXG4gICAqL1xuICBwcmVmZXIoLi4ucHJlZmVyT3JkZXJzKSB7XG4gICAgcHJlZmVyT3JkZXJzLmZvckVhY2goKHByZWZlcikgPT4ge1xuICAgICAgdGhpcy5fcHJlZmVycmVkT3JkZXIucHVzaChwcmVmZXIpO1xuICAgICAgaWYgKCFwcmVmZXIucHJpb3JpdHkpIHtcbiAgICAgICAgcHJlZmVyLnByaW9yaXR5ID0gT2JqZWN0LmtleXMocHJlZmVyLnBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gYWxsIHVybHMgd2hlbiByZXNvbHZpbmdcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYmFzZVBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS8nO1xuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsICdiYXIub25nJyk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycsICdiYXIucG5nJyk7IC8vID0+ICdodHRwczovL2hvbWUuY29tL2Jhci5wbmcnXG4gICAqIEBwYXJhbSBiYXNlUGF0aCAtIHRoZSBiYXNlIHBhdGggdG8gdXNlXG4gICAqL1xuICBzZXQgYmFzZVBhdGgoYmFzZVBhdGgpIHtcbiAgICB0aGlzLl9iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB9XG4gIGdldCBiYXNlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgcm9vdCBwYXRoIGZvciByb290LXJlbGF0aXZlIFVSTHMuIEJ5IGRlZmF1bHQgdGhlIGBiYXNlUGF0aGAncyByb290IGlzIHVzZWQuIElmIG5vIGBiYXNlUGF0aGAgaXMgc2V0LCB0aGVuIHRoZVxuICAgKiBkZWZhdWx0IHZhbHVlIGZvciBicm93c2VycyBpcyBgd2luZG93LmxvY2F0aW9uLm9yaWdpbmBcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQXBwbGljYXRpb24gaG9zdGVkIG9uIGh0dHBzOi8vaG9tZS5jb20vc29tZS1wYXRoL2luZGV4Lmh0bWxcbiAgICogcmVzb2x2ZXIuYmFzZVBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS9zb21lLXBhdGgvJztcbiAgICogcmVzb2x2ZXIucm9vdFBhdGggPSAnaHR0cHM6Ly9ob21lLmNvbS8nO1xuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsICcvYmFyLnBuZycpO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nLCAnL2Jhci5wbmcnKTsgLy8gPT4gJ2h0dHBzOi8vaG9tZS5jb20vYmFyLnBuZydcbiAgICogQHBhcmFtIHJvb3RQYXRoIC0gdGhlIHJvb3QgcGF0aCB0byB1c2VcbiAgICovXG4gIHNldCByb290UGF0aChyb290UGF0aCkge1xuICAgIHRoaXMuX3Jvb3RQYXRoID0gcm9vdFBhdGg7XG4gIH1cbiAgZ2V0IHJvb3RQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290UGF0aDtcbiAgfVxuICAvKipcbiAgICogQWxsIHRoZSBhY3RpdmUgVVJMIHBhcnNlcnMgdGhhdCBoZWxwIHRoZSBwYXJzZXIgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBhbmQgY3JlYXRlXG4gICAqIGFuIGFzc2V0IG9iamVjdC1iYXNlZCBvbiBwYXJzaW5nIHRoZSBVUkwgaXRzZWxmLlxuICAgKlxuICAgKiBDYW4gYmUgYWRkZWQgdXNpbmcgdGhlIGV4dGVuc2lvbnMgQVBJXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc29sdmVyLmFkZCgnZm9vJywgW1xuICAgKiAgICAge1xuICAgKiAgICAgICAgIHJlc29sdXRpb246IDIsXG4gICAqICAgICAgICAgZm9ybWF0OiAncG5nJyxcbiAgICogICAgICAgICBzcmM6ICdpbWFnZUAyeC5wbmcnLFxuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAqICAgICAgICAgZm9ybWF0OidwbmcnLFxuICAgKiAgICAgICAgIHNyYzogJ2ltYWdlLnBuZycsXG4gICAqICAgICB9LFxuICAgKiBdKTtcbiAgICpcbiAgICogLy8gV2l0aCBhIHVybCBwYXJzZXIgdGhlIGluZm9ybWF0aW9uIHN1Y2ggYXMgcmVzb2x1dGlvbiBhbmQgZmlsZSBmb3JtYXQgY291bGQgZXh0cmFjdGVkIGZyb20gdGhlIHVybCBpdHNlbGY6XG4gICAqIGV4dGVuc2lvbnMuYWRkKHtcbiAgICogICAgIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICAgKiAgICAgdGVzdDogbG9hZFRleHR1cmVzLnRlc3QsIC8vIHRlc3QgaWYgdXJsIGVuZHMgaW4gYW4gaW1hZ2VcbiAgICogICAgIHBhcnNlOiAodmFsdWU6IHN0cmluZykgPT5cbiAgICogICAgICh7XG4gICAqICAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChSZXNvbHZlci5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gJzEnKSxcbiAgICogICAgICAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KCcuJykucG9wKCksXG4gICAqICAgICAgICAgc3JjOiB2YWx1ZSxcbiAgICogICAgIH0pLFxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gTm93IHJlc29sdXRpb24gYW5kIGZvcm1hdCBjYW4gYmUgZXh0cmFjdGVkIGZyb20gdGhlIHVybFxuICAgKiByZXNvbHZlci5hZGQoJ2ZvbycsIFtcbiAgICogICAgICdpbWFnZUAyeC5wbmcnLFxuICAgKiAgICAgJ2ltYWdlLnBuZycsXG4gICAqIF0pO1xuICAgKi9cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbiAgLyoqIFVzZWQgZm9yIHRlc3RpbmcsIHRoaXMgcmVzZXRzIHRoZSByZXNvbHZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZSAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnNldEJ1bmRsZUlkZW50aWZpZXIodGhpcy5fZGVmYXVsdEJ1bmRsZUlkZW50aWZpZXJPcHRpb25zKTtcbiAgICB0aGlzLl9hc3NldE1hcCA9IHt9O1xuICAgIHRoaXMuX3ByZWZlcnJlZE9yZGVyID0gW107XG4gICAgdGhpcy5fcmVzb2x2ZXJIYXNoID0ge307XG4gICAgdGhpcy5fcm9vdFBhdGggPSBudWxsO1xuICAgIHRoaXMuX2Jhc2VQYXRoID0gbnVsbDtcbiAgICB0aGlzLl9tYW5pZmVzdCA9IG51bGw7XG4gICAgdGhpcy5fYnVuZGxlcyA9IHt9O1xuICAgIHRoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IFVSTCBzZWFyY2ggcGFyYW1ldGVycyBmb3IgdGhlIFVSTCByZXNvbHZlci4gVGhlIHVybHMgY2FuIGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSBzZWFyY2hQYXJhbXMgLSB0aGUgZGVmYXVsdCB1cmwgcGFyYW1ldGVycyB0byBhcHBlbmQgd2hlbiByZXNvbHZpbmcgdXJsc1xuICAgKi9cbiAgc2V0RGVmYXVsdFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHNlYXJjaFBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnlWYWx1ZXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gT2JqZWN0LmtleXMocXVlcnlWYWx1ZXMpLm1hcCgoa2V5KSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnlWYWx1ZXNba2V5XSl9YCkuam9pbihcIiZcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbGlhc2VzIGZvciBhIGdpdmVuIGFzc2V0XG4gICAqIEBwYXJhbSBhc3NldCAtIHRoZSBhc3NldCB0byBnZXQgdGhlIGFsaWFzZXMgZm9yXG4gICAqL1xuICBnZXRBbGlhcyhhc3NldCkge1xuICAgIGNvbnN0IHsgYWxpYXMsIHNyYyB9ID0gYXNzZXQ7XG4gICAgY29uc3QgYWxpYXNlc1RvVXNlID0gY29udmVydFRvTGlzdChcbiAgICAgIGFsaWFzIHx8IHNyYyxcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHY/LnNyYyA/PyB2KTtcbiAgICAgICAgaWYgKHZhbHVlPy5zcmMpXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnNyYztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIHJldHVybiBhbGlhc2VzVG9Vc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG1hbmlmZXN0IHRvIHRoZSBhc3NldCByZXNvbHZlci4gVGhpcyBpcyBhIG5pY2Ugd2F5IHRvIGFkZCBhbGwgdGhlIGFzc2V0IGluZm9ybWF0aW9uIGluIG9uZSBnby5cbiAgICogZ2VuZXJhbGx5IGEgbWFuaWZlc3Qgd291bGQgYmUgYnVpbHQgdXNpbmcgYSB0b29sLlxuICAgKiBAcGFyYW0gbWFuaWZlc3QgLSB0aGUgbWFuaWZlc3QgdG8gYWRkIHRvIHRoZSByZXNvbHZlclxuICAgKi9cbiAgYWRkTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICBpZiAodGhpcy5fbWFuaWZlc3QpIHtcbiAgICAgIHdhcm4oXCJbUmVzb2x2ZXJdIE1hbmlmZXN0IGFscmVhZHkgZXhpc3RzLCB0aGlzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cIik7XG4gICAgfVxuICAgIHRoaXMuX21hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgbWFuaWZlc3QuYnVuZGxlcy5mb3JFYWNoKChidW5kbGUpID0+IHtcbiAgICAgIHRoaXMuYWRkQnVuZGxlKGJ1bmRsZS5uYW1lLCBidW5kbGUuYXNzZXRzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBhZGRzIGEgYnVuZGxlIG9mIGFzc2V0cyBpbiBvbmUgZ28gc28gdGhhdCB5b3UgY2FuIHJlc29sdmUgdGhlbSBhcyBhIGdyb3VwLlxuICAgKiBGb3IgZXhhbXBsZSB5b3UgY291bGQgYWRkIGEgYnVuZGxlIGZvciBlYWNoIHNjcmVlbiBpbiB5b3UgcGl4aSBhcHBcbiAgICogQGV4YW1wbGVcbiAgICogcmVzb2x2ZXIuYWRkQnVuZGxlKCdhbmltYWxzJywgW1xuICAgKiAgeyBhbGlhczogJ2J1bm55Jywgc3JjOiAnYnVubnkucG5nJyB9LFxuICAgKiAgeyBhbGlhczogJ2NoaWNrZW4nLCBzcmM6ICdjaGlja2VuLnBuZycgfSxcbiAgICogIHsgYWxpYXM6ICd0aHVtcGVyJywgc3JjOiAndGh1bXBlci5wbmcnIH0sXG4gICAqIF0pO1xuICAgKiAvLyBvclxuICAgKiByZXNvbHZlci5hZGRCdW5kbGUoJ2FuaW1hbHMnLCB7XG4gICAqICAgICBidW5ueTogJ2J1bm55LnBuZycsXG4gICAqICAgICBjaGlja2VuOiAnY2hpY2tlbi5wbmcnLFxuICAgKiAgICAgdGh1bXBlcjogJ3RodW1wZXIucG5nJyxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IHJlc29sdmVkQXNzZXRzID0gYXdhaXQgcmVzb2x2ZXIucmVzb2x2ZUJ1bmRsZSgnYW5pbWFscycpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWQgLSBUaGUgaWQgb2YgdGhlIGJ1bmRsZSB0byBhZGRcbiAgICogQHBhcmFtIGFzc2V0cyAtIEEgcmVjb3JkIG9mIHRoZSBhc3NldCBvciBhc3NldHMgdGhhdCB3aWxsIGJlIGNob3NlbiBmcm9tIHdoZW4gbG9hZGluZyB2aWEgdGhlIHNwZWNpZmllZCBrZXlcbiAgICovXG4gIGFkZEJ1bmRsZShidW5kbGVJZCwgYXNzZXRzKSB7XG4gICAgY29uc3QgYXNzZXROYW1lcyA9IFtdO1xuICAgIGxldCBjb252ZXJ0ZWRBc3NldHMgPSBhc3NldHM7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc2V0cykpIHtcbiAgICAgIGNvbnZlcnRlZEFzc2V0cyA9IE9iamVjdC5lbnRyaWVzKGFzc2V0cykubWFwKChbYWxpYXMsIHNyY10pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYWxpYXMsIHNyYyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFsaWFzLCAuLi5zcmMgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb252ZXJ0ZWRBc3NldHMuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHNyY3MgPSBhc3NldC5zcmM7XG4gICAgICBjb25zdCBhbGlhc2VzID0gYXNzZXQuYWxpYXM7XG4gICAgICBsZXQgaWRzO1xuICAgICAgaWYgKHR5cGVvZiBhbGlhc2VzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUFzc2V0SWQgPSB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBhbGlhc2VzKTtcbiAgICAgICAgYXNzZXROYW1lcy5wdXNoKGJ1bmRsZUFzc2V0SWQpO1xuICAgICAgICBpZHMgPSBbYWxpYXNlcywgYnVuZGxlQXNzZXRJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidW5kbGVJZHMgPSBhbGlhc2VzLm1hcCgobmFtZSkgPT4gdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChidW5kbGVJZCwgbmFtZSkpO1xuICAgICAgICBhc3NldE5hbWVzLnB1c2goLi4uYnVuZGxlSWRzKTtcbiAgICAgICAgaWRzID0gWy4uLmFsaWFzZXMsIC4uLmJ1bmRsZUlkc107XG4gICAgICB9XG4gICAgICB0aGlzLmFkZCh7XG4gICAgICAgIC4uLmFzc2V0LFxuICAgICAgICAuLi57XG4gICAgICAgICAgYWxpYXM6IGlkcyxcbiAgICAgICAgICBzcmM6IHNyY3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fYnVuZGxlc1tidW5kbGVJZF0gPSBhc3NldE5hbWVzO1xuICB9XG4gIC8qKlxuICAgKiBUZWxscyB0aGUgcmVzb2x2ZXIgd2hhdCBrZXlzIGFyZSBhc3NvY2lhdGVkIHdpdGggd2l0Y2ggYXNzZXQuXG4gICAqIFRoZSBtb3N0IGltcG9ydGFudCB0aGluZyB0aGUgcmVzb2x2ZXIgZG9lc1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTaW5nbGUga2V5LCBzaW5nbGUgYXNzZXQ6XG4gICAqIHJlc29sdmVyLmFkZCh7YWxpYXM6ICdmb28nLCBzcmM6ICdiYXIucG5nJyk7XG4gICAqIHJlc29sdmVyLnJlc29sdmVVcmwoJ2ZvbycpIC8vID0+ICdiYXIucG5nJ1xuICAgKlxuICAgKiAvLyBNdWx0aXBsZSBrZXlzLCBzaW5nbGUgYXNzZXQ6XG4gICAqIHJlc29sdmVyLmFkZCh7YWxpYXM6IFsnZm9vJywgJ2JvbyddLCBzcmM6ICdiYXIucG5nJ30pO1xuICAgKiByZXNvbHZlci5yZXNvbHZlVXJsKCdmb28nKSAvLyA9PiAnYmFyLnBuZydcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnYm9vJykgLy8gPT4gJ2Jhci5wbmcnXG4gICAqXG4gICAqIC8vIE11bHRpcGxlIGtleXMsIG11bHRpcGxlIGFzc2V0czpcbiAgICogcmVzb2x2ZXIuYWRkKHthbGlhczogWydmb28nLCAnYm9vJ10sIHNyYzogWydiYXIucG5nJywgJ2Jhci53ZWJwJ119KTtcbiAgICogcmVzb2x2ZXIucmVzb2x2ZVVybCgnZm9vJykgLy8gPT4gJ2Jhci5wbmcnXG4gICAqXG4gICAqIC8vIEFkZCBjdXN0b20gZGF0YSBhdHRhY2hlZCB0byB0aGUgcmVzb2x2ZXJcbiAgICogUmVzb2x2ZXIuYWRkKHtcbiAgICogICAgIGFsaWFzOiAnYnVubnlCb29Cb29TbW9vdGgnLFxuICAgKiAgICAgc3JjOiAnYnVubnl7cG5nLHdlYnB9JyxcbiAgICogICAgIGRhdGE6IHsgc2NhbGVNb2RlOlNDQUxFX01PREVTLk5FQVJFU1QgfSwgLy8gQmFzZSB0ZXh0dXJlIG9wdGlvbnNcbiAgICogfSk7XG4gICAqXG4gICAqIHJlc29sdmVyLnJlc29sdmUoJ2J1bm55Qm9vQm9vU21vb3RoJykgLy8gPT4geyBzcmM6ICdidW5ueS5wbmcnLCBkYXRhOiB7IHNjYWxlTW9kZTogU0NBTEVfTU9ERVMuTkVBUkVTVCB9IH1cbiAgICogQHBhcmFtIGFsaWFzZXMgLSB0aGUgVW5yZXNvbHZlZEFzc2V0IG9yIGFycmF5IG9mIFVucmVzb2x2ZWRBc3NldHMgdG8gYWRkIHRvIHRoZSByZXNvbHZlclxuICAgKi9cbiAgYWRkKGFsaWFzZXMpIHtcbiAgICBjb25zdCBhc3NldHMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuICAgICAgYXNzZXRzLnB1c2goLi4uYWxpYXNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2V0cy5wdXNoKGFsaWFzZXMpO1xuICAgIH1cbiAgICBsZXQga2V5Q2hlY2s7XG4gICAga2V5Q2hlY2sgPSAoa2V5KSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNLZXkoa2V5KSkge1xuICAgICAgICB3YXJuKGBbUmVzb2x2ZXJdIGFscmVhZHkgaGFzIGtleTogJHtrZXl9IG92ZXJ3cml0aW5nYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhc3NldEFycmF5ID0gY29udmVydFRvTGlzdChhc3NldHMpO1xuICAgIGFzc2V0QXJyYXkuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIGNvbnN0IHsgc3JjIH0gPSBhc3NldDtcbiAgICAgIGxldCB7IGRhdGEsIGZvcm1hdCwgbG9hZFBhcnNlciB9ID0gYXNzZXQ7XG4gICAgICBjb25zdCBzcmNzVG9Vc2UgPSBjb252ZXJ0VG9MaXN0KHNyYykubWFwKChzcmMyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdWYXJpYXRpb25zKHNyYzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNyYzIpID8gc3JjMiA6IFtzcmMyXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWxpYXNlc1RvVXNlID0gdGhpcy5nZXRBbGlhcyhhc3NldCk7XG4gICAgICBBcnJheS5pc0FycmF5KGFsaWFzZXNUb1VzZSkgPyBhbGlhc2VzVG9Vc2UuZm9yRWFjaChrZXlDaGVjaykgOiBrZXlDaGVjayhhbGlhc2VzVG9Vc2UpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRBc3NldHMgPSBbXTtcbiAgICAgIHNyY3NUb1VzZS5mb3JFYWNoKChzcmNzKSA9PiB7XG4gICAgICAgIHNyY3MuZm9yRWFjaCgoc3JjMikgPT4ge1xuICAgICAgICAgIGxldCBmb3JtYXR0ZWRBc3NldCA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3JjMiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gc3JjMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLl9wYXJzZXJzW2ldO1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRlc3Qoc3JjMikpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHBhcnNlci5wYXJzZShzcmMyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc3JjMi5kYXRhID8/IGRhdGE7XG4gICAgICAgICAgICBmb3JtYXQgPSBzcmMyLmZvcm1hdCA/PyBmb3JtYXQ7XG4gICAgICAgICAgICBsb2FkUGFyc2VyID0gc3JjMi5sb2FkUGFyc2VyID8/IGxvYWRQYXJzZXI7XG4gICAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHtcbiAgICAgICAgICAgICAgLi4uZm9ybWF0dGVkQXNzZXQsXG4gICAgICAgICAgICAgIC4uLnNyYzJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYWxpYXNlc1RvVXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSZXNvbHZlcl0gYWxpYXMgaXMgdW5kZWZpbmVkIGZvciB0aGlzIGFzc2V0OiAke2Zvcm1hdHRlZEFzc2V0LnNyY31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0dGVkQXNzZXQgPSB0aGlzLl9idWlsZFJlc29sdmVkQXNzZXQoZm9ybWF0dGVkQXNzZXQsIHtcbiAgICAgICAgICAgIGFsaWFzZXM6IGFsaWFzZXNUb1VzZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBsb2FkUGFyc2VyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzb2x2ZWRBc3NldHMucHVzaChmb3JtYXR0ZWRBc3NldCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhbGlhc2VzVG9Vc2UuZm9yRWFjaCgoYWxpYXMpID0+IHtcbiAgICAgICAgdGhpcy5fYXNzZXRNYXBbYWxpYXNdID0gcmVzb2x2ZWRBc3NldHM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPOiB0aGlzIG5lZWRzIGFuIG92ZXJsb2FkIGxpa2UgbG9hZCBkaWQgaW4gQXNzZXRzXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVzb2x2ZXIgaGFzIGhhZCBhIG1hbmlmZXN0IHNldCB2aWEgc2V0TWFuaWZlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGFzc2V0cyB1cmxzIGZvclxuICAgKiBhIGdpdmVuIGJ1bmRsZUlkIG9yIGJ1bmRsZUlkcy5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gTWFuaWZlc3QgRXhhbXBsZVxuICAgKiBjb25zdCBtYW5pZmVzdCA9IHtcbiAgICogICAgIGJ1bmRsZXM6IFtcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICAgIG5hbWU6ICdsb2FkLXNjcmVlbicsXG4gICAqICAgICAgICAgICAgIGFzc2V0czogW1xuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnYmFja2dyb3VuZCcsXG4gICAqICAgICAgICAgICAgICAgICAgICAgc3JjOiAnc3Vuc2V0LnBuZycsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnYmFyJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdsb2FkLWJhci57cG5nLHdlYnB9JyxcbiAgICogICAgICAgICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAgIF0sXG4gICAqICAgICAgICAgfSxcbiAgICogICAgICAgICB7XG4gICAqICAgICAgICAgICAgIG5hbWU6ICdnYW1lLXNjcmVlbicsXG4gICAqICAgICAgICAgICAgIGFzc2V0czogW1xuICAgKiAgICAgICAgICAgICAgICAge1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnY2hhcmFjdGVyJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdyb2JvdC5wbmcnLFxuICAgKiAgICAgICAgICAgICAgICAgfSxcbiAgICogICAgICAgICAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgICAgICAgICBhbGlhczogJ2VuZW15JyxcbiAgICogICAgICAgICAgICAgICAgICAgICBzcmM6ICdiYWQtZ3V5LnBuZycsXG4gICAqICAgICAgICAgICAgICAgICB9LFxuICAgKiAgICAgICAgICAgICBdLFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICBdXG4gICAqIH07XG4gICAqXG4gICAqIHJlc29sdmVyLnNldE1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICogY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlci5yZXNvbHZlQnVuZGxlKCdsb2FkLXNjcmVlbicpO1xuICAgKiBAcGFyYW0gYnVuZGxlSWRzIC0gVGhlIGJ1bmRsZSBpZHMgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyBBbGwgdGhlIGJ1bmRsZXMgYXNzZXRzIG9yIGEgaGFzaCBvZiBhc3NldHMgZm9yIGVhY2ggYnVuZGxlIHNwZWNpZmllZFxuICAgKi9cbiAgcmVzb2x2ZUJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbShidW5kbGVJZHMpO1xuICAgIGJ1bmRsZUlkcyA9IGNvbnZlcnRUb0xpc3QoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBidW5kbGVJZHMuZm9yRWFjaCgoYnVuZGxlSWQpID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0TmFtZXMgPSB0aGlzLl9idW5kbGVzW2J1bmRsZUlkXTtcbiAgICAgIGlmIChhc3NldE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLnJlc29sdmUoYXNzZXROYW1lcyk7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgY29uc3QgYXNzZXQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgYXNzZXRzW3RoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZShidW5kbGVJZCwga2V5KV0gPSBhc3NldDtcbiAgICAgICAgfVxuICAgICAgICBvdXRbYnVuZGxlSWRdID0gYXNzZXRzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFtidW5kbGVJZHNbMF1dIDogb3V0O1xuICB9XG4gIC8qKlxuICAgKiBEb2VzIGV4YWN0bHkgd2hhdCByZXNvbHZlIGRvZXMsIGJ1dCByZXR1cm5zIGp1c3QgdGhlIFVSTCByYXRoZXIgdGhhbiB0aGUgd2hvbGUgYXNzZXQgb2JqZWN0XG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9yIGtleXMgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJucyAtIFRoZSBVUkxzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5KHMpXG4gICAqL1xuICByZXNvbHZlVXJsKGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzb2x2ZShrZXkpO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBvdXQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgb3V0W2ldID0gcmVzdWx0W2ldLnNyYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc3JjO1xuICB9XG4gIHJlc29sdmUoa2V5cykge1xuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKGtleXMpO1xuICAgIGtleXMgPSBjb252ZXJ0VG9MaXN0KGtleXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc29sdmVySGFzaFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3NldE1hcFtrZXldKSB7XG4gICAgICAgICAgbGV0IGFzc2V0cyA9IHRoaXMuX2Fzc2V0TWFwW2tleV07XG4gICAgICAgICAgY29uc3QgcHJlZmVycmVkT3JkZXIgPSB0aGlzLl9nZXRQcmVmZXJyZWRPcmRlcihhc3NldHMpO1xuICAgICAgICAgIHByZWZlcnJlZE9yZGVyPy5wcmlvcml0eS5mb3JFYWNoKChwcmlvcml0eUtleSkgPT4ge1xuICAgICAgICAgICAgcHJlZmVycmVkT3JkZXIucGFyYW1zW3ByaW9yaXR5S2V5XS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEFzc2V0cyA9IGFzc2V0cy5maWx0ZXIoKGFzc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0W3ByaW9yaXR5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0W3ByaW9yaXR5S2V5XSA9PT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChmaWx0ZXJlZEFzc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhc3NldHMgPSBmaWx0ZXJlZEFzc2V0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0gPSBhc3NldHNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV0gPSB0aGlzLl9idWlsZFJlc29sdmVkQXNzZXQoe1xuICAgICAgICAgICAgYWxpYXM6IFtrZXldLFxuICAgICAgICAgICAgc3JjOiBrZXlcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gcmVzdWx0W2tleXNbMF1dIDogcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gYXNzZXQgd2l0aCBhIGdpdmVuIGtleSBleGlzdHMgaW4gdGhlIHJlc29sdmVyXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBhc3NldFxuICAgKi9cbiAgaGFzS2V5KGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuX2Fzc2V0TWFwW2tleV07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGJ1bmRsZSB3aXRoIHRoZSBnaXZlbiBrZXkgZXhpc3RzIGluIHRoZSByZXNvbHZlclxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgYnVuZGxlXG4gICAqL1xuICBoYXNCdW5kbGUoa2V5KSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYnVuZGxlc1trZXldO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgZmlndXJpbmcgb3V0IHdoYXQgcHJlZmVyIGNyaXRlcmlhIGFuIGFzc2V0IHNob3VsZCB1c2UuXG4gICAqIEBwYXJhbSBhc3NldHNcbiAgICovXG4gIF9nZXRQcmVmZXJyZWRPcmRlcihhc3NldHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXNzZXQgPSBhc3NldHNbMF07XG4gICAgICBjb25zdCBwcmVmZXJyZWQgPSB0aGlzLl9wcmVmZXJyZWRPcmRlci5maW5kKChwcmVmZXJlbmNlKSA9PiBwcmVmZXJlbmNlLnBhcmFtcy5mb3JtYXQuaW5jbHVkZXMoYXNzZXQuZm9ybWF0KSk7XG4gICAgICBpZiAocHJlZmVycmVkKSB7XG4gICAgICAgIHJldHVybiBwcmVmZXJyZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVmZXJyZWRPcmRlclswXTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZGVmYXVsdCB1cmwgcGFyYW1ldGVycyB0byB0aGUgdXJsXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGFwcGVuZCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIHRvXG4gICAqIEByZXR1cm5zIC0gVGhlIHVybCB3aXRoIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgYXBwZW5kZWRcbiAgICovXG4gIF9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKHVybCkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcylcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgcGFyYW1Db25uZWN0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICAgIHJldHVybiBgJHt1cmx9JHtwYXJhbUNvbm5lY3Rvcn0ke3RoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXN9YDtcbiAgfVxuICBfYnVpbGRSZXNvbHZlZEFzc2V0KGZvcm1hdHRlZEFzc2V0LCBkYXRhKSB7XG4gICAgY29uc3QgeyBhbGlhc2VzLCBkYXRhOiBhc3NldERhdGEsIGxvYWRQYXJzZXIsIGZvcm1hdCB9ID0gZGF0YTtcbiAgICBpZiAodGhpcy5fYmFzZVBhdGggfHwgdGhpcy5fcm9vdFBhdGgpIHtcbiAgICAgIGZvcm1hdHRlZEFzc2V0LnNyYyA9IHBhdGgudG9BYnNvbHV0ZShmb3JtYXR0ZWRBc3NldC5zcmMsIHRoaXMuX2Jhc2VQYXRoLCB0aGlzLl9yb290UGF0aCk7XG4gICAgfVxuICAgIGZvcm1hdHRlZEFzc2V0LmFsaWFzID0gYWxpYXNlcyA/PyBmb3JtYXR0ZWRBc3NldC5hbGlhcyA/PyBbZm9ybWF0dGVkQXNzZXQuc3JjXTtcbiAgICBmb3JtYXR0ZWRBc3NldC5zcmMgPSB0aGlzLl9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKGZvcm1hdHRlZEFzc2V0LnNyYyk7XG4gICAgZm9ybWF0dGVkQXNzZXQuZGF0YSA9IHsgLi4uYXNzZXREYXRhIHx8IHt9LCAuLi5mb3JtYXR0ZWRBc3NldC5kYXRhIH07XG4gICAgZm9ybWF0dGVkQXNzZXQubG9hZFBhcnNlciA9IGxvYWRQYXJzZXIgPz8gZm9ybWF0dGVkQXNzZXQubG9hZFBhcnNlcjtcbiAgICBmb3JtYXR0ZWRBc3NldC5mb3JtYXQgPSBmb3JtYXQgPz8gZm9ybWF0dGVkQXNzZXQuZm9ybWF0ID8/IGdldFVybEV4dGVuc2lvbihmb3JtYXR0ZWRBc3NldC5zcmMpO1xuICAgIHJldHVybiBmb3JtYXR0ZWRBc3NldDtcbiAgfVxufVxuLyoqXG4gKiBUaGUgcHJlZml4IHRoYXQgZGVub3RlcyBhIFVSTCBpcyBmb3IgYSByZXRpbmEgYXNzZXQuXG4gKiBAc3RhdGljXG4gKiBAbmFtZSBSRVRJTkFfUFJFRklYXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGRlZmF1bHQgL0AoWzAtOVxcLl0rKXgvXG4gKiBAZXhhbXBsZSBgQDJ4YFxuICovXG5SZXNvbHZlci5SRVRJTkFfUFJFRklYID0gL0AoWzAtOVxcLl0rKXgvO1xuZnVuY3Rpb24gZ2V0VXJsRXh0ZW5zaW9uKHVybCkge1xuICByZXR1cm4gdXJsLnNwbGl0KFwiLlwiKS5wb3AoKS5zcGxpdChcIj9cIikuc2hpZnQoKS5zcGxpdChcIiNcIikuc2hpZnQoKTtcbn1cblxuZXhwb3J0IHsgUmVzb2x2ZXIsIGdldFVybEV4dGVuc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb2x2ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IF9TcHJpdGVzaGVldCA9IGNsYXNzIF9TcHJpdGVzaGVldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIFJlZmVyZW5jZSB0byB0aGUgc291cmNlIEJhc2VUZXh0dXJlIG9iamVjdC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBTcHJpdGVzaGVldCBpbWFnZSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgZGF0YSkge1xuICAgIC8qKiBGb3IgbXVsdGktcGFja2VkIHNwcml0ZXNoZWV0cywgdGhpcyBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhbGwgdGhlIG90aGVyIHNwcml0ZXNoZWV0cyBpdCBkZXBlbmRzIG9uLiAqL1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZSA6IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgY29uc3QgbWV0YVJlc29sdXRpb24gPSBwYXJzZUZsb2F0KGRhdGEubWV0YS5zY2FsZSk7XG4gICAgaWYgKG1ldGFSZXNvbHV0aW9uKSB7XG4gICAgICB0aGlzLnJlc29sdXRpb24gPSBtZXRhUmVzb2x1dGlvbjtcbiAgICAgIHRleHR1cmUuc291cmNlLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIH1cbiAgICB0aGlzLl9mcmFtZXMgPSB0aGlzLmRhdGEuZnJhbWVzO1xuICAgIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyk7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXIgc3ByaXRlc2hlZXQgZnJvbSBsb2FkZWQgZGF0YS4gVGhpcyBpcyBkb25lIGFzeW5jaHJvbm91c2x5XG4gICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICovXG4gIHBhcnNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICBpZiAodGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKDApO1xuICAgICAgICB0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhIGJhdGNoIG9mIGZyYW1lc1xuICAgKiBAcGFyYW0gaW5pdGlhbEZyYW1lSW5kZXggLSBUaGUgaW5kZXggb2YgZnJhbWUgdG8gc3RhcnQuXG4gICAqL1xuICBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgIGxldCBmcmFtZUluZGV4ID0gaW5pdGlhbEZyYW1lSW5kZXg7XG4gICAgY29uc3QgbWF4RnJhbWVzID0gX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkU7XG4gICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2ZyYW1lS2V5c1tmcmFtZUluZGV4XTtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9mcmFtZXNbaV07XG4gICAgICBjb25zdCByZWN0ID0gZGF0YS5mcmFtZTtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGxldCBmcmFtZSA9IG51bGw7XG4gICAgICAgIGxldCB0cmltID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc291cmNlU2l6ZSA9IGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zb3VyY2VTaXplID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZTtcbiAgICAgICAgY29uc3Qgb3JpZyA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICBNYXRoLmZsb29yKHNvdXJjZVNpemUuaCkgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNwcml0ZVNvdXJjZVNpemUpIHtcbiAgICAgICAgICB0cmltID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLngpIC8gdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueSkgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sXG4gICAgICAgICAgICBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZSh7XG4gICAgICAgICAgc291cmNlOiB0aGlzLnRleHR1cmVTb3VyY2UsXG4gICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgb3JpZyxcbiAgICAgICAgICB0cmltLFxuICAgICAgICAgIHJvdGF0ZTogZGF0YS5yb3RhdGVkID8gMiA6IDAsXG4gICAgICAgICAgZGVmYXVsdEFuY2hvcjogZGF0YS5hbmNob3IsXG4gICAgICAgICAgZGVmYXVsdEJvcmRlcnM6IGRhdGEuYm9yZGVycyxcbiAgICAgICAgICBsYWJlbDogaS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnJhbWVJbmRleCsrO1xuICAgIH1cbiAgfVxuICAvKiogUGFyc2UgYW5pbWF0aW9ucyBjb25maWcuICovXG4gIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgZm9yIChjb25zdCBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvbnNbYW5pbU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLiAqL1xuICBfcGFyc2VDb21wbGV0ZSgpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudGV4dHVyZXMpO1xuICB9XG4gIC8qKiBCZWdpbiB0aGUgbmV4dCBiYXRjaCBvZiB0ZXh0dXJlcy4gKi9cbiAgX25leHRCYXRjaCgpIHtcbiAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKHRoaXMuX2JhdGNoSW5kZXggKiBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSk7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCsrO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2JhdGNoSW5kZXggKiBfU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbmV4dEJhdGNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgU3ByaXRlc2hlZXQgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gICAqL1xuICBkZXN0cm95KGRlc3Ryb3lCYXNlID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lcyA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVLZXlzID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZT8uZGVzdHJveSgpO1xuICAgICAgdGhpcy50ZXh0dXJlU291cmNlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmxpbmtlZFNoZWV0cyA9IFtdO1xuICB9XG59O1xuLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUZXh0dXJlcyB0byBidWlsZCBwZXIgcHJvY2Vzcy4gKi9cbl9TcHJpdGVzaGVldC5CQVRDSF9TSVpFID0gMWUzO1xubGV0IFNwcml0ZXNoZWV0ID0gX1Nwcml0ZXNoZWV0O1xuXG5leHBvcnQgeyBTcHJpdGVzaGVldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlc2hlZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuLi9hc3NldHMvbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5pbXBvcnQgeyBSZXNvbHZlciB9IGZyb20gJy4uL2Fzc2V0cy9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gJy4uL2Fzc2V0cy91dGlscy9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5tanMnO1xuaW1wb3J0IHsgU3ByaXRlc2hlZXQgfSBmcm9tICcuL1Nwcml0ZXNoZWV0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgdmFsaWRJbWFnZXMgPSBbXG4gIFwianBnXCIsXG4gIFwicG5nXCIsXG4gIFwianBlZ1wiLFxuICBcImF2aWZcIixcbiAgXCJ3ZWJwXCIsXG4gIFwiYmFzaXNcIixcbiAgXCJldGMyXCIsXG4gIFwiYmM3XCIsXG4gIFwiYmM2aFwiLFxuICBcImJjNVwiLFxuICBcImJjNFwiLFxuICBcImJjM1wiLFxuICBcImJjMlwiLFxuICBcImJjMVwiLFxuICBcImVhY1wiLFxuICBcImFzdGNcIlxuXTtcbmZ1bmN0aW9uIGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCwgaWdub3JlTXVsdGlQYWNrKSB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQ7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhhc3NldC50ZXh0dXJlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgb3V0W2tleV0gPSBhc3NldC50ZXh0dXJlc1trZXldO1xuICB9KTtcbiAgaWYgKCFpZ25vcmVNdWx0aVBhY2spIHtcbiAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGguZGlybmFtZShrZXlzWzBdKTtcbiAgICBhc3NldC5saW5rZWRTaGVldHMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qgb3V0MiA9IGdldENhY2hlYWJsZUFzc2V0cyhbYCR7YmFzZVBhdGh9LyR7YXNzZXQuZGF0YS5tZXRhLnJlbGF0ZWRfbXVsdGlfcGFja3NbaV19YF0sIGl0ZW0sIHRydWUpO1xuICAgICAgT2JqZWN0LmFzc2lnbihvdXQsIG91dDIpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5jb25zdCBzcHJpdGVzaGVldEFzc2V0ID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQXNzZXQsXG4gIC8qKiBIYW5kbGUgdGhlIGNhY2hpbmcgb2YgdGhlIHJlbGF0ZWQgU3ByaXRlc2hlZXQgVGV4dHVyZXMgKi9cbiAgY2FjaGU6IHtcbiAgICB0ZXN0OiAoYXNzZXQpID0+IGFzc2V0IGluc3RhbmNlb2YgU3ByaXRlc2hlZXQsXG4gICAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IGdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCBhc3NldCwgZmFsc2UpXG4gIH0sXG4gIC8qKiBSZXNvbHZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBhc3NldC4gKi9cbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBVUkwgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgICBjb25zdCBzcGxpdCA9IHRlbXBVUkwuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBzcGxpdC5wb3AoKTtcbiAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwianNvblwiICYmIHZhbGlkSW1hZ2VzLmluY2x1ZGVzKGZvcm1hdCk7XG4gICAgfSxcbiAgICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoUmVzb2x2ZXIuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgZm9ybWF0OiBzcGxpdFtzcGxpdC5sZW5ndGggLSAyXSxcbiAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBMb2FkZXIgcGx1Z2luIHRoYXQgcGFyc2VzIHNwcml0ZSBzaGVldHMhXG4gICAqIG9uY2UgdGhlIEpTT04gaGFzIGJlZW4gbG9hZGVkIHRoaXMgY2hlY2tzIHRvIHNlZSBpZiB0aGUgSlNPTiBpcyBzcHJpdGVzaGVldCBkYXRhLlxuICAgKiBJZiBpdCBpcywgd2UgbG9hZCB0aGUgc3ByaXRlc2hlZXRzIGltYWdlIGFuZCBwYXJzZSB0aGUgZGF0YSBpbnRvIFNwcml0ZXNoZWV0XG4gICAqIEFsbCB0ZXh0dXJlcyBpbiB0aGUgc3ByaXRlIHNoZWV0IGFyZSB0aGVuIGFkZGVkIHRvIHRoZSBjYWNoZVxuICAgKi9cbiAgbG9hZGVyOiB7XG4gICAgbmFtZTogXCJzcHJpdGVzaGVldExvYWRlclwiLFxuICAgIGV4dGVuc2lvbjoge1xuICAgICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICAgIH0sXG4gICAgYXN5bmMgdGVzdFBhcnNlKGFzc2V0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcGF0aC5leHRuYW1lKG9wdGlvbnMuc3JjKS50b0xvd2VyQ2FzZSgpID09PSBcIi5qc29uXCIgJiYgISFhc3NldC5mcmFtZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShhc3NldCwgb3B0aW9ucywgbG9hZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRleHR1cmU6IGltYWdlVGV4dHVyZSxcbiAgICAgICAgLy8gaWYgdXNlciBuZWVkIHRvIHVzZSBwcmVsb2FkZWQgdGV4dHVyZVxuICAgICAgICBpbWFnZUZpbGVuYW1lXG4gICAgICAgIC8vIGlmIHVzZXIgbmVlZCB0byB1c2UgY3VzdG9tIGZpbGVuYW1lIChub3QgZnJvbSBqc29uRmlsZS5tZXRhLmltYWdlKVxuICAgICAgfSA9IG9wdGlvbnM/LmRhdGEgPz8ge307XG4gICAgICBsZXQgYmFzZVBhdGggPSBwYXRoLmRpcm5hbWUob3B0aW9ucy5zcmMpO1xuICAgICAgaWYgKGJhc2VQYXRoICYmIGJhc2VQYXRoLmxhc3RJbmRleE9mKFwiL1wiKSAhPT0gYmFzZVBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBiYXNlUGF0aCArPSBcIi9cIjtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0dXJlO1xuICAgICAgaWYgKGltYWdlVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgdGV4dHVyZSA9IGltYWdlVGV4dHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGNvcHlTZWFyY2hQYXJhbXMoYmFzZVBhdGggKyAoaW1hZ2VGaWxlbmFtZSA/PyBhc3NldC5tZXRhLmltYWdlKSwgb3B0aW9ucy5zcmMpO1xuICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCBsb2FkZXIubG9hZChbaW1hZ2VQYXRoXSk7XG4gICAgICAgIHRleHR1cmUgPSBhc3NldHNbaW1hZ2VQYXRoXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0KFxuICAgICAgICB0ZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgYXNzZXRcbiAgICAgICk7XG4gICAgICBhd2FpdCBzcHJpdGVzaGVldC5wYXJzZSgpO1xuICAgICAgY29uc3QgbXVsdGlQYWNrcyA9IGFzc2V0Py5tZXRhPy5yZWxhdGVkX211bHRpX3BhY2tzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXVsdGlQYWNrcykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG11bHRpUGFja3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhPy5pZ25vcmVNdWx0aVBhY2spIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtVXJsID0gY29weVNlYXJjaFBhcmFtcyhpdGVtVXJsLCBvcHRpb25zLnNyYyk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cyA9IHJlcztcbiAgICAgICAgcmVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmxpbmtlZFNoZWV0cyA9IFtzcHJpdGVzaGVldF0uY29uY2F0KHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cy5maWx0ZXIoKHNwKSA9PiBzcCAhPT0gaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcHJpdGVzaGVldDtcbiAgICB9LFxuICAgIHVubG9hZChzcHJpdGVzaGVldCkge1xuICAgICAgc3ByaXRlc2hlZXQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCB7IHNwcml0ZXNoZWV0QXNzZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZXNoZWV0QXNzZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9IGZyb20gJy4vc3ByaXRlc2hlZXRBc3NldC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKHNwcml0ZXNoZWV0QXNzZXQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9026\n")},9366:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  v: () => (/* binding */ Ticker)\n});\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(901);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/TickerListener.mjs\n\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs\n\n\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = ticker_const/* UPDATE_PRIORITY */.u.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlDQUF5QztBQUM1RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3RpY2tlci9UaWNrZXJMaXN0ZW5lci5tanM/ZjMwYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi90aWNrZXIvVGlja2VyLm1qcz83YzM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyTGlzdGVuZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgKiBAcGFyYW0gb25jZSAtIElmIHRoZSBoYW5kbGVyIHNob3VsZCBmaXJlIG9uY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZuLCBjb250ZXh0ID0gbnVsbCwgcHJpb3JpdHkgPSAwLCBvbmNlID0gZmFsc2UpIHtcbiAgICAvKiogVGhlIG5leHQgaXRlbSBpbiBjaGFpbi4gKi9cbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIC8qKiBUaGUgcHJldmlvdXMgaXRlbSBpbiBjaGFpbi4gKi9cbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAvKiogYHRydWVgIGlmIHRoaXMgbGlzdGVuZXIgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuICovXG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5fb25jZSA9IG9uY2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBsaXN0ZW5lciBtYXRjaCB0aGUgYXJndW1lbnRzXG4gICAqL1xuICBtYXRjaChmbiwgY29udGV4dCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fZm4gPT09IGZuICYmIHRoaXMuX2NvbnRleHQgPT09IGNvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIEVtaXQgYnkgY2FsbGluZyB0aGUgY3VycmVudCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHRpY2tlciAtIFRoZSB0aWNrZXIgZW1pdHRpbmcuXG4gICAqIEByZXR1cm5zIE5leHQgdGlja2VyXG4gICAqL1xuICBlbWl0KHRpY2tlcikge1xuICAgIGlmICh0aGlzLl9mbikge1xuICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB0aWNrZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm4odGlja2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XG4gICAgaWYgKHRoaXMuX29uY2UpIHtcbiAgICAgIHRoaXMuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcHJldmlvdXMgLSBJbnB1dCBub2RlLCBwcmV2aW91cyBsaXN0ZW5lclxuICAgKi9cbiAgY29ubmVjdChwcmV2aW91cykge1xuICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICBpZiAocHJldmlvdXMubmV4dCkge1xuICAgICAgcHJldmlvdXMubmV4dC5wcmV2aW91cyA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQ7XG4gICAgcHJldmlvdXMubmV4dCA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgKiBAcGFyYW0gaGFyZCAtIGB0cnVlYCB0byByZW1vdmUgdGhlIGBuZXh0YCByZWZlcmVuY2UsIHRoaXNcbiAgICogICAgICAgIGlzIGNvbnNpZGVyZWQgYSBoYXJkIGRlc3Ryb3kuIFNvZnQgZGVzdHJveSBtYWludGFpbnMgdGhlIG5leHQgcmVmZXJlbmNlLlxuICAgKiBAcmV0dXJucyBUaGUgbGlzdGVuZXIgdG8gcmVkaXJlY3Qgd2hpbGUgZW1pdHRpbmcgb3IgcmVtb3ZpbmcuXG4gICAqL1xuICBkZXN0cm95KGhhcmQgPSBmYWxzZSkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3Q7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG59XG5cbmV4cG9ydCB7IFRpY2tlckxpc3RlbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJMaXN0ZW5lci5tanMubWFwXG4iLCJpbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXJMaXN0ZW5lciB9IGZyb20gJy4vVGlja2VyTGlzdGVuZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfVGlja2VyID0gY2xhc3MgX1RpY2tlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGlja2VyIHNob3VsZCBpbnZva2UgdGhlIG1ldGhvZFxuICAgICAqIHtAbGluayB0aWNrZXIuVGlja2VyI3N0YXJ0fHN0YXJ0fSBhdXRvbWF0aWNhbGx5IHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNjYWxhciB0aW1lIHZhbHVlIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjbWluRlBTfG1pbkZQU31cbiAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIHRpY2tlci5UaWNrZXIjc3BlZWR8c3BlZWR9LlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHtAbGluayB0aWNrZXIuVGlja2VyI3VwZGF0ZXx1cGRhdGV9IHdhcyBpbnZva2VkLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcbiAgICAgKiB1cGRhdGUsIGJ1dCBvbmx5IHdoZW4gYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZC5cbiAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcbiAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lID0gLTE7XG4gICAgLyoqXG4gICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIHRpY2tlci5UaWNrZXIjZGVsdGFUaW1lfGRlbHRhVGltZX0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTY2FsZXMgdGlja2VyLmRlbHRhVGltZSB0byB3aGF0IHdvdWxkIGJlXG4gICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXG4gICAgICogdGlja2VyLnNwZWVkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAqIGB0cnVlYCBpZiB7QGxpbmsgdGlja2VyLlRpY2tlciNzdGFydHxzdGFydH0gaGFzIGJlZW4gY2FsbGVkLlxuICAgICAqIGBmYWxzZWAgaWYge0BsaW5rIHRpY2tlci5UaWNrZXIjc3RvcHxTdG9wfSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcbiAgICAgKiBldmVudCBvZiB7QGxpbmsgdGlja2VyLlRpY2tlciNhdXRvU3RhcnR8YXV0b1N0YXJ0fSBiZWluZyBgdHJ1ZWBcbiAgICAgKiBhbmQgYSBsaXN0ZW5lciBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAvKiogSW50ZXJuYWwgY3VycmVudCBmcmFtZSByZXF1ZXN0IElEICovXG4gICAgdGhpcy5fcmVxdWVzdElkID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgKiBUaGlzIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cbiAgICAgKi9cbiAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDA7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdmFsdWUgbWFuYWdlZCBieSBtaW5GUFMgcHJvcGVydHkgc2V0dGVyIGFuZCBnZXR0ZXIuXG4gICAgICogVGhpcyBpcyB0aGUgbWluaW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICovXG4gICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMDtcbiAgICAvKiogSWYgZW5hYmxlZCwgZGVsZXRpbmcgaXMgZGlzYWJsZWQuKi9cbiAgICB0aGlzLl9wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgICAvKiogVGhlIGxhc3QgdGltZSBrZXlmcmFtZSB3YXMgZXhlY3V0ZWQuIE1haW50YWlucyBhIHJlbGF0aXZlbHkgZml4ZWQgaW50ZXJ2YWwgd2l0aCB0aGUgcHJldmlvdXMgdmFsdWUuICovXG4gICAgdGhpcy5fbGFzdEZyYW1lID0gLTE7XG4gICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcihudWxsLCBudWxsLCBJbmZpbml0eSk7XG4gICAgdGhpcy5kZWx0YU1TID0gMSAvIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfVGlja2VyLnRhcmdldEZQTVM7XG4gICAgdGhpcy5fdGljayA9ICh0aW1lKSA9PiB7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aW1lKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsXG4gICAqIGVtaXR0ZXIgaGFzIGxpc3RlbmVycywgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5sYXN0VGltZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgY2FuY2VscyBhIHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhbmNlbElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gICAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcbiAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxuICAgKiBjb25kaXRpb25zIGFyZSBtZXQsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC4gSWYgdGhlIHRpY2tlciBoYXMgbm90XG4gICAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxuICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydElmUG9zc2libGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aWNrIGV2ZW50cy4gQ2FsbHMgY29udGludW91c2x5IHVubGVzc1xuICAgKiBpdCBpcyByZW1vdmVkIG9yIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciB1cGRhdGVzXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgYWRkKGZuLCBjb250ZXh0LCBwcmlvcml0eSA9IFVQREFURV9QUklPUklUWS5OT1JNQUwpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSkpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciB0aGUgdGljayBldmVudCB3aGljaCBpcyBvbmx5IGV4ZWN1dGUgb25jZS5cbiAgICogQHBhcmFtIGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkgPSBVUERBVEVfUFJJT1JJVFkuTk9STUFMKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHksIHRydWUpKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWxseSBhZGRzIHRoZSBldmVudCBoYW5kbGVyIHNvIHRoYXQgaXQgY2FuIGJlIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIEN1cnJlbnQgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXG4gICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICovXG4gIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIGxldCBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyLnByaW9yaXR5ID4gY3VycmVudC5wcmlvcml0eSkge1xuICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmICghbGlzdGVuZXIucHJldmlvdXMpIHtcbiAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyBtYXRjaGluZyB0aGUgZnVuY3Rpb24gYW5kIGNvbnRleHQgcGFyYW1ldGVycy5cbiAgICogSWYgbm8gaGFuZGxlcnMgYXJlIGxlZnQgYWZ0ZXIgcmVtb3ZpbmcsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgKi9cbiAgcmVtb3ZlKGZuLCBjb250ZXh0KSB7XG4gICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9oZWFkLm5leHQpIHtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvbiB0aGlzIHRpY2tlciwgY2FsY3VsYXRlZCBieSB3YWxraW5nIHRocm91Z2ggbGlua2VkIGxpc3RcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQubmV4dCkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIC8qKiBTdGFydHMgdGhlIHRpY2tlci4gSWYgdGhlIHRpY2tlciBoYXMgbGlzdGVuZXJzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZCBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC4gKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICB9XG4gIC8qKiBEZXN0cm95IHRoZSB0aWNrZXIgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLiBDYWxsaW5nIHRoaXMgbWV0aG9kIHJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZXZlbnRzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5fcHJvdGVjdGVkKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcnMgYW4gdXBkYXRlLiBBbiB1cGRhdGUgZW50YWlscyBzZXR0aW5nIHRoZVxuICAgKiBjdXJyZW50IHtAbGluayB0aWNrZXIuVGlja2VyI2VsYXBzZWRNU3xlbGFwc2VkTVN9LFxuICAgKiB0aGUgY3VycmVudCB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfSxcbiAgICogaW52b2tpbmcgYWxsIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZGVsdGFUaW1lLFxuICAgKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjbGFzdFRpbWV8bGFzdFRpbWV9XG4gICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IGFuaW1hdGlvblxuICAgKiBmcmFtZSBjYWxsYmFja3MgaWYgdGhlIHRpY2tlciBpbnN0YW5jZSBoYXMgYmVlbiBzdGFydGVkXG4gICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnJlbnRUaW1lPXBlcmZvcm1hbmNlLm5vdygpXSAtIHRoZSBjdXJyZW50IHRpbWUgb2YgZXhlY3V0aW9uXG4gICAqL1xuICB1cGRhdGUoY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSkge1xuICAgIGxldCBlbGFwc2VkTVM7XG4gICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0VGltZSkge1xuICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICBpZiAoZWxhcHNlZE1TID4gdGhpcy5fbWF4RWxhcHNlZE1TKSB7XG4gICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIGVsYXBzZWRNUyAqPSB0aGlzLnNwZWVkO1xuICAgICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fbGFzdEZyYW1lIHwgMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgdGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGN1cnJlbnRUaW1lIC0gZGVsdGEgJSB0aGlzLl9taW5FbGFwc2VkTVM7XG4gICAgICB9XG4gICAgICB0aGlzLmRlbHRhTVMgPSBlbGFwc2VkTVM7XG4gICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZGVsdGFNUyAqIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgbGV0IGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZW1pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxuICAgKiBUaGUgZGVmYXVsdCBpcyBhcHByb3hpbWF0ZWx5IDYwIGluIG1vc3QgbW9kZXJuIGJyb3dzZXJzLlxuICAgKiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBmYWN0b3IgaW4gdGhlIHZhbHVlIG9mXG4gICAqIHtAbGluayB0aWNrZXIuVGlja2VyI3NwZWVkfHNwZWVkfSwgd2hpY2ggaXMgc3BlY2lmaWNcbiAgICogdG8gc2NhbGluZyB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfS5cbiAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBGUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuZWxhcHNlZE1TO1xuICB9XG4gIC8qKlxuICAgKiBNYW5hZ2VzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgdGlja2VyLlRpY2tlciN1cGRhdGV8dXBkYXRlfS5cbiAgICogVGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGNhcCB7QGxpbmsgdGlja2VyLlRpY2tlciNkZWx0YVRpbWV8ZGVsdGFUaW1lfSxcbiAgICogYnV0IGRvZXMgbm90IGVmZmVjdCB0aGUgbWVhc3VyZWQgdmFsdWUgb2Yge0BsaW5rIHRpY2tlci5UaWNrZXIjRlBTfEZQU30uXG4gICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIGAwYCBhbmQgYFRpY2tlci50YXJnZXRGUE1TICogMTAwMGAuXG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICogQGRlZmF1bHQgMTBcbiAgICovXG4gIGdldCBtaW5GUFMoKSB7XG4gICAgcmV0dXJuIDFlMyAvIHRoaXMuX21heEVsYXBzZWRNUztcbiAgfVxuICBzZXQgbWluRlBTKGZwcykge1xuICAgIGNvbnN0IG1pbkZQUyA9IE1hdGgubWluKHRoaXMubWF4RlBTLCBmcHMpO1xuICAgIGNvbnN0IG1pbkZQTVMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtaW5GUFMpIC8gMWUzLCBfVGlja2VyLnRhcmdldEZQTVMpO1xuICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xuICB9XG4gIC8qKlxuICAgKiBNYW5hZ2VzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgcmVxdWlyZWQgdG9cbiAgICogZWxhcHNlIGJldHdlZW4gaW52b2tpbmcge0BsaW5rIHRpY2tlci5UaWNrZXIjdXBkYXRlfHVwZGF0ZX0uXG4gICAqIFRoaXMgd2lsbCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayB0aWNrZXIuVGlja2VyI0ZQU3xGUFN9LlxuICAgKiBJZiBpdCBpcyBzZXQgdG8gYDBgLCB0aGVuIHRoZXJlIGlzIG5vIGxpbWl0OyBQaXhpSlMgd2lsbCByZW5kZXIgYXMgbWFueSBmcmFtZXMgYXMgaXQgY2FuLlxuICAgKiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhdCBsZWFzdCBgbWluRlBTYFxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBtYXhGUFMoKSB7XG4gICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoMWUzIC8gdGhpcy5fbWluRWxhcHNlZE1TKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc2V0IG1heEZQUyhmcHMpIHtcbiAgICBpZiAoZnBzID09PSAwKSB7XG4gICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyAobWF4RlBTIC8gMWUzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIEFuaW1hdGVkU3ByaXRlfSBhbmQgYnlcbiAgICoge0BsaW5rIFZpZGVvUmVzb3VyY2V9IHRvIHVwZGF0ZSBhbmltYXRpb24gZnJhbWVzIC8gdmlkZW8gdGV4dHVyZXMuXG4gICAqXG4gICAqIEl0IG1heSBhbHNvIGJlIHVzZWQgYnkge0BsaW5rIEFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogVGhlIHByb3BlcnR5IHtAbGluayB0aWNrZXIuVGlja2VyI2F1dG9TdGFydHxhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IFRpY2tlciB9IGZyb20gJ3BpeGkuanMnO1xuICAgKlxuICAgKiBjb25zdCB0aWNrZXIgPSBUaWNrZXIuc2hhcmVkO1xuICAgKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAgICogLy8gQnkgZGVmYXVsdCB0aGlzIGlzIHRydWUgb25seSBmb3IgdGhlIFRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXG4gICAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICpcbiAgICogLy8gRllJLCBjYWxsIHRoaXMgdG8gZW5zdXJlIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC4gSXQgc2hvdWxkIGJlIHN0b3BwZWRcbiAgICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxuICAgKiB0aWNrZXIuc3RvcCgpO1xuICAgKlxuICAgKiAvLyBDYWxsIHRoaXMgd2hlbiB5b3UgYXJlIHJlYWR5IGZvciBhIHJ1bm5pbmcgc2hhcmVkIHRpY2tlci5cbiAgICogdGlja2VyLnN0YXJ0KCk7XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciwgQ29udGFpbmVyIH0gZnJvbSAncGl4aS5qcyc7XG4gICAqXG4gICAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxuICAgKiBjb25zdCByZW5kZXJlciA9IGF1dG9EZXRlY3RSZW5kZXJlcigpO1xuICAgKiBjb25zdCBzdGFnZSA9IG5ldyBDb250YWluZXIoKTtcbiAgICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcbiAgICogdGlja2VyLmFkZCgodGltZSkgPT4gcmVuZGVyZXIucmVuZGVyKHN0YWdlKSk7XG4gICAqXG4gICAqIC8vIE9yIHlvdSBjYW4ganVzdCB1cGRhdGUgaXQgbWFudWFsbHkuXG4gICAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICogdGlja2VyLnN0b3AoKTtcbiAgICogY29uc3QgYW5pbWF0ZSA9ICh0aW1lKSA9PiB7XG4gICAqICAgICB0aWNrZXIudXBkYXRlKHRpbWUpO1xuICAgKiAgICAgcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcbiAgICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICogfTtcbiAgICogYW5pbWF0ZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAqIEBtZW1iZXIge3RpY2tlci5UaWNrZXJ9XG4gICAqIEByZWFkb25seVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICBpZiAoIV9UaWNrZXIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlci5fc2hhcmVkID0gbmV3IF9UaWNrZXIoKTtcbiAgICAgIHNoYXJlZC5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgc2hhcmVkLl9wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlci5fc2hhcmVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHRpY2tlciBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBCYXNlUHJlcGFyZX0gZm9yIGNvcmUgdGltaW5nXG4gICAqIGZ1bmN0aW9uYWxpdHkgdGhhdCBzaG91bGRuJ3QgdXN1YWxseSBuZWVkIHRvIGJlIHBhdXNlZCwgdW5saWtlIHRoZSBgc2hhcmVkYFxuICAgKiB0aWNrZXIgd2hpY2ggZHJpdmVzIHZpc3VhbCBhbmltYXRpb25zIGFuZCByZW5kZXJpbmcgd2hpY2ggbWF5IHdhbnQgdG8gYmUgcGF1c2VkLlxuICAgKlxuICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIHRpY2tlci5UaWNrZXIjYXV0b1N0YXJ0fGF1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7dGlja2VyLlRpY2tlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlci5fc3lzdGVtKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSBfVGlja2VyLl9zeXN0ZW0gPSBuZXcgX1RpY2tlcigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICBzeXN0ZW0uX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfVGlja2VyLl9zeXN0ZW07XG4gIH1cbn07XG4vKipcbiAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICogQHN0YXRpY1xuICovXG5fVGlja2VyLnRhcmdldEZQTVMgPSAwLjA2O1xubGV0IFRpY2tlciA9IF9UaWNrZXI7XG5cbmV4cG9ydCB7IFRpY2tlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlja2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9366\n")},901:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ UPDATE_PRIORITY)\n/* harmony export */ });\n\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAxLmpzIiwibWFwcGluZ3MiOiI7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFRztBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3RpY2tlci9jb25zdC5tanM/MmFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBVUERBVEVfUFJJT1JJVFkgPSAvKiBAX19QVVJFX18gKi8gKChVUERBVEVfUFJJT1JJVFkyKSA9PiB7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIklOVEVSQUNUSU9OXCJdID0gNTBdID0gXCJJTlRFUkFDVElPTlwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJISUdIXCJdID0gMjVdID0gXCJISUdIXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIk5PUk1BTFwiXSA9IDBdID0gXCJOT1JNQUxcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiTE9XXCJdID0gLTI1XSA9IFwiTE9XXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIlVUSUxJVFlcIl0gPSAtNTBdID0gXCJVVElMSVRZXCI7XG4gIHJldHVybiBVUERBVEVfUFJJT1JJVFkyO1xufSkoVVBEQVRFX1BSSU9SSVRZIHx8IHt9KTtcblxuZXhwb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///901\n')},1013:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   O: () => (/* binding */ unsafeEvalSupported)\n/* harmony export */ });\n\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rix3QkFBd0IsUUFBUTtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcz8zNTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubGV0IHVuc2FmZUV2YWw7XG5mdW5jdGlvbiB1bnNhZmVFdmFsU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHVuc2FmZUV2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHVuc2FmZUV2YWw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicGFyYW0xXCIsIFwicGFyYW0yXCIsIFwicGFyYW0zXCIsIFwicmV0dXJuIHBhcmFtMVtwYXJhbTJdID09PSBwYXJhbTM7XCIpO1xuICAgIHVuc2FmZUV2YWwgPSBmdW5jKHsgYTogXCJiXCIgfSwgXCJhXCIsIFwiYlwiKSA9PT0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVuc2FmZUV2YWwgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdW5zYWZlRXZhbDtcbn1cblxuZXhwb3J0IHsgdW5zYWZlRXZhbFN1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5zYWZlRXZhbFN1cHBvcnRlZC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1013\n')},7040:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ removeItems)\n/* harmony export */ });\n\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0MC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9kYXRhL3JlbW92ZUl0ZW1zLm1qcz9kMTc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlQ291bnQgPSBzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudDtcbiAgY29uc3QgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgfVxuICBhcnIubGVuZ3RoID0gbGVuO1xufVxuXG5leHBvcnQgeyByZW1vdmVJdGVtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlSXRlbXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7040\n")},6258:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ uid)\n/* harmony export */ });\n/* unused harmony export resetUids */\n\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = "default") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2RhdGEvdWlkLm1qcz80NjM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdWlkQ2FjaGUgPSB7XG4gIGRlZmF1bHQ6IC0xXG59O1xuZnVuY3Rpb24gdWlkKG5hbWUgPSBcImRlZmF1bHRcIikge1xuICBpZiAodWlkQ2FjaGVbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgIHVpZENhY2hlW25hbWVdID0gLTE7XG4gIH1cbiAgcmV0dXJuICsrdWlkQ2FjaGVbbmFtZV07XG59XG5mdW5jdGlvbiByZXNldFVpZHMoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHVpZENhY2hlKSB7XG4gICAgZGVsZXRlIHVpZENhY2hlW2tleV07XG4gIH1cbn1cblxuZXhwb3J0IHsgcmVzZXRVaWRzLCB1aWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpZC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6258\n')},3747:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   w: () => (/* binding */ updateQuadBounds)\n/* harmony export */ });\n\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\n\n//# sourceMappingURL=updateQuadBounds.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzPzVlNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiB1cGRhdGVRdWFkQm91bmRzKGJvdW5kcywgYW5jaG9yLCB0ZXh0dXJlLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZS5vcmlnO1xuICBjb25zdCB0cmltID0gdGV4dHVyZS50cmltO1xuICBpZiAodHJpbSkge1xuICAgIGNvbnN0IHNvdXJjZVdpZHRoID0gdHJpbS53aWR0aDtcbiAgICBjb25zdCBzb3VyY2VIZWlnaHQgPSB0cmltLmhlaWdodDtcbiAgICBib3VuZHMubWluWCA9IHRyaW0ueCAtIGFuY2hvci5feCAqIHdpZHRoIC0gcGFkZGluZztcbiAgICBib3VuZHMubWF4WCA9IGJvdW5kcy5taW5YICsgc291cmNlV2lkdGg7XG4gICAgYm91bmRzLm1pblkgPSB0cmltLnkgLSBhbmNob3IuX3kgKiBoZWlnaHQgLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhZID0gYm91bmRzLm1pblkgKyBzb3VyY2VIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzLm1pblggPSAtYW5jaG9yLl94ICogd2lkdGggLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhYID0gYm91bmRzLm1pblggKyB3aWR0aDtcbiAgICBib3VuZHMubWluWSA9IC1hbmNob3IuX3kgKiBoZWlnaHQgLSBwYWRkaW5nO1xuICAgIGJvdW5kcy5tYXhZID0gYm91bmRzLm1pblkgKyBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5leHBvcnQgeyB1cGRhdGVRdWFkQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVRdWFkQm91bmRzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3747\n")},156:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ v8_0_0),\n/* harmony export */   a: () => (/* binding */ deprecation)\n/* harmony export */ });\n\nconst warnings = {};\nconst v8_0_0 = "8.0.0";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        "%cPixiJS Deprecation Warning: %c%s",\n        "color:#614108;background:#fffbe6",\n        "font-weight:normal;color:#614108;background:#fffbe6",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0JBQW9CLFFBQVE7QUFDNUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDRCQUE0QixjQUFjO0FBQzFDLFdBQVc7QUFDWCxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNEO0FBQ3RELG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanM/NGI1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdhcm5pbmdzID0ge307XG5jb25zdCB2OF8wXzAgPSBcIjguMC4wXCI7XG5mdW5jdGlvbiBkZXByZWNhdGlvbih2ZXJzaW9uLCBtZXNzYWdlLCBpZ25vcmVEZXB0aCA9IDMpIHtcbiAgaWYgKHdhcm5pbmdzW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICBpZiAodHlwZW9mIHN0YWNrID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6IFwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICB9IGVsc2Uge1xuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoXCJcXG5cIikuc3BsaWNlKGlnbm9yZURlcHRoKS5qb2luKFwiXFxuXCIpO1xuICAgIGlmIChjb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICBcIiVjUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6ICVjJXNcIixcbiAgICAgICAgXCJjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbDtjb2xvcjojNjE0MTA4O2JhY2tncm91bmQ6I2ZmZmJlNlwiLFxuICAgICAgICBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogXCIsIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YCk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgIH1cbiAgfVxuICB3YXJuaW5nc1ttZXNzYWdlXSA9IHRydWU7XG59XG5cbmV4cG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0aW9uLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///156\n')},4796:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (/* binding */ warn)\n/* harmony export */ });\n\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");\n  } else {\n    console.warn("PixiJS Warning: ", ...args);\n  }\n}\n\n\n//# sourceMappingURL=warn.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanM/MWI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCB3YXJuQ291bnQgPSAwO1xuY29uc3QgbWF4V2FybmluZ3MgPSA1MDA7XG5mdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgaWYgKHdhcm5Db3VudCA9PT0gbWF4V2FybmluZ3MpXG4gICAgcmV0dXJuO1xuICB3YXJuQ291bnQrKztcbiAgaWYgKHdhcm5Db3VudCA9PT0gbWF4V2FybmluZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogdG9vIG1hbnkgd2FybmluZ3MsIG5vIG1vcmUgd2FybmluZ3Mgd2lsbCBiZSByZXBvcnRlZCB0byB0aGUgY29uc29sZSBieSBQaXhpSlMuXCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlBpeGlKUyBXYXJuaW5nOiBcIiwgLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgd2FybiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fybi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4796\n')},1718:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith("blob:");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return "";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it\'s not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving \'..\' and \'.\' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the \'root\', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":",\n  joinExtensions: [".html"]\n};\n\n\n//# sourceMappingURL=path.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9wYXRoLm1qcz9mN2VhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoMikge1xuICBpZiAodHlwZW9mIHBhdGgyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHBhdGgyKX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVXJsUGFyYW1zKHVybCkge1xuICBjb25zdCByZSA9IHVybC5zcGxpdChcIj9cIilbMF07XG4gIHJldHVybiByZS5zcGxpdChcIiNcIilbMF07XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGZpbmQpLCBcImdcIiksIHJlcGxhY2UpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aDIsIGFsbG93QWJvdmVSb290KSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICBsZXQgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICBsZXQgbGFzdFNsYXNoID0gLTE7XG4gIGxldCBkb3RzID0gMDtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0aDIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgyLmxlbmd0aCkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSA0NztcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlcyArPSBcIi8uLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBcIi4uXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzICs9IGAvJHtwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHBhdGgyLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBwYXRoID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSBwYXRoIHRvIHBvc2l4IGZvcm1hdC5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBjb252ZXJ0IHRvIHBvc2l4XG4gICAqL1xuICB0b1Bvc2l4KHBhdGgyKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VBbGwocGF0aDIsIFwiXFxcXFwiLCBcIi9cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBVUkwgZS5nLiBodHRwOi8vLCBodHRwczovL1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc1VybChwYXRoMikge1xuICAgIHJldHVybiAvXmh0dHBzPzovLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBkYXRhIFVSTFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc0RhdGFVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gL15kYXRhOihbYS16XStcXC9bYS16MC05LSsuXSsoO1thLXowLTktLiEjJCUqKy57fXx+YF0rPVthLXowLTktLiEjJCUqKy57fSgpX3x+YF0rKSopPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHM8Pl0qPykkL2kudGVzdChwYXRoMik7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhdGggaXMgYSBibG9iIFVSTFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBpc0Jsb2JVcmwocGF0aDIpIHtcbiAgICByZXR1cm4gcGF0aDIuc3RhcnRzV2l0aChcImJsb2I6XCIpO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXRoIGhhcyBhIHByb3RvY29sIGUuZy4gaHR0cDovLywgaHR0cHM6Ly8sIGZpbGU6Ly8vLCBkYXRhOiwgYmxvYjosIEM6L1xuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIHdpbmRvd3MgZmlsZSBwYXRoc1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAqL1xuICBoYXNQcm90b2NvbChwYXRoMikge1xuICAgIHJldHVybiAvXlteLzpdKzovLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbCBvZiB0aGUgcGF0aCBlLmcuIGh0dHA6Ly8sIGh0dHBzOi8vLCBmaWxlOi8vLywgZGF0YTosIGJsb2I6LCBDOi9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBnZXQgdGhlIHByb3RvY29sIGZyb21cbiAgICovXG4gIGdldFByb3RvY29sKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgcGF0aDIgPSB0aGlzLnRvUG9zaXgocGF0aDIpO1xuICAgIGNvbnN0IG1hdGNoRmlsZSA9IC9eZmlsZTpcXC9cXC9cXC8vLmV4ZWMocGF0aDIpO1xuICAgIGlmIChtYXRjaEZpbGUpIHtcbiAgICAgIHJldHVybiBtYXRjaEZpbGVbMF07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoUHJvdG9jb2wgPSAvXlteLzpdKzpcXC97MCwyfS8uZXhlYyhwYXRoMik7XG4gICAgaWYgKG1hdGNoUHJvdG9jb2wpIHtcbiAgICAgIHJldHVybiBtYXRjaFByb3RvY29sWzBdO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnRzIFVSTCB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBXaGVuIGxvYWRpbmcgZnJvbSBhIFdlYiBXb3JrZXIsIHdlIG11c3QgdXNlIGFic29sdXRlIHBhdGhzLlxuICAgKiBJZiB0aGUgVVJMIGlzIGFscmVhZHkgYWJzb2x1dGUgd2UgcmV0dXJuIGl0IGFzIGlzXG4gICAqIElmIGl0J3Mgbm90LCB3ZSBjb252ZXJ0IGl0XG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIHRlc3RcbiAgICogQHBhcmFtIGN1c3RvbUJhc2VVcmwgLSBUaGUgYmFzZSBVUkwgdG8gdXNlXG4gICAqIEBwYXJhbSBjdXN0b21Sb290VXJsIC0gVGhlIHJvb3QgVVJMIHRvIHVzZVxuICAgKi9cbiAgdG9BYnNvbHV0ZSh1cmwsIGN1c3RvbUJhc2VVcmwsIGN1c3RvbVJvb3RVcmwpIHtcbiAgICBhc3NlcnRQYXRoKHVybCk7XG4gICAgaWYgKHRoaXMuaXNEYXRhVXJsKHVybCkgfHwgdGhpcy5pc0Jsb2JVcmwodXJsKSlcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgYmFzZVVybCA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgoY3VzdG9tQmFzZVVybCA/PyBET01BZGFwdGVyLmdldCgpLmdldEJhc2VVcmwoKSkpO1xuICAgIGNvbnN0IHJvb3RVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbVJvb3RVcmwgPz8gdGhpcy5yb290bmFtZShiYXNlVXJsKSkpO1xuICAgIHVybCA9IHRoaXMudG9Qb3NpeCh1cmwpO1xuICAgIGlmICh1cmwuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4ocm9vdFVybCwgdXJsLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoID0gdGhpcy5pc0Fic29sdXRlKHVybCkgPyB1cmwgOiB0aGlzLmpvaW4oYmFzZVVybCwgdXJsKTtcbiAgICByZXR1cm4gYWJzb2x1dGVQYXRoO1xuICB9LFxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcGF0aCwgcmVzb2x2aW5nICcuLicgYW5kICcuJyBzZWdtZW50c1xuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIG5vcm1hbGl6ZVxuICAgKi9cbiAgbm9ybWFsaXplKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBpZiAodGhpcy5pc0RhdGFVcmwocGF0aDIpIHx8IHRoaXMuaXNCbG9iVXJsKHBhdGgyKSlcbiAgICAgIHJldHVybiBwYXRoMjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHByb3RvY29sID0gXCJcIjtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gICAgaWYgKHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKSB7XG4gICAgICBwcm90b2NvbCA9IHRoaXMucm9vdG5hbWUocGF0aDIpO1xuICAgICAgcGF0aDIgPSBwYXRoMi5zbGljZShwcm90b2NvbC5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGgyLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBwYXRoMiA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBmYWxzZSk7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpXG4gICAgICBwYXRoMiArPSBcIi9cIjtcbiAgICBpZiAoaXNBYnNvbHV0ZSlcbiAgICAgIHJldHVybiBgLyR7cGF0aDJ9YDtcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoMjtcbiAgfSxcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgcGF0aCBpcyBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKiBBYnNvbHV0ZSBwYXRocyBjYW4gYmUgdXJscywgZGF0YSB1cmxzLCBvciBwYXRocyBvbiBkaXNrXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdGVzdFxuICAgKi9cbiAgaXNBYnNvbHV0ZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBpZiAodGhpcy5oYXNQcm90b2NvbChwYXRoMikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gcGF0aDIuc3RhcnRzV2l0aChcIi9cIik7XG4gIH0sXG4gIC8qKlxuICAgKiBKb2lucyBhbGwgZ2l2ZW4gcGF0aCBzZWdtZW50cyB0b2dldGhlciB1c2luZyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgc2VwYXJhdG9yIGFzIGEgZGVsaW1pdGVyLFxuICAgKiB0aGVuIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoXG4gICAqIEBwYXJhbSBzZWdtZW50cyAtIFRoZSBzZWdtZW50cyBvZiB0aGUgcGF0aCB0byBqb2luXG4gICAqL1xuICBqb2luKC4uLnNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICBsZXQgam9pbmVkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFyZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHZvaWQgMClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByZXZBcmcgPSBzZWdtZW50c1tpIC0gMV0gPz8gXCJcIjtcbiAgICAgICAgICBpZiAodGhpcy5qb2luRXh0ZW5zaW9ucy5pbmNsdWRlcyh0aGlzLmV4dG5hbWUocHJldkFyZykudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLy4uLyR7YXJnfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpvaW5lZCArPSBgLyR7YXJnfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lIG9mIGEgcGF0aFxuICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHBhcnNlXG4gICAqL1xuICBkaXJuYW1lKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGhhc1Jvb3QgPSBjb2RlID09PSA0NztcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgY29uc3QgcHJvdG8gPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICBjb25zdCBvcmlncGF0aCA9IHBhdGgyO1xuICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG8ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgcmV0dXJuIGhhc1Jvb3QgPyBcIi9cIiA6IHRoaXMuaXNVcmwob3JpZ3BhdGgpID8gcHJvdG8gKyBwYXRoMiA6IHByb3RvO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSlcbiAgICAgIHJldHVybiBcIi8vXCI7XG4gICAgcmV0dXJuIHByb3RvICsgcGF0aDIuc2xpY2UoMCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIHBhdGggZS5nLiAvLCBDOi8sIGZpbGU6Ly8vLCBodHRwOi8vZG9tYWluLmNvbS9cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgcm9vdG5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgbGV0IHJvb3QgPSBcIlwiO1xuICAgIGlmIChwYXRoMi5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgIHJvb3QgPSBcIi9cIjtcbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSB0aGlzLmdldFByb3RvY29sKHBhdGgyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcmwocGF0aDIpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhdGgyLmluZGV4T2YoXCIvXCIsIHJvb3QubGVuZ3RoKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcm9vdCA9IHBhdGgyLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByb290ID0gcGF0aDI7XG4gICAgICBpZiAoIXJvb3QuZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICByb290ICs9IFwiL1wiO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgcG9ydGlvbiBvZiBhIHBhdGhcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0ZXN0XG4gICAqIEBwYXJhbSBleHQgLSBPcHRpb25hbCBleHRlbnNpb24gdG8gcmVtb3ZlXG4gICAqL1xuICBiYXNlbmFtZShwYXRoMiwgZXh0KSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKGV4dClcbiAgICAgIGFzc2VydFBhdGgoZXh0KTtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgaTtcbiAgICBpZiAoZXh0ICE9PSB2b2lkIDAgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoMi5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoMi5sZW5ndGggJiYgZXh0ID09PSBwYXRoMilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpXG4gICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICBlbHNlIGlmIChlbmQgPT09IC0xKVxuICAgICAgICBlbmQgPSBwYXRoMi5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAocGF0aDIuY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGF0aCwgZnJvbSB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSAuIChwZXJpb2QpIGNoYXJhY3RlciB0byBlbmQgb2Ygc3RyaW5nIGluIHRoZSBsYXN0XG4gICAqIHBvcnRpb24gb2YgdGhlIHBhdGguIElmIHRoZXJlIGlzIG5vIC4gaW4gdGhlIGxhc3QgcG9ydGlvbiBvZiB0aGUgcGF0aCwgb3IgaWYgdGhlcmUgYXJlIG5vIC4gY2hhcmFjdGVycyBvdGhlciB0aGFuXG4gICAqIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGJhc2VuYW1lIG9mIHBhdGgsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBwYXJzZVxuICAgKi9cbiAgZXh0bmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuICAvKipcbiAgICogUGFyc2VzIGEgcGF0aCBpbnRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSAncm9vdCcsIGBkaXJgLCBgYmFzZWAsIGBleHRgLCBhbmQgYG5hbWVgIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gcGFyc2VcbiAgICovXG4gIHBhcnNlKHBhdGgyKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgY29uc3QgcmV0ID0geyByb290OiBcIlwiLCBkaXI6IFwiXCIsIGJhc2U6IFwiXCIsIGV4dDogXCJcIiwgbmFtZTogXCJcIiB9O1xuICAgIGlmIChwYXRoMi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gcmV0O1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBjb2RlID0gcGF0aDIuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBpc0Fic29sdXRlID0gdGhpcy5pc0Fic29sdXRlKHBhdGgyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBcIlwiO1xuICAgIHJldC5yb290ID0gdGhpcy5yb290bmFtZShwYXRoMik7XG4gICAgaWYgKGlzQWJzb2x1dGUgfHwgdGhpcy5oYXNQcm90b2NvbChwYXRoMikpIHtcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gLTE7XG4gICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgbGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxO1xuICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpXG4gICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aDIuc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cbiAgICByZXQuZGlyID0gdGhpcy5kaXJuYW1lKHBhdGgyKTtcbiAgICBpZiAocHJvdG9jb2wpXG4gICAgICByZXQuZGlyID0gcHJvdG9jb2wgKyByZXQuZGlyO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHNlcDogXCIvXCIsXG4gIGRlbGltaXRlcjogXCI6XCIsXG4gIGpvaW5FeHRlbnNpb25zOiBbXCIuaHRtbFwiXVxufTtcblxuZXhwb3J0IHsgcGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1718\n')},5374:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   K: () => (/* binding */ Pool)\n/* harmony export */ });\n\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n}\n\n\n//# sourceMappingURL=Pool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3NC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1tb3VzZS1ldmVudC10cmFuc21pdHRlci8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi91dGlscy9wb29sL1Bvb2wubWpzPzViMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBQb29sIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgUG9vbC5cbiAgICogQHBhcmFtIENsYXNzVHlwZSAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgaXRlbXMgaW4gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbFNpemVdIC0gVGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgcG9vbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKENsYXNzVHlwZSwgaW5pdGlhbFNpemUpIHtcbiAgICB0aGlzLl9wb29sID0gW107XG4gICAgdGhpcy5fY291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICB0aGlzLl9jbGFzc1R5cGUgPSBDbGFzc1R5cGU7XG4gICAgaWYgKGluaXRpYWxTaXplKSB7XG4gICAgICB0aGlzLnByZXBvcHVsYXRlKGluaXRpYWxTaXplKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByZXBvcHVsYXRlcyB0aGUgcG9vbCB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0gdG90YWwgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICovXG4gIHByZXBvcHVsYXRlKHRvdGFsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICB0aGlzLl9wb29sW3RoaXMuX2luZGV4KytdID0gbmV3IHRoaXMuX2NsYXNzVHlwZSgpO1xuICAgIH1cbiAgICB0aGlzLl9jb3VudCArPSB0b3RhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIGZyb20gdGhlIHBvb2wuIENhbGxzIHRoZSBpdGVtJ3MgYGluaXRgIG1ldGhvZCBpZiBpdCBleGlzdHMuXG4gICAqIElmIHRoZXJlIGFyZSBubyBpdGVtcyBsZWZ0IGluIHRoZSBwb29sLCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtkYXRhXSAtIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgaXRlbSdzIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7VH0gVGhlIGl0ZW0gZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGdldChkYXRhKSB7XG4gICAgbGV0IGl0ZW07XG4gICAgaWYgKHRoaXMuX2luZGV4ID4gMCkge1xuICAgICAgaXRlbSA9IHRoaXMuX3Bvb2xbLS10aGlzLl9pbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0gPSBuZXcgdGhpcy5fY2xhc3NUeXBlKCk7XG4gICAgfVxuICAgIGl0ZW0uaW5pdD8uKGRhdGEpO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGl0ZW0gdG8gdGhlIHBvb2wuIENhbGxzIHRoZSBpdGVtJ3MgYHJlc2V0YCBtZXRob2QgaWYgaXQgZXhpc3RzLlxuICAgKiBAcGFyYW0ge1R9IGl0ZW0gLSBUaGUgaXRlbSB0byByZXR1cm4gdG8gdGhlIHBvb2wuXG4gICAqL1xuICByZXR1cm4oaXRlbSkge1xuICAgIGl0ZW0ucmVzZXQ/LigpO1xuICAgIHRoaXMuX3Bvb2xbdGhpcy5faW5kZXgrK10gPSBpdGVtO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBvb2wuXG4gICAqIEByZWFkb25seVxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdG90YWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwb29sIHRoYXQgYXJlIGZyZWUgdG8gdXNlIHdpdGhvdXQgbmVlZGluZyB0byBjcmVhdGUgbW9yZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCB0b3RhbEZyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBvb2wgdGhhdCBhcmUgY3VycmVudGx5IGluIHVzZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXIge251bWJlcn1cbiAgICovXG4gIGdldCB0b3RhbFVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50IC0gdGhpcy5faW5kZXg7XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9vbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5374\n")},5906:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u: () => (/* binding */ BigPool)\n/* harmony export */ });\n/* unused harmony export PoolGroupClass */\n/* harmony import */ var _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5374);\n\n\n"use strict";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item\'s constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Pool */ .K(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\n\n//# sourceMappingURL=PoolGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkwNi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLFNBQVM7QUFDdEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcz81MWRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvb2wgfSBmcm9tICcuL1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBQb29sR3JvdXBDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFwIHRvIHN0b3JlIHRoZSBwb29scyBieSB0aGVpciBjbGFzcyB0eXBlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcG9vbHNCeUNsYXNzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogUHJlcG9wdWxhdGVzIGEgc3BlY2lmaWMgcG9vbCB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3MgLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGl0ZW1zIGluIHRoZSBwb29sLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWwgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICovXG4gIHByZXBvcHVsYXRlKENsYXNzLCB0b3RhbCkge1xuICAgIGNvbnN0IGNsYXNzUG9vbCA9IHRoaXMuZ2V0UG9vbChDbGFzcyk7XG4gICAgY2xhc3NQb29sLnByZXBvcHVsYXRlKHRvdGFsKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIGZyb20gYSBzcGVjaWZpYyBwb29sLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3MgLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGl0ZW1zIGluIHRoZSBwb29sLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtkYXRhXSAtIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgaXRlbSdzIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7VH0gVGhlIGl0ZW0gZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGdldChDbGFzcywgZGF0YSkge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmdldFBvb2woQ2xhc3MpO1xuICAgIHJldHVybiBwb29sLmdldChkYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVtIHRvIGl0cyByZXNwZWN0aXZlIHBvb2wuXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byByZXR1cm4gdG8gdGhlIHBvb2wuXG4gICAqL1xuICByZXR1cm4oaXRlbSkge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmdldFBvb2woaXRlbS5jb25zdHJ1Y3Rvcik7XG4gICAgcG9vbC5yZXR1cm4oaXRlbSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzcGVjaWZpYyBwb29sIGJhc2VkIG9uIHRoZSBjbGFzcyB0eXBlLlxuICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBpdGVtcyBpbiB0aGUgcG9vbC4gTXVzdCBleHRlbmQgUG9vbEl0ZW0uXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1Db25zdHJ1Y3RvcjxUPn0gQ2xhc3NUeXBlIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBpdGVtcyBpbiB0aGUgcG9vbC5cbiAgICogQHJldHVybnMge1Bvb2w8VD59IFRoZSBwb29sIG9mIHRoZSBnaXZlbiBjbGFzcyB0eXBlLlxuICAgKi9cbiAgZ2V0UG9vbChDbGFzc1R5cGUpIHtcbiAgICBpZiAoIXRoaXMuX3Bvb2xzQnlDbGFzcy5oYXMoQ2xhc3NUeXBlKSkge1xuICAgICAgdGhpcy5fcG9vbHNCeUNsYXNzLnNldChDbGFzc1R5cGUsIG5ldyBQb29sKENsYXNzVHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9vbHNCeUNsYXNzLmdldChDbGFzc1R5cGUpO1xuICB9XG4gIC8qKiBnZXRzIHRoZSB1c2FnZSBzdGF0cyBvZiBlYWNoIHBvb2wgaW4gdGhlIHN5c3RlbSAqL1xuICBzdGF0cygpIHtcbiAgICBjb25zdCBzdGF0cyA9IHt9O1xuICAgIHRoaXMuX3Bvb2xzQnlDbGFzcy5mb3JFYWNoKChwb29sKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gc3RhdHNbcG9vbC5fY2xhc3NUeXBlLm5hbWVdID8gcG9vbC5fY2xhc3NUeXBlLm5hbWUgKyBwb29sLl9jbGFzc1R5cGUuSUQgOiBwb29sLl9jbGFzc1R5cGUubmFtZTtcbiAgICAgIHN0YXRzW25hbWVdID0ge1xuICAgICAgICBmcmVlOiBwb29sLnRvdGFsRnJlZSxcbiAgICAgICAgdXNlZDogcG9vbC50b3RhbFVzZWQsXG4gICAgICAgIHNpemU6IHBvb2wudG90YWxTaXplXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0cztcbiAgfVxufVxuY29uc3QgQmlnUG9vbCA9IG5ldyBQb29sR3JvdXBDbGFzcygpO1xuXG5leHBvcnQgeyBCaWdQb29sLCBQb29sR3JvdXBDbGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9vbEdyb3VwLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5906\n')},3921:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ sayHello)\n/* harmony export */ });\n/* unused harmony export VERSION */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3646);\n\n\n"use strict";\nlet saidHello = false;\nconst VERSION = "8.0.1";\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .z.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      "background: #E72264; padding:5px 0;",\n      "background: #6CA2EA; padding:5px 0;",\n      "background: #B5D33D; padding:5px 0;",\n      "background: #FED23F; padding:5px 0;",\n      "color: #FFFFFF; background: #E72264; padding:5px 0;",\n      "color: #E72264; background: #FFFFFF; padding:5px 0;"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\n\n//# sourceMappingURL=sayHello.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkyMS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlFQUFVO0FBQ2hCO0FBQ0EsdUNBQXVDLFNBQVMsR0FBRyxLQUFLOztBQUV4RDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLDRCQUE0QixjQUFjO0FBQzFDLHVCQUF1QixxQkFBcUIsY0FBYztBQUMxRCx1QkFBdUIscUJBQXFCLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsU0FBUyxJQUFJLE1BQU07QUFDeEQ7QUFDQTtBQUNBOztBQUU2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLW1vdXNlLWV2ZW50LXRyYW5zbWl0dGVyLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL3NheUhlbGxvLm1qcz82ZmU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xubGV0IHNhaWRIZWxsbyA9IGZhbHNlO1xuY29uc3QgVkVSU0lPTiA9IFwiOC4wLjFcIjtcbmZ1bmN0aW9uIHNheUhlbGxvKHR5cGUpIHtcbiAgaWYgKHNhaWRIZWxsbykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoRE9NQWRhcHRlci5nZXQoKS5nZXROYXZpZ2F0b3IoKS51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY2hyb21lXCIpID4gLTEpIHtcbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgYCVjICAlYyAgJWMgICVjICAlYyBQaXhpSlMgJWMgdiR7VkVSU0lPTn0gKCR7dHlwZX0pIGh0dHA6Ly93d3cucGl4aWpzLmNvbS9cblxuYCxcbiAgICAgIFwiYmFja2dyb3VuZDogI0U3MjI2NDsgcGFkZGluZzo1cHggMDtcIixcbiAgICAgIFwiYmFja2dyb3VuZDogIzZDQTJFQTsgcGFkZGluZzo1cHggMDtcIixcbiAgICAgIFwiYmFja2dyb3VuZDogI0I1RDMzRDsgcGFkZGluZzo1cHggMDtcIixcbiAgICAgIFwiYmFja2dyb3VuZDogI0ZFRDIzRjsgcGFkZGluZzo1cHggMDtcIixcbiAgICAgIFwiY29sb3I6ICNGRkZGRkY7IGJhY2tncm91bmQ6ICNFNzIyNjQ7IHBhZGRpbmc6NXB4IDA7XCIsXG4gICAgICBcImNvbG9yOiAjRTcyMjY0OyBiYWNrZ3JvdW5kOiAjRkZGRkZGOyBwYWRkaW5nOjVweCAwO1wiXG4gICAgXTtcbiAgICBnbG9iYWxUaGlzLmNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKGdsb2JhbFRoaXMuY29uc29sZSkge1xuICAgIGdsb2JhbFRoaXMuY29uc29sZS5sb2coYFBpeGlKUyAke1ZFUlNJT059IC0gJHt0eXBlfSAtIGh0dHA6Ly93d3cucGl4aWpzLmNvbS9gKTtcbiAgfVxuICBzYWlkSGVsbG8gPSB0cnVlO1xufVxuXG5leHBvcnQgeyBWRVJTSU9OLCBzYXlIZWxsbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2F5SGVsbG8ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3921\n')},1580:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2218);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4MC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXFDOztBQUVkO0FBQ3ZCLGlFQUFlLHNDQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtbW91c2UtZXZlbnQtdHJhbnNtaXR0ZXIvLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/N2E2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1580\n")}}]);